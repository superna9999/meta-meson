From 7d969210b2c0effefcee3a7dd94843e88ef4ea92 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 21 Jun 2017 18:50:58 +0800
Subject: [PATCH 067/134] drm/lima: soft reset gp/pp when task done

This can prevent some problem like last task state
affect current task which is also be done the the
original mali driver.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 drivers/gpu/drm/lima/lima.h       |  2 +
 drivers/gpu/drm/lima/lima_gp.c    | 89 ++++++++++++++++++++++----------------
 drivers/gpu/drm/lima/lima_pp.c    | 91 ++++++++++++++++++++++-----------------
 drivers/gpu/drm/lima/lima_sched.c |  9 +++-
 drivers/gpu/drm/lima/lima_sched.h |  2 +-
 5 files changed, 113 insertions(+), 80 deletions(-)

diff --git a/drivers/gpu/drm/lima/lima.h b/drivers/gpu/drm/lima/lima.h
index 6d99e94..88be7dc 100644
--- a/drivers/gpu/drm/lima/lima.h
+++ b/drivers/gpu/drm/lima/lima.h
@@ -68,11 +68,13 @@ struct lima_gp {
 	struct lima_sched_pipe pipe;
 
 	int task;
+	bool async_reset;
 };
 
 struct lima_pp_core {
 	struct lima_ip ip;
 	struct lima_mmu mmu;
+	bool async_reset;
 };
 
 #define LIMA_MAX_PP 4
diff --git a/drivers/gpu/drm/lima/lima_gp.c b/drivers/gpu/drm/lima/lima_gp.c
index a736636..9ecb459 100644
--- a/drivers/gpu/drm/lima/lima_gp.c
+++ b/drivers/gpu/drm/lima/lima_gp.c
@@ -134,6 +134,41 @@ static irqreturn_t lima_gp_irq_handler(int irq, void *data)
 	return IRQ_NONE;
 }
 
+static void lima_gp_soft_reset_async(struct lima_gp *gp)
+{
+	if (gp->async_reset)
+		return;
+
+	gp_write(INT_MASK, 0);
+	gp_write(INT_CLEAR, LIMA_GP_IRQ_RESET_COMPLETED);
+	gp_write(CMD, LIMA_GP_CMD_SOFT_RESET);
+	gp->async_reset = true;
+}
+
+static int lima_gp_soft_reset_async_wait(struct lima_gp *gp)
+{
+	struct lima_device *dev = gp->ip.dev;
+	int timeout;
+
+	if (!gp->async_reset)
+		return 0;
+
+	for (timeout = 1000; timeout > 0; timeout--) {
+		if (gp_read(INT_RAWSTAT) & LIMA_GP_IRQ_RESET_COMPLETED)
+			break;
+	}
+	if (!timeout) {
+		dev_err(dev->dev, "gp soft reset time out\n");
+		return -ETIMEDOUT;
+	}
+
+	gp_write(INT_CLEAR, LIMA_GP_IRQ_MASK_ALL);
+	gp_write(INT_MASK, LIMA_GP_IRQ_MASK_USED);
+
+	gp->async_reset = false;
+	return 0;
+}
+
 static int lima_gp_start_task(void *data, struct lima_sched_task *task)
 {
 	struct lima_gp *gp = data;
@@ -141,8 +176,6 @@ static int lima_gp_start_task(void *data, struct lima_sched_task *task)
 	struct drm_lima_m400_gp_frame *frame = task->frame;
 	u32 cmd = 0;
 
-	dev_info(dev->dev, "lima start task gp status %08x\n", gp_read(STATUS));
-
 	if (frame->vs_cmd_start > frame->vs_cmd_end ||
 	    frame->plbu_cmd_start > frame->plbu_cmd_end ||
 	    frame->tile_heap_start > frame->tile_heap_end)
@@ -163,6 +196,11 @@ static int lima_gp_start_task(void *data, struct lima_sched_task *task)
 		return -EINVAL;
 	}
 
+	/* before any hw ops, wait last success task async soft reset */
+	lima_gp_soft_reset_async_wait(gp);
+
+	dev_info(dev->dev, "lima start task gp status %08x\n", gp_read(STATUS));
+
 	gp_write(VSCL_START_ADDR, frame->vs_cmd_start);
 	gp_write(VSCL_END_ADDR, frame->vs_cmd_end);
 	gp_write(PLBUCL_START_ADDR, frame->plbu_cmd_start);
@@ -175,43 +213,11 @@ static int lima_gp_start_task(void *data, struct lima_sched_task *task)
 	return 0;
 }
 
-static int lima_gp_soft_reset(struct lima_gp *gp)
-{
-	struct lima_device *dev = gp->ip.dev;
-	int timeout;
-
-	gp_write(INT_MASK, 0);
-	gp_write(INT_CLEAR, LIMA_GP_IRQ_RESET_COMPLETED);
-	gp_write(CMD, LIMA_GP_CMD_SOFT_RESET);
-	for (timeout = 1000; timeout > 0; timeout--) {
-		if (gp_read(INT_RAWSTAT) & LIMA_GP_IRQ_RESET_COMPLETED)
-			break;
-	}
-	if (!timeout) {
-		dev_err(dev->dev, "gp reset time out\n");
-		return -ETIMEDOUT;
-	}
-
-	gp_write(INT_CLEAR, LIMA_GP_IRQ_MASK_ALL);
-	gp_write(INT_MASK, LIMA_GP_IRQ_MASK_USED);
-	return 0;
-}
-
 static int lima_gp_hard_reset(struct lima_gp *gp)
 {
 	struct lima_device *dev = gp->ip.dev;
 	int timeout;
 
-	gp_write(CMD, LIMA_GP_CMD_STOP_BUS);
-	for (timeout = 1000; timeout > 0; timeout--) {
-		if (gp_read(STATUS) & LIMA_GP_STATUS_BUS_STOPPED)
-			break;
-	}
-	if (!timeout) {
-		dev_err(dev->dev, "gp stop bus timeout\n");
-		return -ETIMEDOUT;
-	}
-
 	gp_write(PERF_CNT_0_LIMIT, 0xC0FFE000);
 	gp_write(INT_MASK, 0);
 	gp_write(CMD, LIMA_GP_CMD_RESET);
@@ -231,9 +237,14 @@ static int lima_gp_hard_reset(struct lima_gp *gp)
 	return 0;
 }
 
-static int lima_gp_reset(void *data)
+static int lima_gp_end_task(void *data, bool fail)
 {
-	return lima_gp_hard_reset(data);
+	/* when task fail, to hard reset, otherwise soft reset */
+	if (fail)
+		return lima_gp_hard_reset(data);
+
+	lima_gp_soft_reset_async(data);
+	return 0;
 }
 
 int lima_gp_init(struct lima_gp *gp)
@@ -241,7 +252,9 @@ int lima_gp_init(struct lima_gp *gp)
 	struct lima_device *dev = gp->ip.dev;
 	int err;
 
-	err = lima_gp_soft_reset(gp);
+	gp->async_reset = false;
+	lima_gp_soft_reset_async(gp);
+	err = lima_gp_soft_reset_async_wait(gp);
 	if (err)
 		return err;
 
@@ -253,7 +266,7 @@ int lima_gp_init(struct lima_gp *gp)
 	}
 
 	gp->pipe.start_task = lima_gp_start_task;
-	gp->pipe.reset = lima_gp_reset;
+	gp->pipe.end_task = lima_gp_end_task;
 	gp->pipe.data = gp;
 	gp->pipe.mmu[0] = &gp->mmu;
 	gp->pipe.num_mmu = 1;
diff --git a/drivers/gpu/drm/lima/lima_pp.c b/drivers/gpu/drm/lima/lima_pp.c
index 683d53d..86d741a 100644
--- a/drivers/gpu/drm/lima/lima_pp.c
+++ b/drivers/gpu/drm/lima/lima_pp.c
@@ -106,6 +106,42 @@ static irqreturn_t lima_pp_core_irq_handler(int irq, void *data)
 	return IRQ_NONE;
 }
 
+static void lima_pp_core_soft_reset_async(struct lima_pp_core *core)
+{
+	if (core->async_reset)
+		return;
+
+	pp_write(INT_MASK, 0);
+	pp_write(INT_RAWSTAT, LIMA_PP_IRQ_MASK_ALL);
+	pp_write(CTRL, LIMA_PP_CTRL_SOFT_RESET);
+	core->async_reset = true;
+}
+
+static int lima_pp_core_soft_reset_async_wait(struct lima_pp_core *core)
+{
+	struct lima_device *dev = core->ip.dev;
+	int timeout;
+
+	if (!core->async_reset)
+		return 0;
+
+	for (timeout = 1000; timeout > 0; timeout--) {
+		if (!(pp_read(STATUS) & LIMA_PP_STATUS_RENDERING_ACTIVE) &&
+		    pp_read(INT_RAWSTAT) == LIMA_PP_IRQ_RESET_COMPLETED)
+			break;
+	}
+	if (!timeout) {
+		dev_err(dev->dev, "gp reset time out\n");
+		return -ETIMEDOUT;
+	}
+
+	pp_write(INT_CLEAR, LIMA_PP_IRQ_MASK_ALL);
+	pp_write(INT_MASK, LIMA_PP_IRQ_MASK_USED);
+
+	core->async_reset = false;
+	return 0;
+}
+
 static void lima_pp_core_start_task(struct lima_pp_core *core, int index,
 				    struct lima_sched_task *task)
 {
@@ -115,6 +151,8 @@ static void lima_pp_core_start_task(struct lima_pp_core *core, int index,
 	const int num_frame_reg = 23, num_wb_reg = 12;
 	int i, j;
 
+	lima_pp_core_soft_reset_async_wait(core);
+
 	dev_info(dev->dev, "lima start task pp %s %08x\n", core->ip.name, pp_read(STATUS));
 
 	frame->frame.plbu_array_address = frame->plbu_array_address[index];
@@ -132,44 +170,11 @@ static void lima_pp_core_start_task(struct lima_pp_core *core, int index,
 	pp_write(CTRL, LIMA_PP_CTRL_START_RENDERING);
 }
 
-static int lima_pp_core_reset(struct lima_pp_core *core)
-{
-	struct lima_device *dev = core->ip.dev;
-	int timeout;
-
-	pp_write(INT_MASK, 0);
-	pp_write(INT_RAWSTAT, LIMA_PP_IRQ_MASK_ALL);
-	pp_write(CTRL, LIMA_PP_CTRL_SOFT_RESET);
-	for (timeout = 1000; timeout > 0; timeout--) {
-		if (!(pp_read(STATUS) & LIMA_PP_STATUS_RENDERING_ACTIVE) &&
-		    pp_read(INT_RAWSTAT) == LIMA_PP_IRQ_RESET_COMPLETED)
-			break;
-	}
-	if (!timeout) {
-		dev_err(dev->dev, "gp reset time out\n");
-		return -ETIMEDOUT;
-	}
-
-	pp_write(INT_CLEAR, LIMA_PP_IRQ_MASK_ALL);
-	pp_write(INT_MASK, LIMA_PP_IRQ_MASK_USED);
-	return 0;
-}
-
 static int lima_pp_core_hard_reset(struct lima_pp_core *core)
 {
 	struct lima_device *dev = core->ip.dev;
 	int timeout;
-/*
-	pp_write(CTRL, LIMA_PP_CTRL_STOP_BUS);
-	for (timeout = 1000; timeout > 0; timeout--) {
-		if (pp_read(STATUS) & LIMA_PP_STATUS_BUS_STOPPED)
-			break;
-	}
-	if (!timeout) {
-		dev_err(dev->dev, "pp stop bus timeout\n");
-		return -ETIMEDOUT;
-	}
-*/
+
 	pp_write(PERF_CNT_0_LIMIT, 0xC0FFE000);
 	pp_write(INT_MASK, 0);
 	pp_write(CTRL, LIMA_PP_CTRL_FORCE_RESET);
@@ -194,7 +199,9 @@ int lima_pp_core_init(struct lima_pp_core *core)
 	struct lima_device *dev = core->ip.dev;
 	int err;
 
-	err = lima_pp_core_reset(core);
+	core->async_reset = false;
+	lima_pp_core_soft_reset_async(core);
+	err = lima_pp_core_soft_reset_async_wait(core);
 	if (err)
 		return err;
 
@@ -226,13 +233,19 @@ static int lima_pp_start_task(void *data, struct lima_sched_task *task)
 	return 0;
 }
 
-static int lima_pp_reset(void *data)
+static int lima_pp_end_task(void *data, bool fail)
 {
 	struct lima_pp *pp = data;
-	int i;
+	int i, err = 0;
+
+	if (fail) {
+		for (i = 0; i < pp->num_core; i++)
+			err |= lima_pp_core_hard_reset(pp->core + i);
+		return err;
+	}
 
 	for (i = 0; i < pp->num_core; i++)
-		lima_pp_core_hard_reset(pp->core + i);
+		lima_pp_core_soft_reset_async(pp->core + i);
 	return 0;
 }
 
@@ -241,7 +254,7 @@ void lima_pp_init(struct lima_pp *pp)
 	int i;
 
 	pp->pipe.start_task = lima_pp_start_task;
-	pp->pipe.reset = lima_pp_reset;
+	pp->pipe.end_task = lima_pp_end_task;
 	pp->pipe.data = pp;
 
 	for (i = 0; i < pp->num_core; i++)
diff --git a/drivers/gpu/drm/lima/lima_sched.c b/drivers/gpu/drm/lima/lima_sched.c
index aad6ba3..72462d4 100644
--- a/drivers/gpu/drm/lima/lima_sched.c
+++ b/drivers/gpu/drm/lima/lima_sched.c
@@ -239,12 +239,17 @@ static int lima_sched_pipe_worker(void *param)
 		pipe->worker_is_busy = true;
 		pipe->worker_has_error = false;
 		if (!pipe->start_task(pipe->data, task)) {
+			bool fail;
+
 			ret = lima_sched_pipe_worker_wait_busy(pipe);
 			if (ret == -ERESTARTSYS)
 				return 0;
-			if (ret < 0 || pipe->worker_has_error) {
+
+			fail = ret < 0 || pipe->worker_has_error;
+			pipe->end_task(pipe->data, fail);
+
+			if (fail) {
 				DRM_INFO("lima worker wait task error\n");
-				pipe->reset(pipe->data);
 				for (i = 0; i < pipe->num_mmu; i++)
 					lima_mmu_page_fault_resume(pipe->mmu[i]);
 			}
diff --git a/drivers/gpu/drm/lima/lima_sched.h b/drivers/gpu/drm/lima/lima_sched.h
index fef66f5..1c09fcc 100644
--- a/drivers/gpu/drm/lima/lima_sched.h
+++ b/drivers/gpu/drm/lima/lima_sched.h
@@ -59,7 +59,7 @@ struct lima_sched_pipe {
 	u32 fence_done_seqno;
 
 	int (*start_task)(void *data, struct lima_sched_task *task);
-	int (*reset)(void *data);
+	int (*end_task)(void *data, bool fail);
 	void *data;
 };
 
-- 
2.0.1

