From 0ac78b7ca65fea3cf1cb535b2bb173a9873d7e54 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 8 May 2018 16:57:33 +0800
Subject: [PATCH 134/134] drm/lima: remove reg definition from lima_drm.h

Reg definition may change from time to time as
this is a reverse engineering project.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 drivers/gpu/drm/lima/lima_gp.c | 38 +++++++++++++-----------
 drivers/gpu/drm/lima/lima_pp.c | 29 +++++++------------
 include/uapi/drm/lima_drm.h    | 65 +++++++-----------------------------------
 3 files changed, 44 insertions(+), 88 deletions(-)

diff --git a/drivers/gpu/drm/lima/lima_gp.c b/drivers/gpu/drm/lima/lima_gp.c
index 540e23f..5ab015d 100644
--- a/drivers/gpu/drm/lima/lima_gp.c
+++ b/drivers/gpu/drm/lima/lima_gp.c
@@ -208,16 +208,22 @@ static int lima_gp_soft_reset_async_wait(struct lima_ip *ip)
 static int lima_gp_task_validate(struct lima_sched_pipe *pipe,
 				 struct lima_sched_task *task)
 {
-	struct drm_lima_m400_gp_frame *f = task->frame;
+	struct drm_lima_gp_frame *frame = task->frame;
+	u32 *f = frame->frame;
 	(void)pipe;
 
-	if (f->vs_cmd_start > f->vs_cmd_end ||
-	    f->plbu_cmd_start > f->plbu_cmd_end ||
-	    f->tile_heap_start > f->tile_heap_end)
+	if (f[LIMA_GP_VSCL_START_ADDR >> 2] >
+	    f[LIMA_GP_VSCL_END_ADDR >> 2] ||
+	    f[LIMA_GP_PLBUCL_START_ADDR >> 2] >
+	    f[LIMA_GP_PLBUCL_END_ADDR >> 2] ||
+	    f[LIMA_GP_PLBU_ALLOC_START_ADDR >> 2] >
+	    f[LIMA_GP_PLBU_ALLOC_END_ADDR >> 2])
 		return -EINVAL;
 
-	if (f->vs_cmd_start == f->vs_cmd_end &&
-	    f->plbu_cmd_start == f->plbu_cmd_end)
+	if (f[LIMA_GP_VSCL_START_ADDR >> 2] ==
+	    f[LIMA_GP_VSCL_END_ADDR >> 2] &&
+	    f[LIMA_GP_PLBUCL_START_ADDR >> 2] ==
+	    f[LIMA_GP_PLBUCL_END_ADDR >> 2])
 		return -EINVAL;
 
 	return 0;
@@ -227,23 +233,23 @@ static void lima_gp_task_run(struct lima_sched_pipe *pipe,
 			     struct lima_sched_task *task)
 {
 	struct lima_ip *ip = pipe->processor[0];
-	struct drm_lima_m400_gp_frame *frame = task->frame;
+	struct drm_lima_gp_frame *frame = task->frame;
+	u32 *f = frame->frame;
 	u32 cmd = 0;
+	int i;
 
-	if (frame->vs_cmd_start != frame->vs_cmd_end)
+	if (f[LIMA_GP_VSCL_START_ADDR >> 2] !=
+	    f[LIMA_GP_VSCL_END_ADDR >> 2])
 		cmd |= LIMA_GP_CMD_START_VS;
-	if (frame->plbu_cmd_start != frame->plbu_cmd_end)
+	if (f[LIMA_GP_PLBUCL_START_ADDR >> 2] !=
+	    f[LIMA_GP_PLBUCL_END_ADDR >> 2])
 		cmd |= LIMA_GP_CMD_START_PLBU;
 
 	/* before any hw ops, wait last success task async soft reset */
 	lima_gp_soft_reset_async_wait(ip);
 
-	gp_write(VSCL_START_ADDR, frame->vs_cmd_start);
-	gp_write(VSCL_END_ADDR, frame->vs_cmd_end);
-	gp_write(PLBUCL_START_ADDR, frame->plbu_cmd_start);
-	gp_write(PLBUCL_END_ADDR, frame->plbu_cmd_end);
-	gp_write(PLBU_ALLOC_START_ADDR, frame->tile_heap_start);
-	gp_write(PLBU_ALLOC_END_ADDR, frame->tile_heap_end);
+	for (i = 0; i < LIMA_GP_FRAME_REG_NUM; i++)
+		writel(f[i], ip->iomem + LIMA_GP_VSCL_START_ADDR + i * 4);
 
 	gp_write(CMD, LIMA_GP_CMD_UPDATE_PLBU_ALLOC);
 	gp_write(CMD, cmd);
@@ -351,7 +357,7 @@ void lima_gp_fini(struct lima_ip *ip)
 
 int lima_gp_pipe_init(struct lima_device *dev)
 {
-	int frame_size = sizeof(struct drm_lima_m400_gp_frame);
+	int frame_size = sizeof(struct drm_lima_gp_frame);
 	struct lima_sched_pipe *pipe = dev->pipe + lima_pipe_gp;
 
 	if (!lima_gp_task_slab) {
diff --git a/drivers/gpu/drm/lima/lima_pp.c b/drivers/gpu/drm/lima/lima_pp.c
index 7d8b0ab..a71a870 100644
--- a/drivers/gpu/drm/lima/lima_pp.c
+++ b/drivers/gpu/drm/lima/lima_pp.c
@@ -243,27 +243,21 @@ static int lima_pp_soft_reset_async_wait(struct lima_ip *ip)
 	return err;
 }
 
-static void lima_pp_start_task(struct lima_ip *ip,
-			       struct drm_lima_pp_frame_reg *frame,
-			       struct drm_lima_pp_wb_reg *wb,
+static void lima_pp_start_task(struct lima_ip *ip, u32 *frame, u32 *wb,
 			       bool skip_stack_addr)
 {
-	const int num_frame_reg = 23, num_wb_reg = 12;
-	int i, j;
-
-	for (i = 0; i < num_frame_reg; i++) {
-		u32 *frame_reg = (void *)frame;
+	int i, j, n = 0;
 
+	for (i = 0; i < LIMA_PP_FRAME_REG_NUM; i++) {
 		if (skip_stack_addr && i * 4 == LIMA_PP_STACK)
 			continue;
 
-		writel(frame_reg[i], ip->iomem + LIMA_PP_FRAME + i * 4);
+		writel(frame[i], ip->iomem + LIMA_PP_FRAME + i * 4);
 	}
 
 	for (i = 0; i < 3; i++) {
-		u32 *wb_reg = (void *)(wb + i);
-		for (j = 0; j < num_wb_reg; j++)
-			writel(wb_reg[j], ip->iomem + LIMA_PP_WB(i) + j * 4);
+		for (j = 0; j < LIMA_PP_WB_REG_NUM; j++)
+			writel(wb[n++], ip->iomem + LIMA_PP_WB(i) + j * 4);
 	}
 
 	pp_write(CTRL, LIMA_PP_CTRL_START_RENDERING);
@@ -396,7 +390,7 @@ static void lima_pp_task_run(struct lima_sched_pipe *pipe,
 		pipe->done = 0;
 		atomic_set(&pipe->task, pipe->num_processor);
 
-		frame->frame.plbu_array_address = LIMA_VA_RESERVE_DLBU;
+		frame->frame[LIMA_PP_FRAME >> 2] = LIMA_VA_RESERVE_DLBU;
 		lima_dlbu_set_reg(dev->ip + lima_ip_dlbu, frame->dlbu_regs);
 
 		lima_pp_soft_reset_async_wait(pipe->bcast_processor);
@@ -406,7 +400,7 @@ static void lima_pp_task_run(struct lima_sched_pipe *pipe,
 			pp_write(STACK, frame->fragment_stack_address[i]);
 		}
 
-		lima_pp_start_task(pipe->bcast_processor, &frame->frame,
+		lima_pp_start_task(pipe->bcast_processor, frame->frame,
 				   frame->wb, true);
 	}
 	else {
@@ -416,15 +410,14 @@ static void lima_pp_task_run(struct lima_sched_pipe *pipe,
 		atomic_set(&pipe->task, frame->num_pp);
 
 		for (i = 0; i < frame->num_pp; i++) {
-			frame->frame.plbu_array_address =
+			frame->frame[LIMA_PP_FRAME >> 2] =
 				frame->plbu_array_address[i];
-			frame->frame.fragment_stack_address =
+			frame->frame[LIMA_PP_STACK >> 2] =
 				frame->fragment_stack_address[i];
 
 			lima_pp_soft_reset_async_wait(pipe->processor[i]);
 
-			lima_pp_start_task(pipe->processor[i],
-					   &frame->frame,
+			lima_pp_start_task(pipe->processor[i], frame->frame,
 					   frame->wb, false);
 		}
 	}
diff --git a/include/uapi/drm/lima_drm.h b/include/uapi/drm/lima_drm.h
index 81907a4..cfe5596 100644
--- a/include/uapi/drm/lima_drm.h
+++ b/include/uapi/drm/lima_drm.h
@@ -1,5 +1,4 @@
 /*
- * Copyright (c) 2011-2013 Luc Verhaegen <libv@skynet.be>
  * Copyright (C) 2017 Lima Project
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -70,69 +69,27 @@ struct drm_lima_gem_submit_bo {
 	__u32 flags;   /* in */
 };
 
-struct drm_lima_m400_gp_frame {
-	__u32 vs_cmd_start;
-	__u32 vs_cmd_end;
-	__u32 plbu_cmd_start;
-	__u32 plbu_cmd_end;
-	__u32 tile_heap_start;
-	__u32 tile_heap_end;
-};
+#define LIMA_GP_FRAME_REG_NUM 6
 
-struct drm_lima_pp_frame_reg {
-	__u32 plbu_array_address;
-	__u32 render_address;
-	__u32 unused_0;
-	__u32 flags;
-	__u32 clear_value_depth;
-	__u32 clear_value_stencil;
-	__u32 clear_value_color;
-	__u32 clear_value_color_1;
-	__u32 clear_value_color_2;
-	__u32 clear_value_color_3;
-	__u32 width;
-	__u32 height;
-	__u32 fragment_stack_address;
-	__u32 fragment_stack_size;
-	__u32 unused_1;
-	__u32 unused_2;
-	__u32 one;
-	__u32 supersampled_height;
-	__u32 dubya;
-	__u32 onscreen;
-	__u32 blocking;
-	__u32 scale;
-	__u32 foureight;
-	__u32 _pad;
+struct drm_lima_gp_frame {
+	__u32 frame[LIMA_GP_FRAME_REG_NUM];
 };
 
-struct drm_lima_pp_wb_reg {
-	__u32 type;
-	__u32 address;
-	__u32 pixel_format;
-	__u32 downsample_factor;
-	__u32 pixel_layout;
-	__u32 pitch;
-	__u32 mrt_bits;
-	__u32 mrt_pitch;
-	__u32 zero;
-	__u32 unused0;
-	__u32 unused1;
-	__u32 unused2;
-};
+#define LIMA_PP_FRAME_REG_NUM 23
+#define LIMA_PP_WB_REG_NUM 12
 
 struct drm_lima_m400_pp_frame {
-	struct drm_lima_pp_frame_reg frame;
-	struct drm_lima_pp_wb_reg wb[3];
+	__u32 frame[LIMA_PP_FRAME_REG_NUM];
+	__u32 num_pp;
+	__u32 wb[3 * LIMA_PP_WB_REG_NUM];
 	__u32 plbu_array_address[4];
 	__u32 fragment_stack_address[4];
-	__u32 num_pp;
-	__u32 _pad;
 };
 
 struct drm_lima_m450_pp_frame {
-	struct drm_lima_pp_frame_reg frame;
-	struct drm_lima_pp_wb_reg wb[3];
+	__u32 frame[LIMA_PP_FRAME_REG_NUM];
+	__u32 _pad;
+	__u32 wb[3 * LIMA_PP_WB_REG_NUM];
 	__u32 dlbu_regs[4];
 	__u32 fragment_stack_address[8];
 };
-- 
2.0.1

