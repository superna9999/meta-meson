From 0ae00c56f91fb3b703ea4f64e7b0039a76117482 Mon Sep 17 00:00:00 2001
From: Maxime Jourdan <maxi.jourdan@wanadoo.fr>
Date: Tue, 3 Apr 2018 15:04:40 +0200
Subject: [PATCH] meson: vdec: Initial HEVC WIP. Fully broken.

The code changes were getting big so push the initial WIP.
Everything is still configured so that you can use H.264.
There are still sooo many things to clean up and modularize better..

* Add V4L2_PIX_FMT_HEVC
* Add clocks necessary for VDEC_HEVC
* Add WIP for HEVC. Still missing a lot of logic, and for power/clk you still need to change the pwrc.
* Add GXL vh265_mc firmware
* Move load_firmware to the VDEC units since each has its own registers.
* Move stbuf init to the VDEC units since they handle it differently
* Fix 2 bugs that could have affected H.264 (firmware DMA_COUNT and bad reg base for a esparser register)
* Implement vdec_enum_framesizes and bump max width/height to 3840*2160.

TODO:

* Apply narmstrong suggestion in the dts for clocks
* Drop meson-pwrc-vdec and handle it in the driver. Each VDEC unit needs its own power management and clks,
and ultimately we want dfs.
* Clean up esparser init logic since each vdec handles it differently
* Use the PARSER RESET
* Add max width/height to vdec_formats
* Define vdec_formats differently for each compatible entry
---
 arch/arm64/boot/dts/amlogic/meson-gxl.dtsi    |  10 +-
 drivers/clk/meson/gxbb.c                      |  51 ++
 drivers/clk/meson/gxbb.h                      |   3 +-
 drivers/media/platform/meson/vdec/Makefile    |   2 +-
 drivers/media/platform/meson/vdec/esparser.c  |  48 +-
 drivers/media/platform/meson/vdec/h264.c      |  29 +-
 drivers/media/platform/meson/vdec/hevc.c      | 363 +++++++++++++
 drivers/media/platform/meson/vdec/hevc.h      |   8 +
 drivers/media/platform/meson/vdec/hevc_regs.h | 754 ++++++++++++++++++++++++++
 drivers/media/platform/meson/vdec/vdec.c      | 132 ++---
 drivers/media/platform/meson/vdec/vdec_1.c    | 128 ++++-
 drivers/media/platform/meson/vdec/vdec_hevc.c | 139 +++++
 drivers/media/platform/meson/vdec/vdec_hevc.h |   8 +
 include/dt-bindings/clock/gxbb-clkc.h         |   2 +
 include/uapi/linux/videodev2.h                |   1 +
 vh265_mc                                      | Bin 0 -> 16384 bytes
 16 files changed, 1519 insertions(+), 159 deletions(-)
 create mode 100644 drivers/media/platform/meson/vdec/hevc.c
 create mode 100644 drivers/media/platform/meson/vdec/hevc.h
 create mode 100644 drivers/media/platform/meson/vdec/hevc_regs.h
 create mode 100644 drivers/media/platform/meson/vdec/vdec_hevc.c
 create mode 100644 drivers/media/platform/meson/vdec/vdec_hevc.h
 create mode 100644 vh265_mc

diff --git a/arch/arm64/boot/dts/amlogic/meson-gxl.dtsi b/arch/arm64/boot/dts/amlogic/meson-gxl.dtsi
index 0ea9508..019e2d8 100644
--- a/arch/arm64/boot/dts/amlogic/meson-gxl.dtsi
+++ b/arch/arm64/boot/dts/amlogic/meson-gxl.dtsi
@@ -811,9 +811,11 @@
 };
 
 &pwrc_vdec {
-	clocks = <&clkc CLKID_VPU_INTR>, <&clkc CLKID_DOS_PARSER>, <&clkc CLKID_VDEC_1>;
-	clock-names = "vpu_intr", "dos_parser", "vdec_1";
+	clocks = <&clkc CLKID_VPU_INTR>, <&clkc CLKID_DOS_PARSER>, <&clkc CLKID_VDEC_1>, <&clkc CLKID_VDEC_HEVC>;
+	clock-names = "vpu_intr", "dos_parser", "vdec_1", "vdec_hevc";
 
-	assigned-clocks = <&clkc CLKID_VDEC_1>;
-	assigned-clock-rates = <648000000>;
+	assigned-clocks = <&clkc CLKID_VDEC_1>,
+			  <&clkc CLKID_VDEC_HEVC>;
+	assigned-clock-rates = <648000000>,
+			       <648000000>;
 };
diff --git a/drivers/clk/meson/gxbb.c b/drivers/clk/meson/gxbb.c
index f08066d..2422d06 100644
--- a/drivers/clk/meson/gxbb.c
+++ b/drivers/clk/meson/gxbb.c
@@ -1592,6 +1592,48 @@ static struct clk_gate gxbb_vdec_1 = {
 	},
 };
 
+static struct clk_mux gxbb_vdec_hevc_sel = {
+	.reg = (void *)HHI_VDEC2_CLK_CNTL,
+	.mask = 0x3,
+	.shift = 25,
+	.lock = &meson_clk_lock,
+	.table = mux_table_vdec,
+	.hw.init = &(struct clk_init_data){
+		.name = "vdec_hevc_sel",
+		.ops = &clk_mux_ops,
+		.parent_names = gxbb_vdec_parent_names,
+		.num_parents = ARRAY_SIZE(gxbb_vdec_parent_names),
+		.flags = CLK_SET_RATE_NO_REPARENT,
+	},
+};
+
+static struct clk_divider gxbb_vdec_hevc_div = {
+	.reg = (void *)HHI_VDEC2_CLK_CNTL,
+	.shift = 16,
+	.width = 7,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "vdec_hevc_div",
+		.ops = &clk_divider_ops,
+		.parent_names = (const char *[]){ "vdec_hevc_sel" },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_gate gxbb_vdec_hevc = {
+	.reg = (void *)HHI_VDEC2_CLK_CNTL,
+	.bit_idx = 24,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data) {
+		.name = "vdec_hevc",
+		.ops = &clk_gate_ops,
+		.parent_names = (const char *[]){ "vdec_hevc_div" },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
 /* Everything Else (EE) domain gates */
 static MESON_GATE(gxbb_ddr, HHI_GCLK_MPEG0, 0);
 static MESON_GATE(gxbb_dos, HHI_GCLK_MPEG0, 1);
@@ -1838,6 +1880,9 @@ static struct clk_hw_onecell_data gxbb_hw_onecell_data = {
 		[CLKID_VDEC_1_SEL]	    = &gxbb_vdec_1_sel.hw,
 		[CLKID_VDEC_1_DIV]          = &gxbb_vdec_1_div.hw,
 		[CLKID_VDEC_1]         	    = &gxbb_vdec_1.hw,
+		[CLKID_VDEC_HEVC_SEL]	    = &gxbb_vdec_hevc_sel.hw,
+		[CLKID_VDEC_HEVC_DIV]	    = &gxbb_vdec_hevc_div.hw,
+		[CLKID_VDEC_HEVC]	    = &gxbb_vdec_hevc.hw,
 		[NR_CLKS]		    = NULL,
 	},
 	.num = NR_CLKS,
@@ -1997,6 +2042,9 @@ static struct clk_hw_onecell_data gxl_hw_onecell_data = {
 		[CLKID_VDEC_1_SEL]	    = &gxbb_vdec_1_sel.hw,
 		[CLKID_VDEC_1_DIV]          = &gxbb_vdec_1_div.hw,
 		[CLKID_VDEC_1]         	    = &gxbb_vdec_1.hw,
+		[CLKID_VDEC_HEVC_SEL]	    = &gxbb_vdec_hevc_sel.hw,
+		[CLKID_VDEC_HEVC_DIV]	    = &gxbb_vdec_hevc_div.hw,
+		[CLKID_VDEC_HEVC]	    = &gxbb_vdec_hevc.hw,
 		[NR_CLKS]		    = NULL,
 	},
 	.num = NR_CLKS,
@@ -2158,6 +2206,9 @@ static struct clk_regmap *const gx_clk_regmaps[] = {
 	&gxbb_vdec_1_sel,
 	&gxbb_vdec_1_div,
 	&gxbb_vdec_1,
+	&gxbb_vdec_hevc_sel,
+	&gxbb_vdec_hevc_div,
+	&gxbb_vdec_hevc,
 };
 
 struct clkc_data {
diff --git a/drivers/clk/meson/gxbb.h b/drivers/clk/meson/gxbb.h
index 32045ee..ae21d23 100644
--- a/drivers/clk/meson/gxbb.h
+++ b/drivers/clk/meson/gxbb.h
@@ -205,8 +205,9 @@
 #define CLKID_FCLK_DIV5_DIV	  149
 #define CLKID_FCLK_DIV7_DIV	  150
 #define CLKID_VDEC_1_DIV	  152
+#define CLKID_VDEC_HEVC_DIV	  155
 
-#define NR_CLKS			  154
+#define NR_CLKS			  157
 
 /* include the CLKIDs that have been made part of the DT binding */
 #include <dt-bindings/clock/gxbb-clkc.h>
diff --git a/drivers/media/platform/meson/vdec/Makefile b/drivers/media/platform/meson/vdec/Makefile
index b0f4687..4a4ac15 100644
--- a/drivers/media/platform/meson/vdec/Makefile
+++ b/drivers/media/platform/meson/vdec/Makefile
@@ -1,7 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 # Makefile for Qualcomm Venus driver
 
-meson-vdec-objs += vdec.o vdec_1.o esparser.o canvas.o h264.o
+meson-vdec-objs += vdec.o vdec_1.o esparser.o canvas.o h264.o vdec_hevc.o hevc.o
 
 obj-$(CONFIG_VIDEO_AML_MESON_VDEC) += meson-vdec.o
 
diff --git a/drivers/media/platform/meson/vdec/esparser.c b/drivers/media/platform/meson/vdec/esparser.c
index e8ff66d..1cba1f3 100644
--- a/drivers/media/platform/meson/vdec/esparser.c
+++ b/drivers/media/platform/meson/vdec/esparser.c
@@ -49,24 +49,9 @@
 #define PARSER_FETCH_CMD  0x8
 	#define FETCH_ENDIAN_BIT	  27
 
-/* DOS REGS */
-#define DOS_GEN_CTRL0 0xfc08
-
-/* Stream Buffer (stbuf) regs (DOS) */
-#define POWER_CTL_VLD 0x3020
-#define VLD_MEM_VIFIFO_START_PTR 0x3100
-#define VLD_MEM_VIFIFO_CURR_PTR 0x3104
-#define VLD_MEM_VIFIFO_END_PTR 0x3108
-#define VLD_MEM_VIFIFO_CONTROL 0x3110
-	#define MEM_FIFO_CNT_BIT	16
-	#define MEM_FILL_ON_LEVEL	BIT(10)
-	#define MEM_CTRL_EMPTY_EN	BIT(2)
-	#define MEM_CTRL_FILL_EN	BIT(1)
-#define VLD_MEM_VIFIFO_WP 0x3114
-#define VLD_MEM_VIFIFO_RP 0x3118
+/* STBUF regs */
 #define VLD_MEM_VIFIFO_BUF_CNTL 0x3120
 	#define MEM_BUFCTRL_MANUAL	BIT(1)
-#define VLD_MEM_VIFIFO_WRAP_COUNT 0x3144
 
 #define SEARCH_PATTERN_LEN   512
 
@@ -205,6 +190,7 @@ int esparser_queue(void *data) {
 
 int esparser_power_up(struct vdec_session *sess) {
 	struct vdec_core *core = sess->core;
+
 	// WRITE_MPEG_REG(FEC_INPUT_CONTROL, 0);
 	writel_relaxed((10 << PS_CFG_PFIFO_EMPTY_CNT_BIT) |
 				(1  << PS_CFG_MAX_ES_WR_CYCLE_BIT) |
@@ -228,10 +214,7 @@ int esparser_power_up(struct vdec_session *sess) {
 	/* parser video */
 	writel_relaxed(sess->vififo_paddr, core->esparser_base + PARSER_VIDEO_START_PTR);
 	writel_relaxed(sess->vififo_paddr + sess->vififo_size, core->esparser_base + PARSER_VIDEO_END_PTR);
-	writel_relaxed(readl_relaxed(core->dos_base + PARSER_ES_CONTROL) & ~1, core->dos_base + PARSER_ES_CONTROL);
-	writel_relaxed(1, core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL);
-	writel_relaxed(readl_relaxed(core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL) & ~1, core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL);
-	writel_relaxed(0, core->dos_base + DOS_GEN_CTRL0); // set vififo_vbuf_rp_sel=>vdec
+	writel_relaxed(readl_relaxed(core->esparser_base + PARSER_ES_CONTROL) & ~1, core->esparser_base + PARSER_ES_CONTROL);
 	
 	writel_relaxed(0xffff, core->esparser_base + PARSER_INT_STATUS);
 	writel_relaxed(1 << PARSER_INT_HOST_EN_BIT, core->esparser_base + PARSER_INT_ENABLE);
@@ -239,31 +222,6 @@ int esparser_power_up(struct vdec_session *sess) {
 	return 0;
 }
 
-int stbuf_power_up(struct vdec_session *sess) {
-	struct vdec_core *core = sess->core;
-
-	writel_relaxed(0, core->dos_base + VLD_MEM_VIFIFO_CONTROL);
-	writel_relaxed(0, core->dos_base + VLD_MEM_VIFIFO_WRAP_COUNT);
-	writel_relaxed(1 << 4, core->dos_base + POWER_CTL_VLD);
-
-	writel_relaxed(sess->vififo_paddr, core->dos_base + VLD_MEM_VIFIFO_START_PTR);
-	writel_relaxed(sess->vififo_paddr, core->dos_base + VLD_MEM_VIFIFO_CURR_PTR);
-	writel_relaxed(sess->vififo_paddr + sess->vififo_size - 8, core->dos_base + VLD_MEM_VIFIFO_END_PTR);
-
-	writel_relaxed(readl_relaxed(core->dos_base + VLD_MEM_VIFIFO_CONTROL) |  1, core->dos_base + VLD_MEM_VIFIFO_CONTROL);
-	writel_relaxed(readl_relaxed(core->dos_base + VLD_MEM_VIFIFO_CONTROL) & ~1, core->dos_base + VLD_MEM_VIFIFO_CONTROL);
-
-	writel_relaxed(MEM_BUFCTRL_MANUAL, core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL);
-	writel_relaxed(sess->vififo_paddr, core->dos_base + VLD_MEM_VIFIFO_WP);
-
-	writel_relaxed(readl_relaxed(core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL) |  1, core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL);
-	writel_relaxed(readl_relaxed(core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL) & ~1, core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL);
-
-	writel_relaxed(readl_relaxed(core->dos_base + VLD_MEM_VIFIFO_CONTROL) | (0x11 << MEM_FIFO_CNT_BIT) | MEM_FILL_ON_LEVEL | MEM_CTRL_FILL_EN | MEM_CTRL_EMPTY_EN, core->dos_base + VLD_MEM_VIFIFO_CONTROL);
-
-	return 0;
-}
-
 int esparser_init(struct platform_device *pdev, struct vdec_core *core) {
 	int ret;
 	int irq;
diff --git a/drivers/media/platform/meson/vdec/h264.c b/drivers/media/platform/meson/vdec/h264.c
index 060db55..8b5d06c 100644
--- a/drivers/media/platform/meson/vdec/h264.c
+++ b/drivers/media/platform/meson/vdec/h264.c
@@ -39,6 +39,7 @@
 #define AV_SCRATCH_D  0x2734
 #define AV_SCRATCH_F  0x273c
 #define AV_SCRATCH_G  0x2740
+#define AV_SCRATCH_H  0x2744
 
 #define POWER_CTL_VLD 0x3020
 
@@ -63,7 +64,7 @@ struct vdec_h264 {
 	void      *ref_vaddr;
 	dma_addr_t ref_paddr;
 	u32	   ref_size;
-	
+
 	/* Housekeeping thread for marking buffers to DONE
 	 * and recycling them into the hardware
 	 */
@@ -102,9 +103,7 @@ static int vdec_h264_buffers_thread(void *data)
 			printk("Buffer %d done\n", tmp->index);
 
 			v4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_DONE);
-
 			list_del(&tmp->list);
-
 			kfree(tmp);
 		}
 		spin_unlock_irqrestore(&sess->bufs_spinlock, flags);
@@ -147,7 +146,7 @@ static int vdec_h264_start(struct vdec_session *sess) {
 	printk("vdec_h264_start\n");
 	
 	/* Allocate a "post canvas", purpose unknown */
-	h264->post_canvas_vaddr = dma_alloc_coherent(core->dev_dec, SIZE_POST_CNV, &h264->post_canvas_paddr, GFP_KERNEL);
+	h264->post_canvas_vaddr = dma_alloc_coherent(core->dev, SIZE_POST_CNV, &h264->post_canvas_paddr, GFP_KERNEL);
 	if (!h264->post_canvas_paddr) {
 		printk("Failed to request post canvas\n");
 		return -ENOMEM;
@@ -155,7 +154,7 @@ static int vdec_h264_start(struct vdec_session *sess) {
 	printk("Allocated post canvas: %08X - %08X\n", h264->post_canvas_paddr, h264->post_canvas_paddr + SIZE_POST_CNV);
 	
 	/* Allocate some memory for the H.264 decoder's state */
-	h264->workspace_vaddr = dma_alloc_coherent(core->dev_dec, SIZE_WORKSPACE, &h264->workspace_paddr, GFP_KERNEL);
+	h264->workspace_vaddr = dma_alloc_coherent(core->dev, SIZE_WORKSPACE, &h264->workspace_paddr, GFP_KERNEL);
 	if (!h264->workspace_vaddr) {
 		printk("Failed to request H.264 Workspace\n");
 		ret = -ENOMEM;
@@ -317,7 +316,7 @@ static void vdec_h264_set_param(struct vdec_session *sess) {
 	mb_height = (mb_height + 3) & 0xfffffffc;
 	mb_total = mb_width * mb_height;
 
-	/* Setup NV21 canvases for Decoded Picture Buffer (dpb)
+	/* Setup NV12 canvases for Decoded Picture Buffer (dpb)
 	 * Map them to the user buffers' planes
 	 */
 	printk("Configuring %d canvases..\n", actual_dpb_size*2);
@@ -339,12 +338,10 @@ static void vdec_h264_set_param(struct vdec_session *sess) {
 				(cnv_y_idx), core->dos_base + ANC0_CANVAS_ADDR + buf_idx*4);
 	}
 
-	if (max_reference_size >= max_dpb_size) {
+	if (max_reference_size >= max_dpb_size)
 		max_dpb_size = max_reference_size;
-		max_reference_size++;
-	} else {
-		max_reference_size = max_dpb_size + 1;
-	}
+
+	max_reference_size++;
 
 	/* I don't really know the purpose of this post canvas.
 	 * It seems required with the write to AV_SCRATCH_3 though..
@@ -393,6 +390,7 @@ static irqreturn_t vdec_h264_isr(struct vdec_session *sess)
 	unsigned int cpu_cmd;
 	unsigned int buffer_index;
 	int i;
+	u32 slice_type;
 	struct vdec_core *core = sess->core;
 
 	writel_relaxed(1, core->dos_base + ASSIST_MBOX1_CLR_REG);
@@ -406,18 +404,21 @@ static irqreturn_t vdec_h264_isr(struct vdec_session *sess)
 		int error_count, error, num_frame, status, eos = 0;
 		error_count = readl_relaxed(core->dos_base + AV_SCRATCH_D);
 		num_frame = (cpu_cmd >> 8) & 0xff;
-		if (error_count) {
+		if (error_count)
 			printk("decoder error(s) happened, count %d\n", error_count);
-		}
 
 		//printk("Decoded %d frames\n", num_frame);
 
 		for (i = 0 ; (i < num_frame) && (!eos) ; i++) {
-
+			slice_type = (readl_relaxed(core->dos_base + AV_SCRATCH_H) >> (i * 4)) & 0xf;
 			status = readl_relaxed(core->dos_base + AV_SCRATCH_1 + i*4);
 			buffer_index = status & 0x1f;
 			error = status & 0x200;
 
+			/* A buffer decode error means it was decoded,
+			 * but part of the picture will have artifacts.
+			 * Typical reason is a temporarily corrupted bitstream
+			 */
 			if (error) {
 				printk("Buffer %d decode error: %08X\n", buffer_index, error);
 			} else {
diff --git a/drivers/media/platform/meson/vdec/hevc.c b/drivers/media/platform/meson/vdec/hevc.c
new file mode 100644
index 0000000..7f27cae
--- /dev/null
+++ b/drivers/media/platform/meson/vdec/hevc.c
@@ -0,0 +1,363 @@
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "hevc.h"
+#include "canvas.h"
+#include "hevc_regs.h"
+
+/* DOS registers */
+#define ASSIST_MBOX1_CLR_REG 0x01d4
+#define ASSIST_MBOX1_MASK    0x01d8
+
+#define DOS_SW_RESET3        0xfcd0
+
+/* HEVC reg mapping */
+#define HEVC_DEC_STATUS_REG       HEVC_ASSIST_SCRATCH_0
+#define HEVC_RPM_BUFFER           HEVC_ASSIST_SCRATCH_1
+#define HEVC_SHORT_TERM_RPS       HEVC_ASSIST_SCRATCH_2
+#define HEVC_VPS_BUFFER           HEVC_ASSIST_SCRATCH_3
+#define HEVC_SPS_BUFFER           HEVC_ASSIST_SCRATCH_4
+#define HEVC_PPS_BUFFER           HEVC_ASSIST_SCRATCH_5
+#define HEVC_SAO_UP               HEVC_ASSIST_SCRATCH_6
+#define HEVC_STREAM_SWAP_BUFFER   HEVC_ASSIST_SCRATCH_7
+#define HEVC_STREAM_SWAP_BUFFER2  HEVC_ASSIST_SCRATCH_8
+#define HEVC_sao_mem_unit         HEVC_ASSIST_SCRATCH_9
+#define HEVC_SAO_ABV              HEVC_ASSIST_SCRATCH_A
+#define HEVC_sao_vb_size          HEVC_ASSIST_SCRATCH_B
+#define HEVC_SAO_VB               HEVC_ASSIST_SCRATCH_C
+#define HEVC_SCALELUT             HEVC_ASSIST_SCRATCH_D
+#define HEVC_WAIT_FLAG            HEVC_ASSIST_SCRATCH_E
+#define RPM_CMD_REG               HEVC_ASSIST_SCRATCH_F
+#define LMEM_DUMP_ADR             HEVC_ASSIST_SCRATCH_F
+#define NAL_SEARCH_CTL            HEVC_ASSIST_SCRATCH_I
+#define HEVC_DECODE_MODE	  HEVC_ASSIST_SCRATCH_J
+	#define DECODE_MODE_SINGLE 0
+#define DECODE_STOP_POS		  HEVC_ASSIST_SCRATCH_K
+#define HEVC_AUX_ADR		  HEVC_ASSIST_SCRATCH_L
+#define HEVC_AUX_DATA_SIZE	  HEVC_ASSIST_SCRATCH_M
+#define HEVC_DECODE_SIZE	  HEVC_ASSIST_SCRATCH_N
+
+#define HEVCD_MPP_ANC2AXI_TBL_DATA (0x3464 * 4)
+
+/* HEVC Infos */
+#define MAX_REF_PIC_NUM 24
+
+#define IPP_OFFSET       0x00
+#define SAO_ABV_OFFSET   (IPP_OFFSET + 0x4000)
+#define SAO_VB_OFFSET    (SAO_ABV_OFFSET + 0x30000)
+#define SH_TM_RPS_OFFSET (SAO_VB_OFFSET + 0x30000)
+#define VPS_OFFSET       (SH_TM_RPS_OFFSET + 0x800)
+#define SPS_OFFSET       (VPS_OFFSET + 0x800)
+#define PPS_OFFSET       (SPS_OFFSET + 0x800)
+#define SAO_UP_OFFSET    (PPS_OFFSET + 0x2000)
+#define SWAP_BUF_OFFSET  (SAO_UP_OFFSET + 0x800)
+#define SWAP_BUF2_OFFSET (SWAP_BUF_OFFSET + 0x800)
+#define SCALELUT_OFFSET  (SWAP_BUF2_OFFSET + 0x800)
+#define DBLK_PARA_OFFSET (SCALELUT_OFFSET + 0x8000)
+#define DBLK_DATA_OFFSET (DBLK_PARA_OFFSET + 0x20000)
+#define MMU_VBH_OFFSET   (DBLK_DATA_OFFSET + 0x40000)
+#define MPRED_ABV_OFFSET (MMU_VBH_OFFSET + 0x5000)
+#define MPRED_MV_OFFSET  (MPRED_ABV_OFFSET + 0x8000)
+#define RPM_OFFSET       (MPRED_MV_OFFSET + 0x120000 * MAX_REF_PIC_NUM)
+#define LMEM_OFFSET      (RPM_OFFSET + 0x100)
+
+#define SIZE_WORKSPACE ALIGN(LMEM_OFFSET + 0xA00, 64 * SZ_1K)
+
+#define PARSER_CMD_SKIP_CFG_0 0x0000090b
+#define PARSER_CMD_SKIP_CFG_1 0x1b14140f
+#define PARSER_CMD_SKIP_CFG_2 0x001b1910
+
+static const u16 parser_cmd[] = {
+	0x0401,
+	0x8401,
+	0x0800,
+	0x0402,
+	0x9002,
+	0x1423,
+	0x8CC3,
+	0x1423,
+	0x8804,
+	0x9825,
+	0x0800,
+	0x04FE,
+	0x8406,
+	0x8411,
+	0x1800,
+	0x8408,
+	0x8409,
+	0x8C2A,
+	0x9C2B,
+	0x1C00,
+	0x840F,
+	0x8407,
+	0x8000,
+	0x8408,
+	0x2000,
+	0xA800,
+	0x8410,
+	0x04DE,
+	0x840C,
+	0x840D,
+	0xAC00,
+	0xA000,
+	0x08C0,
+	0x08E0,
+	0xA40E,
+	0xFC00,
+	0x7C00
+};
+
+struct codec_hevc {
+	/* Buffer for the HEVC Workspace */
+	void      *workspace_vaddr;
+	dma_addr_t workspace_paddr;
+
+	/* Housekeeping thread for marking buffers to DONE
+	 * and recycling them into the hardware
+	 */
+	struct task_struct *buffers_thread;
+};
+
+static int codec_hevc_buffers_thread(void *data)
+{
+	struct vdec_buffer *tmp;
+	struct vb2_v4l2_buffer *vbuf;
+	unsigned long flags;
+	struct vdec_session *sess = data;
+
+	while (!kthread_should_stop()) {
+
+		/* The DONE part should probably be in a common thread */
+		spin_lock_irqsave(&sess->bufs_spinlock, flags);
+		while (!list_empty(&sess->bufs))
+		{
+			tmp = list_first_entry(&sess->bufs, struct vdec_buffer, list);
+			if (tmp->index == -1)
+				break;
+
+			vbuf = v4l2_m2m_dst_buf_remove_by_idx(sess->m2m_ctx, tmp->index);
+			if (!vbuf) {
+				printk("HW buffer ready but we don't have the vb2 buffer !!!\n");
+				break;
+			}
+
+			vbuf->vb2_buf.planes[0].bytesused = vdec_get_output_size(sess);
+			vbuf->vb2_buf.planes[1].bytesused = vdec_get_output_size(sess) / 2;
+			vbuf->vb2_buf.timestamp = tmp->timestamp;
+			vbuf->sequence = sess->sequence_cap++;
+			if (!(vbuf->sequence % 100))
+				printk("%d\n", vbuf->sequence);
+
+			printk("Buffer %d done\n", tmp->index);
+
+			v4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_DONE);
+
+			list_del(&tmp->list);
+
+			kfree(tmp);
+		}
+		spin_unlock_irqrestore(&sess->bufs_spinlock, flags);
+
+		usleep_range(5000, 10000);
+	}
+
+	return 0;
+}
+
+static void codec_hevc_setup_buffers(struct vdec_session *sess) {
+	int i;
+	dma_addr_t buf_y_paddr = 0;
+	dma_addr_t buf_uv_paddr;
+	struct v4l2_m2m_buffer *buf;
+	struct vdec_core *core = sess->core;
+	u32 buf_size = v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);
+
+	/* >= GXL */
+	writel_relaxed((1 << 2) | (1 << 1), core->dos_base + HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR);
+
+	v4l2_m2m_for_each_dst_buf(sess->m2m_ctx, buf) {
+		buf_y_paddr  = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
+		buf_uv_paddr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 1);
+
+		writel_relaxed(buf_y_paddr >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
+		/* Double write mode ?? */
+		writel_relaxed(buf_uv_paddr >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
+	}
+
+	/* Fill the remaining unused slots with the last buffer's Y addr ? */
+	for (i = buf_size; i < MAX_REF_PIC_NUM; ++i) {
+		writel_relaxed(buf_y_paddr >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
+	}
+
+	writel_relaxed(1, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR);
+	writel_relaxed(1, core->dos_base + HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR);
+	for (i = 0; i < 32; ++i)
+		writel_relaxed(0, core->dos_base + HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+}
+
+static int codec_hevc_setup_workspace(struct vdec_session *sess) {
+	struct vdec_core *core = sess->core;
+	struct codec_hevc *hevc = sess->priv;
+
+	/* Allocate some memory for the HEVC decoder's state */
+	hevc->workspace_vaddr = dma_alloc_coherent(core->dev, SIZE_WORKSPACE, &hevc->workspace_paddr, GFP_KERNEL);
+	if (!hevc->workspace_vaddr) {
+		printk("Failed to request HEVC Workspace\n");
+		return -ENOMEM;
+	}
+	printk("Allocated Workspace: %08X - %08X\n", hevc->workspace_paddr, hevc->workspace_paddr + SIZE_WORKSPACE);
+
+	/* Setup Workspace */
+	writel_relaxed(hevc->workspace_paddr + IPP_OFFSET, core->dos_base + HEVCD_IPP_LINEBUFF_BASE);
+	writel_relaxed(hevc->workspace_paddr + SH_TM_RPS_OFFSET, core->dos_base + HEVC_SHORT_TERM_RPS);
+	writel_relaxed(hevc->workspace_paddr + VPS_OFFSET, core->dos_base + HEVC_VPS_BUFFER);
+	writel_relaxed(hevc->workspace_paddr + SPS_OFFSET, core->dos_base + HEVC_SPS_BUFFER);
+	writel_relaxed(hevc->workspace_paddr + PPS_OFFSET, core->dos_base + HEVC_PPS_BUFFER);
+	writel_relaxed(hevc->workspace_paddr + SAO_UP_OFFSET, core->dos_base + HEVC_SAO_UP);
+	writel_relaxed(hevc->workspace_paddr + SWAP_BUF_OFFSET, core->dos_base + HEVC_STREAM_SWAP_BUFFER);
+	writel_relaxed(hevc->workspace_paddr + SWAP_BUF2_OFFSET, core->dos_base + HEVC_STREAM_SWAP_BUFFER2);
+	writel_relaxed(hevc->workspace_paddr + SCALELUT_OFFSET, core->dos_base + HEVC_SCALELUT);
+	writel_relaxed(hevc->workspace_paddr + DBLK_PARA_OFFSET, core->dos_base + HEVC_DBLK_CFG4);
+	writel_relaxed(hevc->workspace_paddr + DBLK_DATA_OFFSET, core->dos_base + HEVC_DBLK_CFG5);
+	writel_relaxed(hevc->workspace_paddr + LMEM_OFFSET, core->dos_base + LMEM_DUMP_ADR);
+
+	return 0;
+}
+
+static int codec_hevc_start(struct vdec_session *sess) {
+	struct vdec_core *core = sess->core;
+	struct codec_hevc *hevc;
+	int ret;
+	int i;
+
+	printk("Workspace size: %u\n", SIZE_WORKSPACE);
+
+	hevc = kzalloc(sizeof(*hevc), GFP_KERNEL);
+	if (!hevc)
+		return -ENOMEM;
+
+	sess->priv = hevc;
+
+	codec_hevc_setup_workspace(sess);
+
+	writel_relaxed(0x5a5a55aa, core->dos_base + HEVC_PARSER_VERSION);
+	writel_relaxed((1 << 14), core->dos_base + DOS_SW_RESET3);
+	writel_relaxed(readl_relaxed(core->dos_base + HEVC_STREAM_CONTROL) | 1, core->dos_base + HEVC_STREAM_CONTROL);
+	writel_relaxed(0x12345678, core->dos_base + HEVC_SHIFT_STARTCODE);
+	writel_relaxed(0x9abcdef0, core->dos_base + HEVC_SHIFT_EMULATECODE);
+	writel_relaxed(0x00000100, core->dos_base + HEVC_SHIFT_STARTCODE);
+	writel_relaxed(0x00000300, core->dos_base + HEVC_SHIFT_EMULATECODE);
+	writel_relaxed((readl_relaxed(core->dos_base + HEVC_PARSER_INT_CONTROL) & 0x03ffffff) |
+			(3 << 29) | (2 << 26) | (1 << 24) | (1 << 22) | (1 << 7) | (1 << 4) | 1, core->dos_base + HEVC_PARSER_INT_CONTROL);
+	writel_relaxed(readl_relaxed(core->dos_base + HEVC_SHIFT_STATUS) | (1 << 1) | 1, core->dos_base + HEVC_SHIFT_STATUS);
+	writel_relaxed((3 << 6) | (2 << 4) | (2 << 1) | 1, core->dos_base + HEVC_SHIFT_CONTROL);
+	writel_relaxed(1, core->dos_base + HEVC_CABAC_CONTROL);
+	writel_relaxed(1, core->dos_base + HEVC_PARSER_CORE_CONTROL);
+	writel_relaxed(0, core->dos_base + HEVC_DEC_STATUS_REG);
+
+	writel_relaxed(0, core->dos_base + HEVC_IQIT_SCALELUT_WR_ADDR);
+	for (i = 0; i < 1024; ++i)
+		writel_relaxed(0, core->dos_base + HEVC_IQIT_SCALELUT_DATA);
+
+	writel_relaxed(0, core->dos_base + HEVC_DECODE_SIZE);
+	writel_relaxed((1 << 16), core->dos_base + HEVC_PARSER_CMD_WRITE);
+	for (i = 0; i < ARRAY_SIZE(parser_cmd); ++i)
+		writel_relaxed(parser_cmd[i], core->dos_base + HEVC_PARSER_CMD_WRITE);
+
+	writel_relaxed(PARSER_CMD_SKIP_CFG_0, core->dos_base + HEVC_PARSER_CMD_SKIP_0);
+	writel_relaxed(PARSER_CMD_SKIP_CFG_1, core->dos_base + HEVC_PARSER_CMD_SKIP_1);
+	writel_relaxed(PARSER_CMD_SKIP_CFG_2, core->dos_base + HEVC_PARSER_CMD_SKIP_2);
+	writel_relaxed((1 << 5) | (1 << 2) | 1, core->dos_base + HEVC_PARSER_IF_CONTROL);
+
+	writel_relaxed(1, core->dos_base + HEVCD_IPP_TOP_CNTL);
+	writel_relaxed((1 << 1), core->dos_base + HEVCD_IPP_TOP_CNTL);
+
+	writel_relaxed(1, core->dos_base + HEVC_WAIT_FLAG);
+
+	/* clear mailbox interrupt */
+	writel_relaxed(1, core->dos_base + HEVC_ASSIST_MBOX1_CLR_REG);
+	/* enable mailbox interrupt */
+	writel_relaxed(1, core->dos_base + HEVC_ASSIST_MBOX1_MASK);
+	/* disable PSCALE for hardware sharing */
+	writel_relaxed(0, core->dos_base + HEVC_PSCALE_CTRL);
+	/* Let the uCode do all the parsing */
+	writel_relaxed(8, core->dos_base + NAL_SEARCH_CTL);
+
+	/*WRITE_VREG(NAL_SEARCH_CTL,
+	READ_VREG(NAL_SEARCH_CTL)
+	| ((parser_sei_enable & 0x7) << 17));*/
+
+	writel_relaxed(0, core->dos_base + DECODE_STOP_POS);
+	writel_relaxed(DECODE_MODE_SINGLE, core->dos_base + HEVC_DECODE_MODE);
+
+	/*WRITE_VREG(HEVC_AUX_ADR, hevc->aux_phy_addr);
+	WRITE_VREG(HEVC_AUX_DATA_SIZE,
+	((hevc->prefix_aux_size >> 4) << 16) |
+	(hevc->suffix_aux_size >> 4)
+	);*/
+
+	codec_hevc_setup_buffers(sess);
+	writel_relaxed(1, core->dos_base + HEVC_ASSIST_MBOX1_IRQ_REG);
+
+	writel_relaxed((1<<12)|(1<<11), core->dos_base + DOS_SW_RESET3);
+	writel_relaxed(0, core->dos_base + DOS_SW_RESET3);
+	readl_relaxed(core->dos_base + DOS_SW_RESET3);
+
+	hevc->buffers_thread = kthread_run(codec_hevc_buffers_thread, sess, "buffers_done");
+
+	printk("HEVC start OK!\n");
+
+	return 0;
+}
+
+static int codec_hevc_stop(struct vdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	struct vdec_core *core = sess->core;
+
+	printk("codec_hevc_stop\n");
+
+	kthread_stop(hevc->buffers_thread);
+
+	if (hevc->workspace_vaddr) {
+		dma_free_coherent(core->dev, SIZE_WORKSPACE, hevc->workspace_vaddr, hevc->workspace_paddr);
+		hevc->workspace_vaddr = 0;
+	}
+
+	kfree(hevc);
+	sess->priv = 0;
+
+	return 0;
+}
+
+/* Map a ready HW buffer index with a previously queued OUTPUT buffer's timestamp */
+static void fill_buffer_index(struct vdec_session *sess, u32 buffer_index) {
+	struct vdec_buffer *tmp;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sess->bufs_spinlock, flags);
+	list_for_each_entry(tmp, &sess->bufs, list) {
+		if (tmp->index == -1) {
+			tmp->index = buffer_index;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&sess->bufs_spinlock, flags);
+}
+
+static irqreturn_t codec_hevc_isr(struct vdec_session *sess)
+{
+	u32 dec_status;
+	struct vdec_core *core = sess->core;
+
+	dec_status = readl_relaxed(core->dos_base + HEVC_DEC_STATUS_REG);
+	printk("codec_hevc_isr: %08X\n", dec_status);
+	return IRQ_HANDLED;
+}
+
+struct vdec_codec_ops codec_hevc_ops = {
+	.start = codec_hevc_start,
+	.stop = codec_hevc_stop,
+	.isr = codec_hevc_isr,
+};
+
diff --git a/drivers/media/platform/meson/vdec/hevc.h b/drivers/media/platform/meson/vdec/hevc.h
new file mode 100644
index 0000000..522818d
--- /dev/null
+++ b/drivers/media/platform/meson/vdec/hevc.h
@@ -0,0 +1,8 @@
+#ifndef __MESON_VDEC_HEVC_H_
+#define __MESON_VDEC_HEVC_H_
+
+#include "vdec.h"
+
+extern struct vdec_codec_ops codec_hevc_ops;
+
+#endif
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/hevc_regs.h b/drivers/media/platform/meson/vdec/hevc_regs.h
new file mode 100644
index 0000000..77f53bd
--- /dev/null
+++ b/drivers/media/platform/meson/vdec/hevc_regs.h
@@ -0,0 +1,754 @@
+/*
+ * drivers/amlogic/amports/arch/regs/hevc_regs.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef HEVC_REGS_HEADERS__
+#define HEVC_REGS_HEADERS__
+/*add from M8M2*/
+#define HEVC_ASSIST_AFIFO_CTRL (0x3001 * 4)
+#define HEVC_ASSIST_AFIFO_CTRL1 (0x3002 * 4)
+#define HEVC_ASSIST_GCLK_EN (0x3003 * 4)
+#define HEVC_ASSIST_SW_RESET (0x3004 * 4)
+#define HEVC_ASSIST_AMR1_INT0 (0x3025 * 4)
+#define HEVC_ASSIST_AMR1_INT1 (0x3026 * 4)
+#define HEVC_ASSIST_AMR1_INT2 (0x3027 * 4)
+#define HEVC_ASSIST_AMR1_INT3 (0x3028 * 4)
+#define HEVC_ASSIST_AMR1_INT4 (0x3029 * 4)
+#define HEVC_ASSIST_AMR1_INT5 (0x302a * 4)
+#define HEVC_ASSIST_AMR1_INT6 (0x302b * 4)
+#define HEVC_ASSIST_AMR1_INT7 (0x302c * 4)
+#define HEVC_ASSIST_AMR1_INT8 (0x302d * 4)
+#define HEVC_ASSIST_AMR1_INT9 (0x302e * 4)
+#define HEVC_ASSIST_AMR1_INTA (0x302f * 4)
+#define HEVC_ASSIST_AMR1_INTB (0x3030 * 4)
+#define HEVC_ASSIST_AMR1_INTC (0x3031 * 4)
+#define HEVC_ASSIST_AMR1_INTD (0x3032 * 4)
+#define HEVC_ASSIST_AMR1_INTE (0x3033 * 4)
+#define HEVC_ASSIST_AMR1_INTF (0x3034 * 4)
+#define HEVC_ASSIST_AMR2_INT0 (0x3035 * 4)
+#define HEVC_ASSIST_AMR2_INT1 (0x3036 * 4)
+#define HEVC_ASSIST_AMR2_INT2 (0x3037 * 4)
+#define HEVC_ASSIST_AMR2_INT3 (0x3038 * 4)
+#define HEVC_ASSIST_AMR2_INT4 (0x3039 * 4)
+#define HEVC_ASSIST_AMR2_INT5 (0x303a * 4)
+#define HEVC_ASSIST_AMR2_INT6 (0x303b * 4)
+#define HEVC_ASSIST_AMR2_INT7 (0x303c * 4)
+#define HEVC_ASSIST_AMR2_INT8 (0x303d * 4)
+#define HEVC_ASSIST_AMR2_INT9 (0x303e * 4)
+#define HEVC_ASSIST_AMR2_INTA (0x303f * 4)
+#define HEVC_ASSIST_AMR2_INTB (0x3040 * 4)
+#define HEVC_ASSIST_AMR2_INTC (0x3041 * 4)
+#define HEVC_ASSIST_AMR2_INTD (0x3042 * 4)
+#define HEVC_ASSIST_AMR2_INTE (0x3043 * 4)
+#define HEVC_ASSIST_AMR2_INTF (0x3044 * 4)
+#define HEVC_ASSIST_MBX_SSEL (0x3045 * 4)
+#define HEVC_ASSIST_TIMER0_LO (0x3060 * 4)
+#define HEVC_ASSIST_TIMER0_HI (0x3061 * 4)
+#define HEVC_ASSIST_TIMER1_LO (0x3062 * 4)
+#define HEVC_ASSIST_TIMER1_HI (0x3063 * 4)
+#define HEVC_ASSIST_DMA_INT (0x3064 * 4)
+#define HEVC_ASSIST_DMA_INT_MSK (0x3065 * 4)
+#define HEVC_ASSIST_DMA_INT2 (0x3066 * 4)
+#define HEVC_ASSIST_DMA_INT_MSK2 (0x3067 * 4)
+#define HEVC_ASSIST_MBOX0_IRQ_REG (0x3070 * 4)
+#define HEVC_ASSIST_MBOX0_CLR_REG (0x3071 * 4)
+#define HEVC_ASSIST_MBOX0_MASK (0x3072 * 4)
+#define HEVC_ASSIST_MBOX0_FIQ_SEL (0x3073 * 4)
+#define HEVC_ASSIST_MBOX1_IRQ_REG (0x3074 * 4)
+#define HEVC_ASSIST_MBOX1_CLR_REG (0x3075 * 4)
+#define HEVC_ASSIST_MBOX1_MASK (0x3076 * 4)
+#define HEVC_ASSIST_MBOX1_FIQ_SEL (0x3077 * 4)
+#define HEVC_ASSIST_MBOX2_IRQ_REG (0x3078 * 4)
+#define HEVC_ASSIST_MBOX2_CLR_REG (0x3079 * 4)
+#define HEVC_ASSIST_MBOX2_MASK (0x307a * 4)
+#define HEVC_ASSIST_MBOX2_FIQ_SEL (0x307b * 4)
+#define HEVC_ASSIST_AXI_CTRL (0x307c * 4)
+#define HEVC_ASSIST_AXI_STATUS (0x307d * 4)
+#define HEVC_ASSIST_SCRATCH_0 (0x30c0 * 4)
+#define HEVC_ASSIST_SCRATCH_1 (0x30c1 * 4)
+#define HEVC_ASSIST_SCRATCH_2 (0x30c2 * 4)
+#define HEVC_ASSIST_SCRATCH_3 (0x30c3 * 4)
+#define HEVC_ASSIST_SCRATCH_4 (0x30c4 * 4)
+#define HEVC_ASSIST_SCRATCH_5 (0x30c5 * 4)
+#define HEVC_ASSIST_SCRATCH_6 (0x30c6 * 4)
+#define HEVC_ASSIST_SCRATCH_7 (0x30c7 * 4)
+#define HEVC_ASSIST_SCRATCH_8 (0x30c8 * 4)
+#define HEVC_ASSIST_SCRATCH_9 (0x30c9 * 4)
+#define HEVC_ASSIST_SCRATCH_A (0x30ca * 4)
+#define HEVC_ASSIST_SCRATCH_B (0x30cb * 4)
+#define HEVC_ASSIST_SCRATCH_C (0x30cc * 4)
+#define HEVC_ASSIST_SCRATCH_D (0x30cd * 4)
+#define HEVC_ASSIST_SCRATCH_E (0x30ce * 4)
+#define HEVC_ASSIST_SCRATCH_F (0x30cf * 4)
+#define HEVC_ASSIST_SCRATCH_G (0x30d0 * 4)
+#define HEVC_ASSIST_SCRATCH_H (0x30d1 * 4)
+#define HEVC_ASSIST_SCRATCH_I (0x30d2 * 4)
+#define HEVC_ASSIST_SCRATCH_J (0x30d3 * 4)
+#define HEVC_ASSIST_SCRATCH_K (0x30d4 * 4)
+#define HEVC_ASSIST_SCRATCH_L (0x30d5 * 4)
+#define HEVC_ASSIST_SCRATCH_M (0x30d6 * 4)
+#define HEVC_ASSIST_SCRATCH_N (0x30d7 * 4)
+#define HEVC_PARSER_VERSION (0x3100 * 4)
+#define HEVC_STREAM_CONTROL (0x3101 * 4)
+#define HEVC_STREAM_START_ADDR (0x3102 * 4)
+#define HEVC_STREAM_END_ADDR (0x3103 * 4)
+#define HEVC_STREAM_WR_PTR (0x3104 * 4)
+#define HEVC_STREAM_RD_PTR (0x3105 * 4)
+#define HEVC_STREAM_LEVEL (0x3106 * 4)
+#define HEVC_STREAM_FIFO_CTL (0x3107 * 4)
+#define HEVC_SHIFT_CONTROL (0x3108 * 4)
+#define HEVC_SHIFT_STARTCODE (0x3109 * 4)
+#define HEVC_SHIFT_EMULATECODE (0x310a * 4)
+#define HEVC_SHIFT_STATUS (0x310b * 4)
+#define HEVC_SHIFTED_DATA (0x310c * 4)
+#define HEVC_SHIFT_BYTE_COUNT (0x310d * 4)
+#define HEVC_SHIFT_COMMAND (0x310e * 4)
+#define HEVC_ELEMENT_RESULT (0x310f * 4)
+#define HEVC_CABAC_CONTROL (0x3110 * 4)
+#define HEVC_PARSER_SLICE_INFO (0x3111 * 4)
+#define HEVC_PARSER_CMD_WRITE (0x3112 * 4)
+#define HEVC_PARSER_CORE_CONTROL (0x3113 * 4)
+#define HEVC_PARSER_CMD_FETCH (0x3114 * 4)
+#define HEVC_PARSER_CMD_STATUS (0x3115 * 4)
+#define HEVC_PARSER_LCU_INFO (0x3116 * 4)
+#define HEVC_PARSER_HEADER_INFO (0x3117 * 4)
+#define HEVC_PARSER_RESULT_0 (0x3118 * 4)
+#define HEVC_PARSER_RESULT_1 (0x3119 * 4)
+#define HEVC_PARSER_RESULT_2 (0x311a * 4)
+#define HEVC_PARSER_RESULT_3 (0x311b * 4)
+#define HEVC_CABAC_TOP_INFO (0x311c * 4)
+#define HEVC_CABAC_TOP_INFO_2 (0x311d * 4)
+#define HEVC_CABAC_LEFT_INFO (0x311e * 4)
+#define HEVC_CABAC_LEFT_INFO_2 (0x311f * 4)
+#define HEVC_PARSER_INT_CONTROL (0x3120 * 4)
+#define HEVC_PARSER_INT_STATUS (0x3121 * 4)
+#define HEVC_PARSER_IF_CONTROL (0x3122 * 4)
+#define HEVC_PARSER_PICTURE_SIZE (0x3123 * 4)
+#define HEVC_PARSER_LCU_START (0x3124 * 4)
+#define HEVC_PARSER_HEADER_INFO2 (0x3125 * 4)
+#define HEVC_PARSER_QUANT_READ (0x3126 * 4)
+#define HEVC_PARSER_RESERVED_27 (0x3127 * 4)
+#define HEVC_PARSER_CMD_SKIP_0 (0x3128 * 4)
+#define HEVC_PARSER_CMD_SKIP_1 (0x3129 * 4)
+#define HEVC_PARSER_CMD_SKIP_2 (0x312a * 4)
+#define HEVC_PARSER_MANUAL_CMD (0x312b * 4)
+#define HEVC_PARSER_MEM_RD_ADDR (0x312c * 4)
+#define HEVC_PARSER_MEM_WR_ADDR (0x312d * 4)
+#define HEVC_PARSER_MEM_RW_DATA (0x312e * 4)
+#define HEVC_SAO_IF_STATUS (0x3130 * 4)
+#define HEVC_SAO_IF_DATA_Y (0x3131 * 4)
+#define HEVC_SAO_IF_DATA_U (0x3132 * 4)
+#define HEVC_SAO_IF_DATA_V (0x3133 * 4)
+#define HEVC_STREAM_SWAP_ADDR (0x3134 * 4)
+#define HEVC_STREAM_SWAP_CTRL (0x3135 * 4)
+#define HEVC_IQIT_IF_WAIT_CNT (0x3136 * 4)
+#define HEVC_MPRED_IF_WAIT_CNT (0x3137 * 4)
+#define HEVC_SAO_IF_WAIT_CNT (0x3138 * 4)
+#define HEVC_PARSER_DEBUG_IDX (0x313e * 4)
+#define HEVC_PARSER_DEBUG_DAT (0x313f * 4)
+#define HEVC_MPRED_VERSION (0x3200 * 4)
+#define HEVC_MPRED_CTRL0 (0x3201 * 4)
+#define HEVC_MPRED_CTRL1 (0x3202 * 4)
+#define HEVC_MPRED_INT_EN (0x3203 * 4)
+#define HEVC_MPRED_INT_STATUS (0x3204 * 4)
+#define HEVC_MPRED_PIC_SIZE (0x3205 * 4)
+#define HEVC_MPRED_PIC_SIZE_LCU (0x3206 * 4)
+#define HEVC_MPRED_TILE_START (0x3207 * 4)
+#define HEVC_MPRED_TILE_SIZE_LCU (0x3208 * 4)
+#define HEVC_MPRED_REF_NUM (0x3209 * 4)
+#define HEVC_MPRED_LT_REF (0x320a * 4)
+#define HEVC_MPRED_LT_COLREF (0x320b * 4)
+#define HEVC_MPRED_REF_EN_L0 (0x320c * 4)
+#define HEVC_MPRED_REF_EN_L1 (0x320d * 4)
+#define HEVC_MPRED_COLREF_EN_L0 (0x320e * 4)
+#define HEVC_MPRED_COLREF_EN_L1 (0x320f * 4)
+#define HEVC_MPRED_AXI_WCTRL (0x3210 * 4)
+#define HEVC_MPRED_AXI_RCTRL (0x3211 * 4)
+#define HEVC_MPRED_ABV_START_ADDR (0x3212 * 4)
+#define HEVC_MPRED_MV_WR_START_ADDR (0x3213 * 4)
+#define HEVC_MPRED_MV_RD_START_ADDR (0x3214 * 4)
+#define HEVC_MPRED_MV_WPTR (0x3215 * 4)
+#define HEVC_MPRED_MV_RPTR (0x3216 * 4)
+#define HEVC_MPRED_MV_WR_ROW_JUMP (0x3217 * 4)
+#define HEVC_MPRED_MV_RD_ROW_JUMP (0x3218 * 4)
+#define HEVC_MPRED_CURR_LCU (0x3219 * 4)
+#define HEVC_MPRED_ABV_WPTR (0x321a * 4)
+#define HEVC_MPRED_ABV_RPTR (0x321b * 4)
+#define HEVC_MPRED_CTRL2 (0x321c * 4)
+#define HEVC_MPRED_CTRL3 (0x321d * 4)
+#define HEVC_MPRED_MV_WLCUY (0x321e * 4)
+#define HEVC_MPRED_MV_RLCUY (0x321f * 4)
+#define HEVC_MPRED_L0_REF00_POC (0x3220 * 4)
+#define HEVC_MPRED_L0_REF01_POC (0x3221 * 4)
+#define HEVC_MPRED_L0_REF02_POC (0x3222 * 4)
+#define HEVC_MPRED_L0_REF03_POC (0x3223 * 4)
+#define HEVC_MPRED_L0_REF04_POC (0x3224 * 4)
+#define HEVC_MPRED_L0_REF05_POC (0x3225 * 4)
+#define HEVC_MPRED_L0_REF06_POC (0x3226 * 4)
+#define HEVC_MPRED_L0_REF07_POC (0x3227 * 4)
+#define HEVC_MPRED_L0_REF08_POC (0x3228 * 4)
+#define HEVC_MPRED_L0_REF09_POC (0x3229 * 4)
+#define HEVC_MPRED_L0_REF10_POC (0x322a * 4)
+#define HEVC_MPRED_L0_REF11_POC (0x322b * 4)
+#define HEVC_MPRED_L0_REF12_POC (0x322c * 4)
+#define HEVC_MPRED_L0_REF13_POC (0x322d * 4)
+#define HEVC_MPRED_L0_REF14_POC (0x322e * 4)
+#define HEVC_MPRED_L0_REF15_POC (0x322f * 4)
+#define HEVC_MPRED_L1_REF00_POC (0x3230 * 4)
+#define HEVC_MPRED_L1_REF01_POC (0x3231 * 4)
+#define HEVC_MPRED_L1_REF02_POC (0x3232 * 4)
+#define HEVC_MPRED_L1_REF03_POC (0x3233 * 4)
+#define HEVC_MPRED_L1_REF04_POC (0x3234 * 4)
+#define HEVC_MPRED_L1_REF05_POC (0x3235 * 4)
+#define HEVC_MPRED_L1_REF06_POC (0x3236 * 4)
+#define HEVC_MPRED_L1_REF07_POC (0x3237 * 4)
+#define HEVC_MPRED_L1_REF08_POC (0x3238 * 4)
+#define HEVC_MPRED_L1_REF09_POC (0x3239 * 4)
+#define HEVC_MPRED_L1_REF10_POC (0x323a * 4)
+#define HEVC_MPRED_L1_REF11_POC (0x323b * 4)
+#define HEVC_MPRED_L1_REF12_POC (0x323c * 4)
+#define HEVC_MPRED_L1_REF13_POC (0x323d * 4)
+#define HEVC_MPRED_L1_REF14_POC (0x323e * 4)
+#define HEVC_MPRED_L1_REF15_POC (0x323f * 4)
+#define HEVC_MPRED_PIC_SIZE_EXT (0x3240 * 4)
+#define HEVC_MPRED_DBG_MODE0 (0x3241 * 4)
+#define HEVC_MPRED_DBG_MODE1 (0x3242 * 4)
+#define HEVC_MPRED_DBG2_MODE (0x3243 * 4)
+#define HEVC_MPRED_IMP_CMD0 (0x3244 * 4)
+#define HEVC_MPRED_IMP_CMD1 (0x3245 * 4)
+#define HEVC_MPRED_IMP_CMD2 (0x3246 * 4)
+#define HEVC_MPRED_IMP_CMD3 (0x3247 * 4)
+#define HEVC_MPRED_DBG2_DATA_0 (0x3248 * 4)
+#define HEVC_MPRED_DBG2_DATA_1 (0x3249 * 4)
+#define HEVC_MPRED_DBG2_DATA_2 (0x324a * 4)
+#define HEVC_MPRED_DBG2_DATA_3 (0x324b * 4)
+#define HEVC_MPRED_DBG_DATA_0 (0x3250 * 4)
+#define HEVC_MPRED_DBG_DATA_1 (0x3251 * 4)
+#define HEVC_MPRED_DBG_DATA_2 (0x3252 * 4)
+#define HEVC_MPRED_DBG_DATA_3 (0x3253 * 4)
+#define HEVC_MPRED_DBG_DATA_4 (0x3254 * 4)
+#define HEVC_MPRED_DBG_DATA_5 (0x3255 * 4)
+#define HEVC_MPRED_DBG_DATA_6 (0x3256 * 4)
+#define HEVC_MPRED_DBG_DATA_7 (0x3257 * 4)
+#define HEVC_MPRED_CUR_POC (0x3260 * 4)
+#define HEVC_MPRED_COL_POC (0x3261 * 4)
+#define HEVC_MPRED_MV_RD_END_ADDR (0x3262 * 4)
+#define HEVCD_IPP_TOP_CNTL (0x3400 * 4)
+#define HEVCD_IPP_TOP_STATUS (0x3401 * 4)
+#define HEVCD_IPP_TOP_FRMCONFIG (0x3402 * 4)
+#define HEVCD_IPP_TOP_TILECONFIG1 (0x3403 * 4)
+#define HEVCD_IPP_TOP_TILECONFIG2 (0x3404 * 4)
+#define HEVCD_IPP_TOP_TILECONFIG3 (0x3405 * 4)
+#define HEVCD_IPP_TOP_LCUCONFIG (0x3406 * 4)
+#define HEVCD_IPP_TOP_FRMCTL (0x3407 * 4)
+#define HEVCD_IPP_CONFIG (0x3408 * 4)
+#define HEVCD_IPP_LINEBUFF_BASE (0x3409 * 4)
+#define HEVCD_IPP_INTR_MASK (0x340a * 4)
+#define HEVCD_IPP_AXIIF_CONFIG (0x340b * 4)
+#define HEVCD_IPP_BITDEPTH_CONFIG (0x340c * 4)
+#define HEVCD_IPP_SWMPREDIF_CONFIG (0x3410 * 4)
+#define HEVCD_IPP_SWMPREDIF_STATUS (0x3411 * 4)
+#define HEVCD_IPP_SWMPREDIF_CTBINFO (0x3412 * 4)
+#define HEVCD_IPP_SWMPREDIF_PUINFO0 (0x3413 * 4)
+#define HEVCD_IPP_SWMPREDIF_PUINFO1 (0x3414 * 4)
+#define HEVCD_IPP_SWMPREDIF_PUINFO2 (0x3415 * 4)
+#define HEVCD_IPP_SWMPREDIF_PUINFO3 (0x3416 * 4)
+#define HEVCD_IPP_DYNCLKGATE_CONFIG (0x3420 * 4)
+#define HEVCD_IPP_DYNCLKGATE_STATUS (0x3421 * 4)
+#define HEVCD_IPP_DBG_SEL (0x3430 * 4)
+#define HEVCD_IPP_DBG_DATA (0x3431 * 4)
+#define HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR (0x3460 * 4)
+#define HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR (0x3461 * 4)
+#define HEVCD_MPP_ANC2AXI_TBL_WDATA_ADDR (0x3462 * 4)
+#define HEVCD_MPP_ANC2AXI_TBL_RDATA_ADDR (0x3463 * 4)
+#define HEVCD_MPP_WEIGHTPRED_CNTL_ADDR (0x347b * 4)
+#define HEVCD_MPP_L0_WEIGHT_FLAG_ADDR (0x347c * 4)
+#define HEVCD_MPP_L1_WEIGHT_FLAG_ADDR (0x347d * 4)
+#define HEVCD_MPP_YLOG2WGHTDENOM_ADDR (0x347e * 4)
+#define HEVCD_MPP_DELTACLOG2WGHTDENOM_ADDR (0x347f * 4)
+#define HEVCD_MPP_WEIGHT_ADDR (0x3480 * 4)
+#define HEVCD_MPP_WEIGHT_DATA (0x3481 * 4)
+#define HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR (0x34c0 * 4)
+#define HEVCD_MPP_ANC_CANVAS_DATA_ADDR (0x34c1 * 4)
+#define HEVCD_MPP_DECOMP_CTL1 (0x34c2 * 4)
+#define HEVCD_MPP_DECOMP_CTL2 (0x34c3 * 4)
+#define HEVCD_MCRCC_CTL1 (0x34f0 * 4)
+#define HEVCD_MCRCC_CTL2 (0x34f1 * 4)
+#define HEVCD_MCRCC_CTL3 (0x34f2 * 4)
+#define HEVCD_MCRCC_PERFMON_CTL (0x34f3 * 4)
+#define HEVCD_MCRCC_PERFMON_DATA (0x34f4 * 4)
+#define HEVC_DBLK_CFG0 (0x3500 * 4)
+#define HEVC_DBLK_CFG1 (0x3501 * 4)
+#define HEVC_DBLK_CFG2 (0x3502 * 4)
+#define HEVC_DBLK_CFG3 (0x3503 * 4)
+#define HEVC_DBLK_CFG4 (0x3504 * 4)
+#define HEVC_DBLK_CFG5 (0x3505 * 4)
+#define HEVC_DBLK_CFG6 (0x3506 * 4)
+#define HEVC_DBLK_CFG7 (0x3507 * 4)
+#define HEVC_DBLK_CFG8 (0x3508 * 4)
+#define HEVC_DBLK_CFG9 (0x3509 * 4)
+#define HEVC_DBLK_CFGA (0x350a * 4)
+#define HEVC_DBLK_STS0 (0x350b * 4)
+#define HEVC_DBLK_STS1 (0x350c * 4)
+#define HEVC_SAO_VERSION (0x3600 * 4)
+#define HEVC_SAO_CTRL0 (0x3601 * 4)
+#define HEVC_SAO_CTRL1 (0x3602 * 4)
+#define HEVC_SAO_INT_EN (0x3603 * 4)
+#define HEVC_SAO_INT_STATUS (0x3604 * 4)
+#define HEVC_SAO_PIC_SIZE (0x3605 * 4)
+#define HEVC_SAO_PIC_SIZE_LCU (0x3606 * 4)
+#define HEVC_SAO_TILE_START (0x3607 * 4)
+#define HEVC_SAO_TILE_SIZE_LCU (0x3608 * 4)
+#define HEVC_SAO_AXI_WCTRL (0x3609 * 4)
+#define HEVC_SAO_AXI_RCTRL (0x360a * 4)
+#define HEVC_SAO_Y_START_ADDR (0x360b * 4)
+#define HEVC_SAO_Y_LENGTH (0x360c * 4)
+#define HEVC_SAO_C_START_ADDR (0x360d * 4)
+#define HEVC_SAO_C_LENGTH (0x360e * 4)
+#define HEVC_SAO_Y_WPTR (0x360f * 4)
+#define HEVC_SAO_C_WPTR (0x3610 * 4)
+#define HEVC_SAO_ABV_START_ADDR (0x3611 * 4)
+#define HEVC_SAO_VB_WR_START_ADDR (0x3612 * 4)
+#define HEVC_SAO_VB_RD_START_ADDR (0x3613 * 4)
+#define HEVC_SAO_ABV_WPTR (0x3614 * 4)
+#define HEVC_SAO_ABV_RPTR (0x3615 * 4)
+#define HEVC_SAO_VB_WPTR (0x3616 * 4)
+#define HEVC_SAO_VB_RPTR (0x3617 * 4)
+#define HEVC_SAO_DBG_MODE0 (0x361e * 4)
+#define HEVC_SAO_DBG_MODE1 (0x361f * 4)
+#define HEVC_SAO_CTRL2 (0x3620 * 4)
+#define HEVC_SAO_CTRL3 (0x3621 * 4)
+#define HEVC_SAO_CTRL4 (0x3622 * 4)
+#define HEVC_SAO_CTRL5 (0x3623 * 4)
+#define HEVC_SAO_CTRL6 (0x3624 * 4)
+#define HEVC_SAO_CTRL7 (0x3625 * 4)
+#define HEVC_SAO_DBG_DATA_0 (0x3630 * 4)
+#define HEVC_SAO_DBG_DATA_1 (0x3631 * 4)
+#define HEVC_SAO_DBG_DATA_2 (0x3632 * 4)
+#define HEVC_SAO_DBG_DATA_3 (0x3633 * 4)
+#define HEVC_SAO_DBG_DATA_4 (0x3634 * 4)
+#define HEVC_SAO_DBG_DATA_5 (0x3635 * 4)
+#define HEVC_SAO_DBG_DATA_6 (0x3636 * 4)
+#define HEVC_SAO_DBG_DATA_7 (0x3637 * 4)
+#define HEVC_IQIT_CLK_RST_CTRL (0x3700 * 4)
+#define HEVC_IQIT_DEQUANT_CTRL (0x3701 * 4)
+#define HEVC_IQIT_SCALELUT_WR_ADDR (0x3702 * 4)
+#define HEVC_IQIT_SCALELUT_RD_ADDR (0x3703 * 4)
+#define HEVC_IQIT_SCALELUT_DATA (0x3704 * 4)
+#define HEVC_IQIT_SCALELUT_IDX_4 (0x3705 * 4)
+#define HEVC_IQIT_SCALELUT_IDX_8 (0x3706 * 4)
+#define HEVC_IQIT_SCALELUT_IDX_16_32 (0x3707 * 4)
+#define HEVC_IQIT_STAT_GEN0 (0x3708 * 4)
+#define HEVC_QP_WRITE (0x3709 * 4)
+#define HEVC_IQIT_STAT_GEN1 (0x370a * 4)
+/**/
+
+/*add from M8M2*/
+#define HEVC_MC_CTRL_REG (0x3900 * 4)
+#define HEVC_MC_MB_INFO (0x3901 * 4)
+#define HEVC_MC_PIC_INFO (0x3902 * 4)
+#define HEVC_MC_HALF_PEL_ONE (0x3903 * 4)
+#define HEVC_MC_HALF_PEL_TWO (0x3904 * 4)
+#define HEVC_POWER_CTL_MC (0x3905 * 4)
+#define HEVC_MC_CMD (0x3906 * 4)
+#define HEVC_MC_CTRL0 (0x3907 * 4)
+#define HEVC_MC_PIC_W_H (0x3908 * 4)
+#define HEVC_MC_STATUS0 (0x3909 * 4)
+#define HEVC_MC_STATUS1 (0x390a * 4)
+#define HEVC_MC_CTRL1 (0x390b * 4)
+#define HEVC_MC_MIX_RATIO0 (0x390c * 4)
+#define HEVC_MC_MIX_RATIO1 (0x390d * 4)
+#define HEVC_MC_DP_MB_XY (0x390e * 4)
+#define HEVC_MC_OM_MB_XY (0x390f * 4)
+#define HEVC_PSCALE_RST (0x3910 * 4)
+#define HEVC_PSCALE_CTRL (0x3911 * 4)
+#define HEVC_PSCALE_PICI_W (0x3912 * 4)
+#define HEVC_PSCALE_PICI_H (0x3913 * 4)
+#define HEVC_PSCALE_PICO_W (0x3914 * 4)
+#define HEVC_PSCALE_PICO_H (0x3915 * 4)
+#define HEVC_PSCALE_PICO_START_X (0x3916 * 4)
+#define HEVC_PSCALE_PICO_START_Y (0x3917 * 4)
+#define HEVC_PSCALE_DUMMY (0x3918 * 4)
+#define HEVC_PSCALE_FILT0_COEF0 (0x3919 * 4)
+#define HEVC_PSCALE_FILT0_COEF1 (0x391a * 4)
+#define HEVC_PSCALE_CMD_CTRL (0x391b * 4)
+#define HEVC_PSCALE_CMD_BLK_X (0x391c * 4)
+#define HEVC_PSCALE_CMD_BLK_Y (0x391d * 4)
+#define HEVC_PSCALE_STATUS (0x391e * 4)
+#define HEVC_PSCALE_BMEM_ADDR (0x391f * 4)
+#define HEVC_PSCALE_BMEM_DAT (0x3920 * 4)
+#define HEVC_PSCALE_DRAM_BUF_CTRL (0x3921 * 4)
+#define HEVC_PSCALE_MCMD_CTRL (0x3922 * 4)
+#define HEVC_PSCALE_MCMD_XSIZE (0x3923 * 4)
+#define HEVC_PSCALE_MCMD_YSIZE (0x3924 * 4)
+#define HEVC_PSCALE_RBUF_START_BLKX (0x3925 * 4)
+#define HEVC_PSCALE_RBUF_START_BLKY (0x3926 * 4)
+#define HEVC_PSCALE_PICO_SHIFT_XY (0x3928 * 4)
+#define HEVC_PSCALE_CTRL1 (0x3929 * 4)
+#define HEVC_PSCALE_SRCKEY_CTRL0 (0x392a * 4)
+#define HEVC_PSCALE_SRCKEY_CTRL1 (0x392b * 4)
+#define HEVC_PSCALE_CANVAS_RD_ADDR (0x392c * 4)
+#define HEVC_PSCALE_CANVAS_WR_ADDR (0x392d * 4)
+#define HEVC_PSCALE_CTRL2 (0x392e * 4)
+#define HEVC_HDEC_MC_OMEM_AUTO (0x3930 * 4)
+#define HEVC_HDEC_MC_MBRIGHT_IDX (0x3931 * 4)
+#define HEVC_HDEC_MC_MBRIGHT_RD (0x3932 * 4)
+#define HEVC_MC_MPORT_CTRL (0x3940 * 4)
+#define HEVC_MC_MPORT_DAT (0x3941 * 4)
+#define HEVC_MC_WT_PRED_CTRL (0x3942 * 4)
+#define HEVC_MC_MBBOT_ST_EVEN_ADDR (0x3944 * 4)
+#define HEVC_MC_MBBOT_ST_ODD_ADDR (0x3945 * 4)
+#define HEVC_MC_DPDN_MB_XY (0x3946 * 4)
+#define HEVC_MC_OMDN_MB_XY (0x3947 * 4)
+#define HEVC_MC_HCMDBUF_H (0x3948 * 4)
+#define HEVC_MC_HCMDBUF_L (0x3949 * 4)
+#define HEVC_MC_HCMD_H (0x394a * 4)
+#define HEVC_MC_HCMD_L (0x394b * 4)
+#define HEVC_MC_IDCT_DAT (0x394c * 4)
+#define HEVC_MC_CTRL_GCLK_CTRL (0x394d * 4)
+#define HEVC_MC_OTHER_GCLK_CTRL (0x394e * 4)
+#define HEVC_MC_CTRL2 (0x394f * 4)
+#define HEVC_MDEC_PIC_DC_CTRL (0x398e * 4)
+#define HEVC_MDEC_PIC_DC_STATUS (0x398f * 4)
+#define HEVC_ANC0_CANVAS_ADDR (0x3990 * 4)
+#define HEVC_ANC1_CANVAS_ADDR (0x3991 * 4)
+#define HEVC_ANC2_CANVAS_ADDR (0x3992 * 4)
+#define HEVC_ANC3_CANVAS_ADDR (0x3993 * 4)
+#define HEVC_ANC4_CANVAS_ADDR (0x3994 * 4)
+#define HEVC_ANC5_CANVAS_ADDR (0x3995 * 4)
+#define HEVC_ANC6_CANVAS_ADDR (0x3996 * 4)
+#define HEVC_ANC7_CANVAS_ADDR (0x3997 * 4)
+#define HEVC_ANC8_CANVAS_ADDR (0x3998 * 4)
+#define HEVC_ANC9_CANVAS_ADDR (0x3999 * 4)
+#define HEVC_ANC10_CANVAS_ADDR (0x399a * 4)
+#define HEVC_ANC11_CANVAS_ADDR (0x399b * 4)
+#define HEVC_ANC12_CANVAS_ADDR (0x399c * 4)
+#define HEVC_ANC13_CANVAS_ADDR (0x399d * 4)
+#define HEVC_ANC14_CANVAS_ADDR (0x399e * 4)
+#define HEVC_ANC15_CANVAS_ADDR (0x399f * 4)
+#define HEVC_ANC16_CANVAS_ADDR (0x39a0 * 4)
+#define HEVC_ANC17_CANVAS_ADDR (0x39a1 * 4)
+#define HEVC_ANC18_CANVAS_ADDR (0x39a2 * 4)
+#define HEVC_ANC19_CANVAS_ADDR (0x39a3 * 4)
+#define HEVC_ANC20_CANVAS_ADDR (0x39a4 * 4)
+#define HEVC_ANC21_CANVAS_ADDR (0x39a5 * 4)
+#define HEVC_ANC22_CANVAS_ADDR (0x39a6 * 4)
+#define HEVC_ANC23_CANVAS_ADDR (0x39a7 * 4)
+#define HEVC_ANC24_CANVAS_ADDR (0x39a8 * 4)
+#define HEVC_ANC25_CANVAS_ADDR (0x39a9 * 4)
+#define HEVC_ANC26_CANVAS_ADDR (0x39aa * 4)
+#define HEVC_ANC27_CANVAS_ADDR (0x39ab * 4)
+#define HEVC_ANC28_CANVAS_ADDR (0x39ac * 4)
+#define HEVC_ANC29_CANVAS_ADDR (0x39ad * 4)
+#define HEVC_ANC30_CANVAS_ADDR (0x39ae * 4)
+#define HEVC_ANC31_CANVAS_ADDR (0x39af * 4)
+#define HEVC_DBKR_CANVAS_ADDR (0x39b0 * 4)
+#define HEVC_DBKW_CANVAS_ADDR (0x39b1 * 4)
+#define HEVC_REC_CANVAS_ADDR (0x39b2 * 4)
+#define HEVC_CURR_CANVAS_CTRL (0x39b3 * 4)
+#define HEVC_MDEC_PIC_DC_THRESH (0x39b8 * 4)
+#define HEVC_MDEC_PICR_BUF_STATUS (0x39b9 * 4)
+#define HEVC_MDEC_PICW_BUF_STATUS (0x39ba * 4)
+#define HEVC_MCW_DBLK_WRRSP_CNT (0x39bb * 4)
+#define HEVC_MC_MBBOT_WRRSP_CNT (0x39bc * 4)
+#define HEVC_MDEC_PICW_BUF2_STATUS (0x39bd * 4)
+#define HEVC_WRRSP_FIFO_PICW_DBK (0x39be * 4)
+#define HEVC_WRRSP_FIFO_PICW_MC (0x39bf * 4)
+#define HEVC_AV_SCRATCH_0 (0x39c0 * 4)
+#define HEVC_AV_SCRATCH_1 (0x39c1 * 4)
+#define HEVC_AV_SCRATCH_2 (0x39c2 * 4)
+#define HEVC_AV_SCRATCH_3 (0x39c3 * 4)
+#define HEVC_AV_SCRATCH_4 (0x39c4 * 4)
+#define HEVC_AV_SCRATCH_5 (0x39c5 * 4)
+#define HEVC_AV_SCRATCH_6 (0x39c6 * 4)
+#define HEVC_AV_SCRATCH_7 (0x39c7 * 4)
+#define HEVC_AV_SCRATCH_8 (0x39c8 * 4)
+#define HEVC_AV_SCRATCH_9 (0x39c9 * 4)
+#define HEVC_AV_SCRATCH_A (0x39ca * 4)
+#define HEVC_AV_SCRATCH_B (0x39cb * 4)
+#define HEVC_AV_SCRATCH_C (0x39cc * 4)
+#define HEVC_AV_SCRATCH_D (0x39cd * 4)
+#define HEVC_AV_SCRATCH_E (0x39ce * 4)
+#define HEVC_AV_SCRATCH_F (0x39cf * 4)
+#define HEVC_AV_SCRATCH_G (0x39d0 * 4)
+#define HEVC_AV_SCRATCH_H (0x39d1 * 4)
+#define HEVC_AV_SCRATCH_I (0x39d2 * 4)
+#define HEVC_AV_SCRATCH_J (0x39d3 * 4)
+#define HEVC_AV_SCRATCH_K (0x39d4 * 4)
+#define HEVC_AV_SCRATCH_L (0x39d5 * 4)
+#define HEVC_AV_SCRATCH_M (0x39d6 * 4)
+#define HEVC_AV_SCRATCH_N (0x39d7 * 4)
+#define HEVC_WRRSP_CO_MB (0x39d8 * 4)
+#define HEVC_WRRSP_DCAC (0x39d9 * 4)
+#define HEVC_WRRSP_VLD (0x39da * 4)
+#define HEVC_MDEC_DOUBLEW_CFG0 (0x39db * 4)
+#define HEVC_MDEC_DOUBLEW_CFG1 (0x39dc * 4)
+#define HEVC_MDEC_DOUBLEW_CFG2 (0x39dd * 4)
+#define HEVC_MDEC_DOUBLEW_CFG3 (0x39de * 4)
+#define HEVC_MDEC_DOUBLEW_CFG4 (0x39df * 4)
+#define HEVC_MDEC_DOUBLEW_CFG5 (0x39e0 * 4)
+#define HEVC_MDEC_DOUBLEW_CFG6 (0x39e1 * 4)
+#define HEVC_MDEC_DOUBLEW_CFG7 (0x39e2 * 4)
+#define HEVC_MDEC_DOUBLEW_STATUS (0x39e3 * 4)
+#define HEVC_DBLK_RST (0x3950 * 4)
+#define HEVC_DBLK_CTRL (0x3951 * 4)
+#define HEVC_DBLK_MB_WID_HEIGHT (0x3952 * 4)
+#define HEVC_DBLK_STATUS (0x3953 * 4)
+#define HEVC_DBLK_CMD_CTRL (0x3954 * 4)
+#define HEVC_DBLK_MB_XY (0x3955 * 4)
+#define HEVC_DBLK_QP (0x3956 * 4)
+#define HEVC_DBLK_Y_BHFILT (0x3957 * 4)
+#define HEVC_DBLK_Y_BHFILT_HIGH (0x3958 * 4)
+#define HEVC_DBLK_Y_BVFILT (0x3959 * 4)
+#define HEVC_DBLK_CB_BFILT (0x395a * 4)
+#define HEVC_DBLK_CR_BFILT (0x395b * 4)
+#define HEVC_DBLK_Y_HFILT (0x395c * 4)
+#define HEVC_DBLK_Y_HFILT_HIGH (0x395d * 4)
+#define HEVC_DBLK_Y_VFILT (0x395e * 4)
+#define HEVC_DBLK_CB_FILT (0x395f * 4)
+#define HEVC_DBLK_CR_FILT (0x3960 * 4)
+#define HEVC_DBLK_BETAX_QP_SEL (0x3961 * 4)
+#define HEVC_DBLK_CLIP_CTRL0 (0x3962 * 4)
+#define HEVC_DBLK_CLIP_CTRL1 (0x3963 * 4)
+#define HEVC_DBLK_CLIP_CTRL2 (0x3964 * 4)
+#define HEVC_DBLK_CLIP_CTRL3 (0x3965 * 4)
+#define HEVC_DBLK_CLIP_CTRL4 (0x3966 * 4)
+#define HEVC_DBLK_CLIP_CTRL5 (0x3967 * 4)
+#define HEVC_DBLK_CLIP_CTRL6 (0x3968 * 4)
+#define HEVC_DBLK_CLIP_CTRL7 (0x3969 * 4)
+#define HEVC_DBLK_CLIP_CTRL8 (0x396a * 4)
+#define HEVC_DBLK_STATUS1 (0x396b * 4)
+#define HEVC_DBLK_GCLK_FREE (0x396c * 4)
+#define HEVC_DBLK_GCLK_OFF (0x396d * 4)
+#define HEVC_DBLK_AVSFLAGS (0x396e * 4)
+#define HEVC_DBLK_CBPY (0x3970 * 4)
+#define HEVC_DBLK_CBPY_ADJ (0x3971 * 4)
+#define HEVC_DBLK_CBPC (0x3972 * 4)
+#define HEVC_DBLK_CBPC_ADJ (0x3973 * 4)
+#define HEVC_DBLK_VHMVD (0x3974 * 4)
+#define HEVC_DBLK_STRONG (0x3975 * 4)
+#define HEVC_DBLK_RV8_QUANT (0x3976 * 4)
+#define HEVC_DBLK_CBUS_HCMD2 (0x3977 * 4)
+#define HEVC_DBLK_CBUS_HCMD1 (0x3978 * 4)
+#define HEVC_DBLK_CBUS_HCMD0 (0x3979 * 4)
+#define HEVC_DBLK_VLD_HCMD2 (0x397a * 4)
+#define HEVC_DBLK_VLD_HCMD1 (0x397b * 4)
+#define HEVC_DBLK_VLD_HCMD0 (0x397c * 4)
+#define HEVC_DBLK_OST_YBASE (0x397d * 4)
+#define HEVC_DBLK_OST_CBCRDIFF (0x397e * 4)
+#define HEVC_DBLK_CTRL1 (0x397f * 4)
+#define HEVC_MCRCC_CTL1 (0x3980 * 4)
+#define HEVC_MCRCC_CTL2 (0x3981 * 4)
+#define HEVC_MCRCC_CTL3 (0x3982 * 4)
+#define HEVC_GCLK_EN (0x3983 * 4)
+#define HEVC_MDEC_SW_RESET (0x3984 * 4)
+
+/*add from M8M2*/
+#define HEVC_VLD_STATUS_CTRL (0x3c00 * 4)
+#define HEVC_MPEG1_2_REG (0x3c01 * 4)
+#define HEVC_F_CODE_REG (0x3c02 * 4)
+#define HEVC_PIC_HEAD_INFO (0x3c03 * 4)
+#define HEVC_SLICE_VER_POS_PIC_TYPE (0x3c04 * 4)
+#define HEVC_QP_VALUE_REG (0x3c05 * 4)
+#define HEVC_MBA_INC (0x3c06 * 4)
+#define HEVC_MB_MOTION_MODE (0x3c07 * 4)
+#define HEVC_POWER_CTL_VLD (0x3c08 * 4)
+#define HEVC_MB_WIDTH (0x3c09 * 4)
+#define HEVC_SLICE_QP (0x3c0a * 4)
+#define HEVC_PRE_START_CODE (0x3c0b * 4)
+#define HEVC_SLICE_START_BYTE_01 (0x3c0c * 4)
+#define HEVC_SLICE_START_BYTE_23 (0x3c0d * 4)
+#define HEVC_RESYNC_MARKER_LENGTH (0x3c0e * 4)
+#define HEVC_DECODER_BUFFER_INFO (0x3c0f * 4)
+#define HEVC_FST_FOR_MV_X (0x3c10 * 4)
+#define HEVC_FST_FOR_MV_Y (0x3c11 * 4)
+#define HEVC_SCD_FOR_MV_X (0x3c12 * 4)
+#define HEVC_SCD_FOR_MV_Y (0x3c13 * 4)
+#define HEVC_FST_BAK_MV_X (0x3c14 * 4)
+#define HEVC_FST_BAK_MV_Y (0x3c15 * 4)
+#define HEVC_SCD_BAK_MV_X (0x3c16 * 4)
+#define HEVC_SCD_BAK_MV_Y (0x3c17 * 4)
+#define HEVC_VLD_DECODE_CONTROL (0x3c18 * 4)
+#define HEVC_VLD_REVERVED_19 (0x3c19 * 4)
+#define HEVC_VIFF_BIT_CNT (0x3c1a * 4)
+#define HEVC_BYTE_ALIGN_PEAK_HI (0x3c1b * 4)
+#define HEVC_BYTE_ALIGN_PEAK_LO (0x3c1c * 4)
+#define HEVC_NEXT_ALIGN_PEAK (0x3c1d * 4)
+#define HEVC_VC1_CONTROL_REG (0x3c1e * 4)
+#define HEVC_PMV1_X (0x3c20 * 4)
+#define HEVC_PMV1_Y (0x3c21 * 4)
+#define HEVC_PMV2_X (0x3c22 * 4)
+#define HEVC_PMV2_Y (0x3c23 * 4)
+#define HEVC_PMV3_X (0x3c24 * 4)
+#define HEVC_PMV3_Y (0x3c25 * 4)
+#define HEVC_PMV4_X (0x3c26 * 4)
+#define HEVC_PMV4_Y (0x3c27 * 4)
+#define HEVC_M4_TABLE_SELECT (0x3c28 * 4)
+#define HEVC_M4_CONTROL_REG (0x3c29 * 4)
+#define HEVC_BLOCK_NUM (0x3c2a * 4)
+#define HEVC_PATTERN_CODE (0x3c2b * 4)
+#define HEVC_MB_INFO (0x3c2c * 4)
+#define HEVC_VLD_DC_PRED (0x3c2d * 4)
+#define HEVC_VLD_ERROR_MASK (0x3c2e * 4)
+#define HEVC_VLD_DC_PRED_C (0x3c2f * 4)
+#define HEVC_LAST_SLICE_MV_ADDR (0x3c30 * 4)
+#define HEVC_LAST_MVX (0x3c31 * 4)
+#define HEVC_LAST_MVY (0x3c32 * 4)
+#define HEVC_VLD_C38 (0x3c38 * 4)
+#define HEVC_VLD_C39 (0x3c39 * 4)
+#define HEVC_VLD_STATUS (0x3c3a * 4)
+#define HEVC_VLD_SHIFT_STATUS (0x3c3b * 4)
+#define HEVC_VOFF_STATUS (0x3c3c * 4)
+#define HEVC_VLD_C3D (0x3c3d * 4)
+#define HEVC_VLD_DBG_INDEX (0x3c3e * 4)
+#define HEVC_VLD_DBG_DATA (0x3c3f * 4)
+#define HEVC_VLD_MEM_VIFIFO_START_PTR (0x3c40 * 4)
+#define HEVC_VLD_MEM_VIFIFO_CURR_PTR (0x3c41 * 4)
+#define HEVC_VLD_MEM_VIFIFO_END_PTR (0x3c42 * 4)
+#define HEVC_VLD_MEM_VIFIFO_BYTES_AVAIL (0x3c43 * 4)
+#define HEVC_VLD_MEM_VIFIFO_CONTROL (0x3c44 * 4)
+#define HEVC_VLD_MEM_VIFIFO_WP (0x3c45 * 4)
+#define HEVC_VLD_MEM_VIFIFO_RP (0x3c46 * 4)
+#define HEVC_VLD_MEM_VIFIFO_LEVEL (0x3c47 * 4)
+#define HEVC_VLD_MEM_VIFIFO_BUF_CNTL (0x3c48 * 4)
+#define HEVC_VLD_TIME_STAMP_CNTL (0x3c49 * 4)
+#define HEVC_VLD_TIME_STAMP_SYNC_0 (0x3c4a * 4)
+#define HEVC_VLD_TIME_STAMP_SYNC_1 (0x3c4b * 4)
+#define HEVC_VLD_TIME_STAMP_0 (0x3c4c * 4)
+#define HEVC_VLD_TIME_STAMP_1 (0x3c4d * 4)
+#define HEVC_VLD_TIME_STAMP_2 (0x3c4e * 4)
+#define HEVC_VLD_TIME_STAMP_3 (0x3c4f * 4)
+#define HEVC_VLD_TIME_STAMP_LENGTH (0x3c50 * 4)
+#define HEVC_VLD_MEM_VIFIFO_WRAP_COUNT (0x3c51 * 4)
+#define HEVC_VLD_MEM_VIFIFO_MEM_CTL (0x3c52 * 4)
+#define HEVC_VLD_MEM_VBUF_RD_PTR (0x3c53 * 4)
+#define HEVC_VLD_MEM_VBUF2_RD_PTR (0x3c54 * 4)
+#define HEVC_VLD_MEM_SWAP_ADDR (0x3c55 * 4)
+#define HEVC_VLD_MEM_SWAP_CTL (0x3c56 * 4)
+/**/
+
+/*add from M8M2*/
+#define HEVC_VCOP_CTRL_REG (0x3e00 * 4)
+#define HEVC_QP_CTRL_REG (0x3e01 * 4)
+#define HEVC_INTRA_QUANT_MATRIX (0x3e02 * 4)
+#define HEVC_NON_I_QUANT_MATRIX (0x3e03 * 4)
+#define HEVC_DC_SCALER (0x3e04 * 4)
+#define HEVC_DC_AC_CTRL (0x3e05 * 4)
+#define HEVC_DC_AC_SCALE_MUL (0x3e06 * 4)
+#define HEVC_DC_AC_SCALE_DIV (0x3e07 * 4)
+#define HEVC_POWER_CTL_IQIDCT (0x3e08 * 4)
+#define HEVC_RV_AI_Y_X (0x3e09 * 4)
+#define HEVC_RV_AI_U_X (0x3e0a * 4)
+#define HEVC_RV_AI_V_X (0x3e0b * 4)
+#define HEVC_RV_AI_MB_COUNT (0x3e0c * 4)
+#define HEVC_NEXT_INTRA_DMA_ADDRESS (0x3e0d * 4)
+#define HEVC_IQIDCT_CONTROL (0x3e0e * 4)
+#define HEVC_IQIDCT_DEBUG_INFO_0 (0x3e0f * 4)
+#define HEVC_DEBLK_CMD (0x3e10 * 4)
+#define HEVC_IQIDCT_DEBUG_IDCT (0x3e11 * 4)
+#define HEVC_DCAC_DMA_CTRL (0x3e12 * 4)
+#define HEVC_DCAC_DMA_ADDRESS (0x3e13 * 4)
+#define HEVC_DCAC_CPU_ADDRESS (0x3e14 * 4)
+#define HEVC_DCAC_CPU_DATA (0x3e15 * 4)
+#define HEVC_DCAC_MB_COUNT (0x3e16 * 4)
+#define HEVC_IQ_QUANT (0x3e17 * 4)
+#define HEVC_VC1_BITPLANE_CTL (0x3e18 * 4)
+
+
+/*add from M8M2*/
+#define HEVC_MSP (0x3300 * 4)
+#define HEVC_MPSR (0x3301 * 4)
+#define HEVC_MINT_VEC_BASE (0x3302 * 4)
+#define HEVC_MCPU_INTR_GRP (0x3303 * 4)
+#define HEVC_MCPU_INTR_MSK (0x3304 * 4)
+#define HEVC_MCPU_INTR_REQ (0x3305 * 4)
+#define HEVC_MPC_P (0x3306 * 4)
+#define HEVC_MPC_D (0x3307 * 4)
+#define HEVC_MPC_E (0x3308 * 4)
+#define HEVC_MPC_W (0x3309 * 4)
+#define HEVC_MINDEX0_REG (0x330a * 4)
+#define HEVC_MINDEX1_REG (0x330b * 4)
+#define HEVC_MINDEX2_REG (0x330c * 4)
+#define HEVC_MINDEX3_REG (0x330d * 4)
+#define HEVC_MINDEX4_REG (0x330e * 4)
+#define HEVC_MINDEX5_REG (0x330f * 4)
+#define HEVC_MINDEX6_REG (0x3310 * 4)
+#define HEVC_MINDEX7_REG (0x3311 * 4)
+#define HEVC_MMIN_REG (0x3312 * 4)
+#define HEVC_MMAX_REG (0x3313 * 4)
+#define HEVC_MBREAK0_REG (0x3314 * 4)
+#define HEVC_MBREAK1_REG (0x3315 * 4)
+#define HEVC_MBREAK2_REG (0x3316 * 4)
+#define HEVC_MBREAK3_REG (0x3317 * 4)
+#define HEVC_MBREAK_TYPE (0x3318 * 4)
+#define HEVC_MBREAK_CTRL (0x3319 * 4)
+#define HEVC_MBREAK_STAUTS (0x331a * 4)
+#define HEVC_MDB_ADDR_REG (0x331b * 4)
+#define HEVC_MDB_DATA_REG (0x331c * 4)
+#define HEVC_MDB_CTRL (0x331d * 4)
+#define HEVC_MSFTINT0 (0x331e * 4)
+#define HEVC_MSFTINT1 (0x331f * 4)
+#define HEVC_CSP (0x3320 * 4)
+#define HEVC_CPSR (0x3321 * 4)
+#define HEVC_CINT_VEC_BASE (0x3322 * 4)
+#define HEVC_CCPU_INTR_GRP (0x3323 * 4)
+#define HEVC_CCPU_INTR_MSK (0x3324 * 4)
+#define HEVC_CCPU_INTR_REQ (0x3325 * 4)
+#define HEVC_CPC_P (0x3326 * 4)
+#define HEVC_CPC_D (0x3327 * 4)
+#define HEVC_CPC_E (0x3328 * 4)
+#define HEVC_CPC_W (0x3329 * 4)
+#define HEVC_CINDEX0_REG (0x332a * 4)
+#define HEVC_CINDEX1_REG (0x332b * 4)
+#define HEVC_CINDEX2_REG (0x332c * 4)
+#define HEVC_CINDEX3_REG (0x332d * 4)
+#define HEVC_CINDEX4_REG (0x332e * 4)
+#define HEVC_CINDEX5_REG (0x332f * 4)
+#define HEVC_CINDEX6_REG (0x3330 * 4)
+#define HEVC_CINDEX7_REG (0x3331 * 4)
+#define HEVC_CMIN_REG (0x3332 * 4)
+#define HEVC_CMAX_REG (0x3333 * 4)
+#define HEVC_CBREAK0_REG (0x3334 * 4)
+#define HEVC_CBREAK1_REG (0x3335 * 4)
+#define HEVC_CBREAK2_REG (0x3336 * 4)
+#define HEVC_CBREAK3_REG (0x3337 * 4)
+#define HEVC_CBREAK_TYPE (0x3338 * 4)
+#define HEVC_CBREAK_CTRL (0x3339 * 4)
+#define HEVC_CBREAK_STAUTS (0x333a * 4)
+#define HEVC_CDB_ADDR_REG (0x333b * 4)
+#define HEVC_CDB_DATA_REG (0x333c * 4)
+#define HEVC_CDB_CTRL (0x333d * 4)
+#define HEVC_CSFTINT0 (0x333e * 4)
+#define HEVC_CSFTINT1 (0x333f * 4)
+#define HEVC_IMEM_DMA_CTRL (0x3340 * 4)
+#define HEVC_IMEM_DMA_ADR (0x3341 * 4)
+#define HEVC_IMEM_DMA_COUNT (0x3342 * 4)
+#define HEVC_WRRSP_IMEM (0x3343 * 4)
+#define HEVC_LMEM_DMA_CTRL (0x3350 * 4)
+#define HEVC_LMEM_DMA_ADR (0x3351 * 4)
+#define HEVC_LMEM_DMA_COUNT (0x3352 * 4)
+#define HEVC_WRRSP_LMEM (0x3353 * 4)
+#define HEVC_MAC_CTRL1 (0x3360 * 4)
+#define HEVC_ACC0REG1 (0x3361 * 4)
+#define HEVC_ACC1REG1 (0x3362 * 4)
+#define HEVC_MAC_CTRL2 (0x3370 * 4)
+#define HEVC_ACC0REG2 (0x3371 * 4)
+#define HEVC_ACC1REG2 (0x3372 * 4)
+#define HEVC_CPU_TRACE (0x3380 * 4)
+/**/
+
+#endif
+
diff --git a/drivers/media/platform/meson/vdec/vdec.c b/drivers/media/platform/meson/vdec/vdec.c
index 66d3ba1..5d152a3 100644
--- a/drivers/media/platform/meson/vdec/vdec.c
+++ b/drivers/media/platform/meson/vdec/vdec.c
@@ -11,82 +11,14 @@
 #include <media/v4l2-mem2mem.h>
 #include <media/v4l2-dev.h>
 #include <media/videobuf2-dma-contig.h>
-#include <linux/firmware.h>
 
 #include "vdec.h"
 #include "esparser.h"
 #include "canvas.h"
 #include "h264.h"
 #include "vdec_1.h"
-
-#define MC_SIZE			(4096 * 4)
-
-/* DOS registers */
-#define MPSR 0x0c04
-#define CPSR 0x0c84
-
-#define IMEM_DMA_CTRL  0x0d00
-#define IMEM_DMA_ADR   0x0d04
-#define IMEM_DMA_COUNT 0x0d08
-
-#define MDEC_PIC_DC_CTRL   0x2638
-
-/**
- * Load a VDEC firmware, each codec having its own firmware.
- * Some codecs also require additional firmware parts to be loaded after this
- */
-static int vdec_load_firmware(struct vdec_session *sess, const char* fwname)
-{
-	const struct firmware *fw;
-	struct vdec_core *core = sess->core;
-	struct device *dev = core->dev_dec;
-	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
-	static void *mc_addr;
-	static dma_addr_t mc_addr_map;
-	int ret;
-	u32 i = 10000;
-
-	ret = request_firmware(&fw, fwname, dev);
-	if (ret < 0)  {
-		dev_err(dev, "Unable to request firmware %s\n", fwname);
-		return -EINVAL;
-	}
-
-	mc_addr = kmalloc(MC_SIZE, GFP_KERNEL);
-	if (!mc_addr)
-		return -ENOMEM;
-
-	memcpy(mc_addr, fw->data, MC_SIZE);
-	mc_addr_map = dma_map_single(core->dev, mc_addr, MC_SIZE, DMA_TO_DEVICE);
-	if (!mc_addr_map) {
-		dev_err(dev, "Couldn't MAP DMA addr\n");
-		return -EINVAL;
-	}
-
-	writel_relaxed(0, core->dos_base + MPSR);
-	writel_relaxed(0, core->dos_base + CPSR);
-
-	writel_relaxed(readl_relaxed(core->dos_base + MDEC_PIC_DC_CTRL) & ~(1<<31), core->dos_base + MDEC_PIC_DC_CTRL);
-	writel_relaxed(mc_addr_map, core->dos_base + IMEM_DMA_ADR);
-	writel_relaxed(MC_SIZE, core->dos_base + IMEM_DMA_COUNT);
-	writel_relaxed((0x8000 | (7 << 16)), core->dos_base + IMEM_DMA_CTRL);
-
-	while (--i && readl(core->dos_base + IMEM_DMA_CTRL) & 0x8000) { }
-
-	if (i == 0) {
-		printk("Firmware load fail (DMA hang?)\n");
-		ret = -EINVAL;
-	} else
-		printk("Firmware load success\n");
-
-	if (codec_ops->load_extended_firmware)
-		codec_ops->load_extended_firmware(sess, fw->data + MC_SIZE, fw->size - MC_SIZE);
-
-	dma_unmap_single(core->dev, mc_addr_map, MC_SIZE, DMA_TO_DEVICE);
-	kfree(mc_addr);
-	release_firmware(fw);
-	return ret;
-}
+#include "hevc.h"
+#include "vdec_hevc.h"
 
 static void vdec_abort(struct vdec_session *sess) {
 	printk("Aborting decoding session!\n");
@@ -104,42 +36,26 @@ u32 vdec_get_output_size(struct vdec_session *sess) {
 
 static int vdec_poweron(struct vdec_session *sess) {
 	int ret;
-	struct vdec_core *core = sess->core;
 	struct vdec_ops *vdec_ops = sess->fmt_out->vdec_ops;
-	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
 
 	printk("vdec_poweron\n");
 
-	vdec_ops->start(sess);
-
-	stbuf_power_up(sess);
-
-	/*TODO: power up the decoder related to the input PIXFMT */
-	ret = vdec_load_firmware(sess, sess->fmt_out->firmware_path);// "");
+	ret = vdec_ops->start(sess);
 	if (ret)
 		return ret;
 
-	codec_ops->start(sess);
-
-	/* Enable firmware processor */
-	writel_relaxed(1, core->dos_base + MPSR);
-
 	esparser_power_up(sess);
 
 	return 0;
 }
 
 static void vdec_poweroff(struct vdec_session *sess) {
-	struct vdec_core *core = sess->core;
 	struct vdec_ops *vdec_ops = sess->fmt_out->vdec_ops;
 	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
 
 	kthread_stop(sess->esparser_queue_thread);
-	codec_ops->stop(sess);
-
-	writel_relaxed(0, core->dos_base + MPSR);
-	writel_relaxed(0, core->dos_base + CPSR);
 
+	codec_ops->stop(sess);
 	vdec_ops->stop(sess);
 }
 
@@ -346,14 +262,14 @@ static const struct vdec_format vdec_formats[] = {
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_h264_ops,
 		.firmware_path = "meson/gxl/gxtvbb_vh264_mc",
-	}, /*{
+	}, {
 		.pixfmt = V4L2_PIX_FMT_HEVC,
 		.num_planes = 1,
 		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.vdec_ops = &vdec_hevc_ops,
 		.codec_ops = &codec_hevc_ops,
 		.firmware_path = "meson/gxl/vh265_mc",
-	},*/
+	},
 };
 
 static const struct vdec_format * find_format(u32 pixfmt, u32 type)
@@ -420,8 +336,8 @@ vdec_try_fmt_common(struct v4l2_format *f)
 		pixmp->height = 720;
 	}
 
-	pixmp->width  = clamp(pixmp->width,  (u32)256, (u32)1920);
-	pixmp->height = clamp(pixmp->height, (u32)144, (u32)1080);
+	pixmp->width  = clamp(pixmp->width,  (u32)256, (u32)3840);
+	pixmp->height = clamp(pixmp->height, (u32)144, (u32)2160);
 
 	if (pixmp->field == V4L2_FIELD_ANY)
 		pixmp->field = V4L2_FIELD_NONE;
@@ -557,6 +473,36 @@ static int vdec_enum_fmt(struct file *file, void *fh, struct v4l2_fmtdesc *f)
 	return 0;
 }
 
+static int vdec_enum_framesizes(struct file *file, void *fh,
+				struct v4l2_frmsizeenum *fsize)
+{
+	const struct vdec_format *fmt;
+
+	fmt = find_format(fsize->pixel_format,
+			  V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+	if (!fmt) {
+		fmt = find_format(fsize->pixel_format,
+				  V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+		if (!fmt)
+			return -EINVAL;
+	}
+
+	if (fsize->index)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;
+
+	/* TODO: Store these constants in vdec_format */
+	fsize->stepwise.min_width = 256;
+	fsize->stepwise.max_width = 3840;
+	fsize->stepwise.step_width = 1;
+	fsize->stepwise.min_height = 144;
+	fsize->stepwise.max_height = 2160;
+	fsize->stepwise.step_height = 1;
+
+	return 0;
+}
+
 static const struct v4l2_ioctl_ops vdec_ioctl_ops = {
 	.vidioc_querycap = vdec_querycap,
 	.vidioc_enum_fmt_vid_cap_mplane = vdec_enum_fmt,
@@ -578,7 +524,7 @@ static const struct v4l2_ioctl_ops vdec_ioctl_ops = {
 	.vidioc_streamon = v4l2_m2m_ioctl_streamon,
 	.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,
 	//.vidioc_s_parm = vdec_s_parm,
-	//.vidioc_enum_framesizes = vdec_enum_framesizes,
+	.vidioc_enum_framesizes = vdec_enum_framesizes,
 	//.vidioc_subscribe_event = vdec_subscribe_event,
 	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
 	//.vidioc_try_decoder_cmd = vdec_try_decoder_cmd,
diff --git a/drivers/media/platform/meson/vdec/vdec_1.c b/drivers/media/platform/meson/vdec/vdec_1.c
index 0b57b2f..2c6139c 100644
--- a/drivers/media/platform/meson/vdec/vdec_1.c
+++ b/drivers/media/platform/meson/vdec/vdec_1.c
@@ -1,3 +1,5 @@
+#include <linux/firmware.h>
+
 #include "vdec_1.h"
 
 /* AO Registers */
@@ -7,7 +9,12 @@
 #define ASSIST_MBOX1_CLR_REG 0x01d4
 #define ASSIST_MBOX1_MASK    0x01d8
 
+#define MPSR 0x0c04
+#define CPSR 0x0c84
+
 #define IMEM_DMA_CTRL  0x0d00
+#define IMEM_DMA_ADR   0x0d04
+#define IMEM_DMA_COUNT 0x0d08
 #define LMEM_DMA_CTRL  0x0d40
 
 #define MC_STATUS0  0x2424
@@ -24,20 +31,120 @@
 
 #define DOS_SW_RESET0             0xfc00
 #define DOS_GCLK_EN0              0xfc04
+#define DOS_GEN_CTRL0             0xfc08
 #define DOS_MEM_PD_VDEC           0xfcc0
 #define DOS_VDEC_MCRCC_STALL_CTRL 0xfd00
 
+/* Stream Buffer (stbuf) regs (DOS) */
+#define POWER_CTL_VLD 0x3020
+#define VLD_MEM_VIFIFO_START_PTR 0x3100
+#define VLD_MEM_VIFIFO_CURR_PTR 0x3104
+#define VLD_MEM_VIFIFO_END_PTR 0x3108
+#define VLD_MEM_VIFIFO_CONTROL 0x3110
+	#define MEM_FIFO_CNT_BIT	16
+	#define MEM_FILL_ON_LEVEL	BIT(10)
+	#define MEM_CTRL_EMPTY_EN	BIT(2)
+	#define MEM_CTRL_FILL_EN	BIT(1)
+#define VLD_MEM_VIFIFO_WP 0x3114
+#define VLD_MEM_VIFIFO_RP 0x3118
+#define VLD_MEM_VIFIFO_BUF_CNTL 0x3120
+	#define MEM_BUFCTRL_MANUAL	BIT(1)
+#define VLD_MEM_VIFIFO_WRAP_COUNT 0x3144
+
+#define MC_SIZE			(4096 * 4)
+
+static int vdec_1_load_firmware(struct vdec_session *sess, const char* fwname)
+{
+	const struct firmware *fw;
+	struct vdec_core *core = sess->core;
+	struct device *dev = core->dev_dec;
+	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
+	static void *mc_addr;
+	static dma_addr_t mc_addr_map;
+	int ret;
+	u32 i = 1000;
+
+	ret = request_firmware(&fw, fwname, dev);
+	if (ret < 0)  {
+		dev_err(dev, "Unable to request firmware %s\n", fwname);
+		return -EINVAL;
+	}
+
+	mc_addr = kmalloc(MC_SIZE, GFP_KERNEL);
+	if (!mc_addr)
+		return -ENOMEM;
+
+	memcpy(mc_addr, fw->data, MC_SIZE);
+	mc_addr_map = dma_map_single(core->dev, mc_addr, MC_SIZE, DMA_TO_DEVICE);
+	if (!mc_addr_map) {
+		dev_err(dev, "Couldn't MAP DMA addr\n");
+		return -EINVAL;
+	}
+
+	writel_relaxed(0, core->dos_base + MPSR);
+	writel_relaxed(0, core->dos_base + CPSR);
+
+	writel_relaxed(readl_relaxed(core->dos_base + MDEC_PIC_DC_CTRL) & ~(1<<31), core->dos_base + MDEC_PIC_DC_CTRL);
+
+	writel_relaxed(mc_addr_map, core->dos_base + IMEM_DMA_ADR);
+	writel_relaxed(MC_SIZE / 4, core->dos_base + IMEM_DMA_COUNT);
+	writel_relaxed((0x8000 | (7 << 16)), core->dos_base + IMEM_DMA_CTRL);
+
+	while (--i && readl(core->dos_base + IMEM_DMA_CTRL) & 0x8000) { }
+
+	if (i == 0) {
+		printk("Firmware load fail (DMA hang?)\n");
+		ret = -EINVAL;
+	} else
+		printk("Firmware load success\n");
+
+	if (codec_ops->load_extended_firmware)
+		codec_ops->load_extended_firmware(sess, fw->data + MC_SIZE, fw->size - MC_SIZE);
+
+	dma_unmap_single(core->dev, mc_addr_map, MC_SIZE, DMA_TO_DEVICE);
+	kfree(mc_addr);
+	release_firmware(fw);
+	return ret;
+}
+
+int vdec_1_stbuf_power_up(struct vdec_session *sess) {
+	struct vdec_core *core = sess->core;
+
+	writel_relaxed(0, core->dos_base + VLD_MEM_VIFIFO_CONTROL);
+	writel_relaxed(0, core->dos_base + VLD_MEM_VIFIFO_WRAP_COUNT);
+	writel_relaxed(1 << 4, core->dos_base + POWER_CTL_VLD);
+
+	writel_relaxed(sess->vififo_paddr, core->dos_base + VLD_MEM_VIFIFO_START_PTR);
+	writel_relaxed(sess->vififo_paddr, core->dos_base + VLD_MEM_VIFIFO_CURR_PTR);
+	writel_relaxed(sess->vififo_paddr + sess->vififo_size - 8, core->dos_base + VLD_MEM_VIFIFO_END_PTR);
+
+	writel_relaxed(readl_relaxed(core->dos_base + VLD_MEM_VIFIFO_CONTROL) |  1, core->dos_base + VLD_MEM_VIFIFO_CONTROL);
+	writel_relaxed(readl_relaxed(core->dos_base + VLD_MEM_VIFIFO_CONTROL) & ~1, core->dos_base + VLD_MEM_VIFIFO_CONTROL);
+
+	writel_relaxed(MEM_BUFCTRL_MANUAL, core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL);
+	writel_relaxed(sess->vififo_paddr, core->dos_base + VLD_MEM_VIFIFO_WP);
+
+	writel_relaxed(readl_relaxed(core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL) |  1, core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL);
+	writel_relaxed(readl_relaxed(core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL) & ~1, core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL);
+
+	writel_relaxed(readl_relaxed(core->dos_base + VLD_MEM_VIFIFO_CONTROL) | (0x11 << MEM_FIFO_CNT_BIT) | MEM_FILL_ON_LEVEL | MEM_CTRL_FILL_EN | MEM_CTRL_EMPTY_EN, core->dos_base + VLD_MEM_VIFIFO_CONTROL);
+
+	return 0;
+}
+
 irqreturn_t vdec_1_isr(int irq, void *data)
 {
 	struct vdec_core *core = data;
 	struct vdec_session *sess = core->cur_sess;
+
 	return sess->fmt_out->codec_ops->isr(sess);
 }
 
 static int vdec_1_start(struct vdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
 	int ret;
+	struct vdec_core *core = sess->core;
+	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
 
 	printk("vdec_1_start\n");
 	/* Reset VDEC1 */
@@ -58,6 +165,22 @@ static int vdec_1_start(struct vdec_session *sess)
 	writel_relaxed(0x3ff, core->dos_base + GCLK_EN);
 	writel_relaxed(readl_relaxed(core->dos_base + MDEC_PIC_DC_CTRL) & ~(1<<31), core->dos_base + MDEC_PIC_DC_CTRL);
 
+	vdec_1_stbuf_power_up(sess);
+
+	ret = vdec_1_load_firmware(sess, sess->fmt_out->firmware_path);
+	if (ret)
+		return ret;
+
+	codec_ops->start(sess);
+
+	/* Enable firmware processor */
+	writel_relaxed(1, core->dos_base + MPSR);
+
+	/* VDEC_1 specific ESPARSER stuff */
+	writel_relaxed(0, core->dos_base + DOS_GEN_CTRL0); // set vififo_vbuf_rp_sel=>vdec
+	writel_relaxed(1, core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL);
+	writel_relaxed(readl_relaxed(core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL) & ~1, core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL);
+
 	return 0;
 }
 
@@ -66,6 +189,9 @@ static int vdec_1_stop(struct vdec_session *sess)
 	struct vdec_core *core = sess->core;
 	printk("vdec_1_stop\n");
 
+	writel_relaxed(0, core->dos_base + MPSR);
+	writel_relaxed(0, core->dos_base + CPSR);
+
 	while (readl_relaxed(core->dos_base + IMEM_DMA_CTRL) & 0x8000) { }
 
 	writel_relaxed((1<<12)|(1<<11), core->dos_base + DOS_SW_RESET0);
diff --git a/drivers/media/platform/meson/vdec/vdec_hevc.c b/drivers/media/platform/meson/vdec/vdec_hevc.c
new file mode 100644
index 0000000..77998f2
--- /dev/null
+++ b/drivers/media/platform/meson/vdec/vdec_hevc.c
@@ -0,0 +1,139 @@
+#include <linux/firmware.h>
+
+#include "vdec_1.h"
+#include "hevc_regs.h"
+
+/* AO Registers */
+#define AO_RTI_GEN_PWR_ISO0 0xec
+
+/* DOS Registers */
+#define ASSIST_MBOX1_CLR_REG 0x01d4
+#define ASSIST_MBOX1_MASK    0x01d8
+
+#define DOS_GEN_CTRL0	     0xfc08
+#define DOS_SW_RESET3        0xfcd0
+#define DOS_MEM_PD_HEVC      0xfccc
+#define DOS_GCLK_EN3	     0xfcd4
+
+#define MC_SIZE	(4096 * 4)
+
+static int vdec_hevc_load_firmware(struct vdec_session *sess, const char* fwname)
+{
+	const struct firmware *fw;
+	static void *mc_addr;
+	static dma_addr_t mc_addr_map;
+	int ret;
+	u32 i = 1000;
+	struct vdec_core *core = sess->core;
+	struct device *dev = core->dev_dec;
+	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
+
+	ret = request_firmware(&fw, fwname, dev);
+	if (ret < 0)  {
+		dev_err(dev, "Unable to request firmware %s\n", fwname);
+		return -EINVAL;
+	}
+
+	mc_addr = dma_alloc_coherent(core->dev, MC_SIZE, &mc_addr_map, GFP_KERNEL);
+	if (!mc_addr) {
+		printk("Failed allocating memory for firmware loading\n");
+		return -ENOMEM;
+	 }
+
+	memcpy(mc_addr, fw->data, MC_SIZE);
+
+	writel_relaxed(0, core->dos_base + HEVC_MPSR);
+	writel_relaxed(0, core->dos_base + HEVC_CPSR);
+
+	writel_relaxed(mc_addr_map, core->dos_base + HEVC_IMEM_DMA_ADR);
+	writel_relaxed(MC_SIZE / 4, core->dos_base + HEVC_IMEM_DMA_COUNT);
+	writel_relaxed((0x8000 | (7 << 16)), core->dos_base + HEVC_IMEM_DMA_CTRL);
+
+	while (--i && readl(core->dos_base + HEVC_IMEM_DMA_CTRL) & 0x8000) { }
+
+	if (i == 0) {
+		printk("Firmware load fail (DMA hang?)\n");
+		ret = -EINVAL;
+	} else
+		printk("Firmware load success\n");
+
+	if (codec_ops->load_extended_firmware)
+		codec_ops->load_extended_firmware(sess, fw->data + MC_SIZE, fw->size - MC_SIZE);
+
+	dma_free_coherent(core->dev, MC_SIZE, mc_addr, mc_addr_map);
+	release_firmware(fw);
+	return ret;
+}
+
+static void vdec_hevc_stbuf_init(struct vdec_session *sess) {
+	struct vdec_core *core = sess->core;
+
+	printk("vdec_hevc_stbuf_init\n");
+
+	writel_relaxed(readl_relaxed(core->dos_base + HEVC_STREAM_CONTROL) & ~1, core->dos_base + HEVC_STREAM_CONTROL);
+	writel_relaxed(sess->vififo_paddr, core->dos_base + HEVC_STREAM_START_ADDR);
+	writel_relaxed(sess->vififo_paddr + sess->vififo_size, core->dos_base + HEVC_STREAM_END_ADDR);
+	writel_relaxed(sess->vififo_paddr, core->dos_base + HEVC_STREAM_RD_PTR);
+	writel_relaxed(sess->vififo_paddr, core->dos_base + HEVC_STREAM_WR_PTR);
+
+	printk("vdec_hevc_stbuf_init end\n");
+}
+
+static int vdec_hevc_start(struct vdec_session *sess)
+{
+	int ret;
+	struct vdec_core *core = sess->core;
+	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
+
+	printk("vdec_hevc_start\n");
+
+	writel_relaxed(0xffffffff, core->dos_base + DOS_GCLK_EN3);
+
+	/* VDEC_HEVC Memories */
+	writel_relaxed(0x00000000, core->dos_base + DOS_MEM_PD_HEVC);
+
+	/* Remove VDEC_HEVC Isolation */
+	regmap_write(core->regmap_ao, AO_RTI_GEN_PWR_ISO0, ~0xc00);
+
+	/* Reset VDEC_HEVC*/
+	writel_relaxed(0xffffffff, core->dos_base + DOS_SW_RESET3);
+	udelay(10);
+	writel_relaxed(0x00000000, core->dos_base + DOS_SW_RESET3);
+
+	ret = vdec_hevc_load_firmware(sess, sess->fmt_out->firmware_path);
+	if (ret)
+		return ret;
+
+	codec_ops->start(sess);
+
+	writel_relaxed(1, core->dos_base + HEVC_MPSR);
+	vdec_hevc_stbuf_init(sess);
+
+	/* VDEC_HEVC specific ESPARSER stuff */
+	writel_relaxed(3 << 1, core->dos_base + DOS_GEN_CTRL0); // set vififo_vbuf_rp_sel=>vdec_hevc
+	writel_relaxed(readl_relaxed(core->dos_base + HEVC_STREAM_CONTROL) | (1 << 3) | 1, core->dos_base + HEVC_STREAM_CONTROL);
+	writel_relaxed(readl_relaxed(core->dos_base + HEVC_STREAM_FIFO_CTL) | (1 << 29), core->dos_base + HEVC_STREAM_FIFO_CTL);
+
+	printk("vdec_hevc_start end\n");
+
+	return 0;
+}
+
+static int vdec_hevc_stop(struct vdec_session *sess)
+{
+	struct vdec_core *core = sess->core;
+	printk("vdec_hevc_stop\n");
+
+	/* Enable VDEC_HEVC Isolation */
+	regmap_write(core->regmap_ao, AO_RTI_GEN_PWR_ISO0, 0xc00);
+
+	/* VDEC_HEVC Memories */
+	writel_relaxed(0xffffffffUL, core->dos_base + DOS_MEM_PD_HEVC);
+
+	return 0;
+}
+
+struct vdec_ops vdec_hevc_ops = {
+	.start = vdec_hevc_start,
+	.stop = vdec_hevc_stop,
+};
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/vdec_hevc.h b/drivers/media/platform/meson/vdec/vdec_hevc.h
new file mode 100644
index 0000000..af94bf0
--- /dev/null
+++ b/drivers/media/platform/meson/vdec/vdec_hevc.h
@@ -0,0 +1,8 @@
+#ifndef __MESON_VDEC_VDEC_HEVC_H_
+#define __MESON_VDEC_VDEC_HEVC_H_
+
+#include "vdec.h"
+
+extern struct vdec_ops vdec_hevc_ops;
+
+#endif
\ No newline at end of file
diff --git a/include/dt-bindings/clock/gxbb-clkc.h b/include/dt-bindings/clock/gxbb-clkc.h
index 3bec26e..ae7f6be 100644
--- a/include/dt-bindings/clock/gxbb-clkc.h
+++ b/include/dt-bindings/clock/gxbb-clkc.h
@@ -127,5 +127,7 @@
 #define CLKID_VAPB		140
 #define CLKID_VDEC_1_SEL	151
 #define CLKID_VDEC_1		153
+#define CLKID_VDEC_HEVC_SEL	154
+#define CLKID_VDEC_HEVC	156
 
 #endif /* __GXBB_CLKC_H */
diff --git a/include/uapi/linux/videodev2.h b/include/uapi/linux/videodev2.h
index 600877b..6560ac0 100644
--- a/include/uapi/linux/videodev2.h
+++ b/include/uapi/linux/videodev2.h
@@ -623,6 +623,7 @@ struct v4l2_pix_format {
 #define V4L2_PIX_FMT_JPEG     v4l2_fourcc('J', 'P', 'E', 'G') /* JFIF JPEG     */
 #define V4L2_PIX_FMT_DV       v4l2_fourcc('d', 'v', 's', 'd') /* 1394          */
 #define V4L2_PIX_FMT_MPEG     v4l2_fourcc('M', 'P', 'E', 'G') /* MPEG-1/2/4 Multiplexed */
+#define V4L2_PIX_FMT_HEVC     v4l2_fourcc('H', 'E', 'V', 'C') /* HEVC (H265) with start codes */
 #define V4L2_PIX_FMT_H264     v4l2_fourcc('H', '2', '6', '4') /* H264 with start codes */
 #define V4L2_PIX_FMT_H264_NO_SC v4l2_fourcc('A', 'V', 'C', '1') /* H264 without start codes */
 #define V4L2_PIX_FMT_H264_MVC v4l2_fourcc('M', '2', '6', '4') /* H264 MVC */
diff --git a/vh265_mc b/vh265_mc
new file mode 100644
index 0000000000000000000000000000000000000000..8f127a242a5d46ba071881e01c4b3c322c1e8c07
GIT binary patch
literal 16384
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
E0S#<~{r~^~

literal 0
HcmV?d00001

