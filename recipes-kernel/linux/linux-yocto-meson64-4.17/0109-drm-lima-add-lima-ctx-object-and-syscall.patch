From 5ffe75f8a46b96e747a69859f1ddf5f948933279 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sun, 11 Feb 2018 11:05:14 +0800
Subject: [PATCH 109/134] drm/lima: add lima ctx object and syscall

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 drivers/gpu/drm/lima/Makefile   |   3 +-
 drivers/gpu/drm/lima/lima.h     |  37 ++++++++++--
 drivers/gpu/drm/lima/lima_ctx.c | 121 ++++++++++++++++++++++++++++++++++++++++
 drivers/gpu/drm/lima/lima_drv.c |  80 ++++++++++++++++++--------
 drivers/gpu/drm/lima/lima_gem.c |  47 +++++++---------
 include/uapi/drm/lima_drm.h     |  14 +++++
 6 files changed, 246 insertions(+), 56 deletions(-)
 create mode 100644 drivers/gpu/drm/lima/lima_ctx.c

diff --git a/drivers/gpu/drm/lima/Makefile b/drivers/gpu/drm/lima/Makefile
index 1ea42ee..f47e806 100644
--- a/drivers/gpu/drm/lima/Makefile
+++ b/drivers/gpu/drm/lima/Makefile
@@ -8,6 +8,7 @@ lima-y := \
 	lima_pp.o \
 	lima_gem.o \
 	lima_vm.o \
-	lima_sched.o
+	lima_sched.o \
+	lima_ctx.o
 
 obj-$(CONFIG_DRM_LIMA) += lima.o
diff --git a/drivers/gpu/drm/lima/lima.h b/drivers/gpu/drm/lima/lima.h
index 3ffda1f..bf0d6eb 100644
--- a/drivers/gpu/drm/lima/lima.h
+++ b/drivers/gpu/drm/lima/lima.h
@@ -123,12 +123,23 @@ struct lima_device {
 	struct lima_vm *empty_vm;
 };
 
-struct lima_drm_priv {
-	struct lima_vm *vm;
+struct lima_ctx {
+	struct kref refcnt;
+	struct lima_device *dev;
 	struct lima_sched_context context[LIMA_MAX_PIPE];
 	atomic_t guilty;
 };
 
+struct lima_ctx_mgr {
+	spinlock_t lock;
+	struct idr handles;
+};
+
+struct lima_drm_priv {
+	struct lima_vm *vm;
+	struct lima_ctx_mgr ctx_mgr;
+};
+
 struct lima_bo_va_mapping {
 	struct list_head list;
 	struct rb_node rb;
@@ -137,6 +148,17 @@ struct lima_bo_va_mapping {
 	uint32_t __subtree_last;
 };
 
+struct lima_submit {
+	struct lima_ctx *ctx;
+	int pipe;
+
+	struct drm_lima_gem_submit_bo *bos;
+	struct lima_bo **lbos;
+	u32 nr_bos;
+
+	struct lima_sched_task *task;
+};
+
 int lima_device_init(struct lima_device *ldev);
 void lima_device_fini(struct lima_device *ldev);
 
@@ -170,9 +192,7 @@ int lima_gem_mmap_offset(struct drm_file *file, u32 handle, u64 *offset);
 int lima_gem_mmap(struct file *filp, struct vm_area_struct *vma);
 int lima_gem_va_map(struct drm_file *file, u32 handle, u32 flags, u32 va);
 int lima_gem_va_unmap(struct drm_file *file, u32 handle, u32 va);
-int lima_gem_submit(struct drm_file *file, int pipe,
-		    struct drm_lima_gem_submit_bo *bos, u32 nr_bos,
-		    struct lima_sched_task *task, u32 *fence);
+int lima_gem_submit(struct drm_file *file, struct lima_submit *submit, u32 *fence);
 int lima_gem_wait(struct drm_file *file, u32 handle, u32 op, u64 timeout_ns);
 struct drm_gem_object *lima_gem_prime_import_sg_table(struct drm_device *dev,
 						      struct dma_buf_attachment *attach,
@@ -182,4 +202,11 @@ struct reservation_object *lima_gem_prime_res_obj(struct drm_gem_object *obj);
 
 unsigned long lima_timeout_to_jiffies(u64 timeout_ns);
 
+int lima_ctx_create(struct lima_device *dev, struct lima_ctx_mgr *mgr, u32 *id);
+int lima_ctx_free(struct lima_ctx_mgr *mgr, u32 id);
+struct lima_ctx *lima_ctx_get(struct lima_ctx_mgr *mgr, u32 id);
+void lima_ctx_put(struct lima_ctx *ctx);
+void lima_ctx_mgr_init(struct lima_ctx_mgr *mgr);
+void lima_ctx_mgr_fini(struct lima_ctx_mgr *mgr);
+
 #endif
diff --git a/drivers/gpu/drm/lima/lima_ctx.c b/drivers/gpu/drm/lima/lima_ctx.c
new file mode 100644
index 0000000..2836cca
--- /dev/null
+++ b/drivers/gpu/drm/lima/lima_ctx.c
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2018 Lima Project
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "lima.h"
+
+int lima_ctx_create(struct lima_device *dev, struct lima_ctx_mgr *mgr, u32 *id)
+{
+	struct lima_ctx *ctx;
+	int i, err;
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+	ctx->dev = dev;
+	kref_init(&ctx->refcnt);
+
+	for (i = 0; i < LIMA_MAX_PIPE; i++) {
+		err = lima_sched_context_init(dev->pipe[i], ctx->context + i, &ctx->guilty);
+		if (err)
+			goto err_out0;
+	}
+
+	spin_lock(&mgr->lock);
+	err = idr_alloc(&mgr->handles, ctx, 1, 0, GFP_KERNEL);
+	if (err < 0)
+		goto err_out1;
+	spin_unlock(&mgr->lock);
+
+	*id = err;
+	return 0;
+
+err_out1:
+	spin_unlock(&mgr->lock);
+err_out0:
+	for (i--; i >= 0; i--)
+		lima_sched_context_fini(dev->pipe[i], ctx->context + i);
+	kfree(ctx);
+	return err;
+}
+
+static void lima_ctx_do_release(struct kref *ref)
+{
+	struct lima_ctx *ctx = container_of(ref, struct lima_ctx, refcnt);
+	int i;
+
+	for (i = 0; i < LIMA_MAX_PIPE; i++)
+		lima_sched_context_fini(ctx->dev->pipe[i], ctx->context + i);
+	kfree(ctx);
+}
+
+int lima_ctx_free(struct lima_ctx_mgr *mgr, u32 id)
+{
+	struct lima_ctx *ctx;
+
+	spin_lock(&mgr->lock);
+	ctx = idr_remove(&mgr->handles, id);
+	spin_unlock(&mgr->lock);
+
+	if (ctx) {
+		kref_put(&ctx->refcnt, lima_ctx_do_release);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+struct lima_ctx *lima_ctx_get(struct lima_ctx_mgr *mgr, u32 id)
+{
+	struct lima_ctx *ctx;
+
+	spin_lock(&mgr->lock);
+	ctx = idr_find(&mgr->handles, id);
+	if (ctx)
+		kref_get(&ctx->refcnt);
+	spin_unlock(&mgr->lock);
+	return ctx;
+}
+
+void lima_ctx_put(struct lima_ctx *ctx)
+{
+	kref_put(&ctx->refcnt, lima_ctx_do_release);
+}
+
+void lima_ctx_mgr_init(struct lima_ctx_mgr *mgr)
+{
+        spin_lock_init(&mgr->lock);
+	idr_init(&mgr->handles);
+}
+
+void lima_ctx_mgr_fini(struct lima_ctx_mgr *mgr)
+{
+	struct lima_ctx *ctx;
+	struct idr *idp;
+	uint32_t id;
+
+	idp = &mgr->handles;
+
+	idr_for_each_entry(idp, ctx, id) {
+	        kref_put(&ctx->refcnt, lima_ctx_do_release);
+	}
+
+	idr_destroy(&mgr->handles);
+}
diff --git a/drivers/gpu/drm/lima/lima_drv.c b/drivers/gpu/drm/lima/lima_drv.c
index 0159266..16d8d3b 100644
--- a/drivers/gpu/drm/lima/lima_drv.c
+++ b/drivers/gpu/drm/lima/lima_drv.c
@@ -73,23 +73,29 @@ static int lima_ioctl_gem_va(struct drm_device *dev, void *data, struct drm_file
 static int lima_ioctl_gem_submit(struct drm_device *dev, void *data, struct drm_file *file)
 {
 	struct drm_lima_gem_submit *args = data;
-	struct drm_lima_gem_submit_bo *bos;
-	int err = 0;
 	struct lima_device *ldev = to_lima_dev(dev);
+	struct lima_drm_priv *priv = file->driver_priv;
+	struct drm_lima_gem_submit_bo *bos;
 	struct lima_sched_pipe *pipe;
 	struct lima_sched_task *task;
+	struct lima_ctx *ctx;
+	struct lima_submit submit = {0};
+	int err = 0, size;
 
-	if (args->pipe >= ARRAY_SIZE(ldev->pipe) || args->nr_bos == 0)
+	if (args->pipe >= LIMA_MAX_PIPE || args->nr_bos == 0)
 		return -EINVAL;
 
 	pipe = ldev->pipe[args->pipe];
 	if (args->frame_size != pipe->frame_size)
 		return -EINVAL;
 
-	bos = kmalloc(args->nr_bos * sizeof(*bos), GFP_KERNEL);
+	size = args->nr_bos * (sizeof(*submit.bos) + sizeof(*submit.lbos));
+	bos = kzalloc(size, GFP_KERNEL);
 	if (!bos)
 		return -ENOMEM;
-	if (copy_from_user(bos, u64_to_user_ptr(args->bos), args->nr_bos * sizeof(*bos))) {
+
+	size = args->nr_bos * sizeof(*submit.bos);
+	if (copy_from_user(bos, u64_to_user_ptr(args->bos), size)) {
 		err = -EFAULT;
 		goto out0;
 	}
@@ -110,8 +116,22 @@ static int lima_ioctl_gem_submit(struct drm_device *dev, void *data, struct drm_
 	if (err)
 		goto out1;
 
-	err = lima_gem_submit(file, args->pipe, bos, args->nr_bos, task, &args->fence);
+	ctx = lima_ctx_get(&priv->ctx_mgr, args->ctx);
+	if (!ctx) {
+		err = -ENOENT;
+		goto out1;
+	}
+
+	submit.pipe = args->pipe;
+	submit.bos = bos;
+	submit.lbos = (void *)bos + size;
+	submit.nr_bos = args->nr_bos;
+	submit.task = task;
+	submit.ctx = ctx;
 
+	err = lima_gem_submit(file, &submit, &args->fence);
+
+	lima_ctx_put(ctx);
 out1:
 	if (err)
 		kmem_cache_free(pipe->task_slab, task);
@@ -124,12 +144,21 @@ static int lima_ioctl_wait_fence(struct drm_device *dev, void *data, struct drm_
 {
 	struct drm_lima_wait_fence *args = data;
 	struct lima_drm_priv *priv = file->driver_priv;
+	struct lima_ctx *ctx;
+	int err;
 
-	if (args->pipe >= ARRAY_SIZE(priv->context))
+	if (args->pipe >= LIMA_MAX_PIPE)
 		return -EINVAL;
 
-	return lima_sched_context_wait_fence(priv->context + args->pipe,
-					     args->fence, args->timeout_ns);
+	ctx = lima_ctx_get(&priv->ctx_mgr, args->ctx);
+	if (!ctx)
+		return -ENOENT;
+
+	err = lima_sched_context_wait_fence(ctx->context + args->pipe,
+					    args->fence, args->timeout_ns);
+
+	lima_ctx_put(ctx);
+	return err;
 }
 
 static int lima_ioctl_gem_wait(struct drm_device *dev, void *data, struct drm_file *file)
@@ -142,9 +171,23 @@ static int lima_ioctl_gem_wait(struct drm_device *dev, void *data, struct drm_fi
 	return lima_gem_wait(file, args->handle, args->op, args->timeout_ns);
 }
 
+static int lima_ioctl_ctx(struct drm_device *dev, void *data, struct drm_file *file)
+{
+	struct drm_lima_ctx *args = data;
+	struct lima_drm_priv *priv = file->driver_priv;
+	struct lima_device *ldev = to_lima_dev(dev);
+
+	if (args->op == LIMA_CTX_OP_CREATE)
+		return lima_ctx_create(ldev, &priv->ctx_mgr, &args->id);
+	else if (args->op == LIMA_CTX_OP_FREE)
+		return lima_ctx_free(&priv->ctx_mgr, args->id);
+
+	return -EINVAL;
+}
+
 static int lima_drm_driver_open(struct drm_device *dev, struct drm_file *file)
 {
-	int err, i;
+	int err;
 	struct lima_drm_priv *priv;
 	struct lima_device *ldev = to_lima_dev(dev);
 
@@ -158,19 +201,11 @@ static int lima_drm_driver_open(struct drm_device *dev, struct drm_file *file)
 		goto err_out0;
 	}
 
-	for (i = 0; i < LIMA_MAX_PIPE; i++) {
-		err = lima_sched_context_init(ldev->pipe[i], priv->context + i, &priv->guilty);
-		if (err)
-			goto err_out1;
-	}
+        lima_ctx_mgr_init(&priv->ctx_mgr);
 
 	file->driver_priv = priv;
 	return 0;
 
-err_out1:
-	for (i--; i >= 0; i--)
-		lima_sched_context_fini(ldev->pipe[i], priv->context + i);
-	lima_vm_put(priv->vm);
 err_out0:
 	kfree(priv);
 	return err;
@@ -179,12 +214,8 @@ static int lima_drm_driver_open(struct drm_device *dev, struct drm_file *file)
 static void lima_drm_driver_postclose(struct drm_device *dev, struct drm_file *file)
 {
 	struct lima_drm_priv *priv = file->driver_priv;
-	struct lima_device *ldev = to_lima_dev(dev);
-	int i;
-
-	for (i = 0; i < LIMA_MAX_PIPE; i++)
-		lima_sched_context_fini(ldev->pipe[i], priv->context + i);
 
+        lima_ctx_mgr_fini(&priv->ctx_mgr);
 	lima_vm_put(priv->vm);
 	kfree(priv);
 }
@@ -197,6 +228,7 @@ static const struct drm_ioctl_desc lima_drm_driver_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(LIMA_GEM_SUBMIT, lima_ioctl_gem_submit, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(LIMA_WAIT_FENCE, lima_ioctl_wait_fence, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(LIMA_GEM_WAIT, lima_ioctl_gem_wait, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(LIMA_CTX, lima_ioctl_ctx, DRM_AUTH|DRM_RENDER_ALLOW),
 };
 
 extern const struct vm_operations_struct lima_gem_vm_ops;
diff --git a/drivers/gpu/drm/lima/lima_gem.c b/drivers/gpu/drm/lima/lima_gem.c
index b3e4a3e..67099e4 100644
--- a/drivers/gpu/drm/lima/lima_gem.c
+++ b/drivers/gpu/drm/lima/lima_gem.c
@@ -413,66 +413,61 @@ static int lima_gem_sync_bo(struct lima_sched_task *task, struct lima_bo *bo, bo
 	return 0;
 }
 
-int lima_gem_submit(struct drm_file *file, int pipe,
-		    struct drm_lima_gem_submit_bo *bos, u32 nr_bos,
-		    struct lima_sched_task *task, u32 *fence)
+int lima_gem_submit(struct drm_file *file, struct lima_submit *submit, u32 *fence)
 {
-	struct lima_bo **lbos;
 	int i, err = 0;
 	struct ww_acquire_ctx ctx;
 	struct lima_drm_priv *priv = to_lima_drm_priv(file);
 
-	lbos = kzalloc(sizeof(*lbos) * nr_bos, GFP_KERNEL);
-	if (!lbos)
-		return -ENOMEM;
-
-	for (i = 0; i < nr_bos; i++) {
+	for (i = 0; i < submit->nr_bos; i++) {
 		struct drm_gem_object *obj;
 
-		obj = drm_gem_object_lookup(file, bos[i].handle);
+		obj = drm_gem_object_lookup(file, submit->bos[i].handle);
 		if (!obj) {
 			err = -ENOENT;
 			goto out0;
 		}
-		lbos[i] = to_lima_bo(obj);
+		submit->lbos[i] = to_lima_bo(obj);
 	}
 
-	err = lima_gem_lock_bos(lbos, nr_bos, &ctx);
+	err = lima_gem_lock_bos(submit->lbos, submit->nr_bos, &ctx);
 	if (err)
 		goto out0;
 
-	err = lima_sched_task_init(task, priv->context + pipe, priv->vm);
+	err = lima_sched_task_init(
+		submit->task, submit->ctx->context + submit->pipe, priv->vm);
 	if (err)
 		goto out1;
 
-	for (i = 0; i < nr_bos; i++) {
-		err = lima_gem_sync_bo(task, lbos[i], bos[i].flags & LIMA_SUBMIT_BO_WRITE);
+	for (i = 0; i < submit->nr_bos; i++) {
+		err = lima_gem_sync_bo(submit->task, submit->lbos[i],
+				       submit->bos[i].flags & LIMA_SUBMIT_BO_WRITE);
 		if (err)
 			goto out2;
 	}
 
-	for (i = 0; i < nr_bos; i++) {
-		if (bos[i].flags & LIMA_SUBMIT_BO_WRITE)
+	for (i = 0; i < submit->nr_bos; i++) {
+		if (submit->bos[i].flags & LIMA_SUBMIT_BO_WRITE)
 			reservation_object_add_excl_fence(
-				lbos[i]->resv, &task->base.s_fence->finished);
+				submit->lbos[i]->resv, &submit->task->base.s_fence->finished);
 		else
 			reservation_object_add_shared_fence(
-				lbos[i]->resv, &task->base.s_fence->finished);
+				submit->lbos[i]->resv, &submit->task->base.s_fence->finished);
 	}
 
-	*fence = lima_sched_context_queue_task(priv->context + pipe, task);
+	*fence = lima_sched_context_queue_task(
+		submit->ctx->context + submit->pipe, submit->task);
 
 out2:
 	if (err)
-		lima_sched_task_fini(task);
+		lima_sched_task_fini(submit->task);
 out1:
-	for (i = 0; i < nr_bos; i++)
-		ww_mutex_unlock(&lbos[i]->resv->lock);
+	for (i = 0; i < submit->nr_bos; i++)
+		ww_mutex_unlock(&submit->lbos[i]->resv->lock);
 	ww_acquire_fini(&ctx);
 out0:
-	for (i = 0; i < nr_bos && lbos[i]; i++)
-		drm_gem_object_unreference_unlocked(&lbos[i]->gem);
-	kfree(lbos);
+	for (i = 0; i < submit->nr_bos && submit->lbos[i]; i++)
+		drm_gem_object_unreference_unlocked(&submit->lbos[i]->gem);
 	return err;
 }
 
diff --git a/include/uapi/drm/lima_drm.h b/include/uapi/drm/lima_drm.h
index 6f164d6..40f0e81 100644
--- a/include/uapi/drm/lima_drm.h
+++ b/include/uapi/drm/lima_drm.h
@@ -138,12 +138,16 @@ struct drm_lima_gem_submit {
 	__u32 frame_size;  /* in */
 	__u64 bos;         /* in */
 	__u64 frame;       /* in */
+	__u32 ctx;         /* in */
+	__u32 _pad;
 };
 
 struct drm_lima_wait_fence {
 	__u32 pipe;        /* in */
 	__u32 fence;       /* in */
 	__u64 timeout_ns;  /* in */
+	__u32 ctx;         /* in */
+	__u32 _pad;
 };
 
 #define LIMA_GEM_WAIT_READ   0x01
@@ -155,6 +159,14 @@ struct drm_lima_gem_wait {
 	__u64 timeout_ns;  /* in */
 };
 
+#define LIMA_CTX_OP_CREATE 1
+#define LIMA_CTX_OP_FREE   2
+
+struct drm_lima_ctx {
+	__u32 op;          /* in */
+	__u32 id;          /* in/out */
+};
+
 #define DRM_LIMA_INFO        0x00
 #define DRM_LIMA_GEM_CREATE  0x01
 #define DRM_LIMA_GEM_INFO    0x02
@@ -162,6 +174,7 @@ struct drm_lima_gem_wait {
 #define DRM_LIMA_GEM_SUBMIT  0x04
 #define DRM_LIMA_WAIT_FENCE  0x05
 #define DRM_LIMA_GEM_WAIT    0x06
+#define DRM_LIMA_CTX         0x07
 
 #define DRM_IOCTL_LIMA_INFO DRM_IOR(DRM_COMMAND_BASE + DRM_LIMA_INFO, struct drm_lima_info)
 #define DRM_IOCTL_LIMA_GEM_CREATE DRM_IOWR(DRM_COMMAND_BASE + DRM_LIMA_GEM_CREATE, struct drm_lima_gem_create)
@@ -170,6 +183,7 @@ struct drm_lima_gem_wait {
 #define DRM_IOCTL_LIMA_GEM_SUBMIT DRM_IOWR(DRM_COMMAND_BASE + DRM_LIMA_GEM_SUBMIT, struct drm_lima_gem_submit)
 #define DRM_IOCTL_LIMA_WAIT_FENCE DRM_IOW(DRM_COMMAND_BASE + DRM_LIMA_WAIT_FENCE, struct drm_lima_wait_fence)
 #define DRM_IOCTL_LIMA_GEM_WAIT DRM_IOW(DRM_COMMAND_BASE + DRM_LIMA_GEM_WAIT, struct drm_lima_gem_wait)
+#define DRM_IOCTL_LIMA_CTX DRM_IOWR(DRM_COMMAND_BASE + DRM_LIMA_CTX, struct drm_lima_ctx)
 
 #if defined(__cplusplus)
 }
-- 
2.0.1

