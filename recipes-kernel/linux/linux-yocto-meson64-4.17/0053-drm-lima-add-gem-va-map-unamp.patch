From a6ec886a4f80416ed54ee102fed3b8c7c9852dc4 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 22 Apr 2017 09:38:59 +0800
Subject: [PATCH 053/134] drm/lima: add gem va map/unamp

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 drivers/gpu/drm/lima/Kconfig       |   1 +
 drivers/gpu/drm/lima/Makefile      |   3 +-
 drivers/gpu/drm/lima/lima.h        |  10 ++-
 drivers/gpu/drm/lima/lima_device.c |  13 +--
 drivers/gpu/drm/lima/lima_drv.c    |  46 ++++++++++
 drivers/gpu/drm/lima/lima_gem.c    | 119 ++++++++++++++++++++++++
 drivers/gpu/drm/lima/lima_mmu.c    |  28 +-----
 drivers/gpu/drm/lima/lima_vm.c     | 180 +++++++++++++++++++++++++++++++++++++
 drivers/gpu/drm/lima/lima_vm.h     |  52 +++++++++++
 include/uapi/drm/lima_drm.h        |  12 +++
 10 files changed, 424 insertions(+), 40 deletions(-)
 create mode 100644 drivers/gpu/drm/lima/lima_vm.c
 create mode 100644 drivers/gpu/drm/lima/lima_vm.h

diff --git a/drivers/gpu/drm/lima/Kconfig b/drivers/gpu/drm/lima/Kconfig
index 1f746b5..f238362 100644
--- a/drivers/gpu/drm/lima/Kconfig
+++ b/drivers/gpu/drm/lima/Kconfig
@@ -3,5 +3,6 @@ config DRM_LIMA
        tristate "LIMA (DRM support for ARM Mali 400 GPU)"
        depends on DRM
        depends on ARCH_SUNXI
+       select INTERVAL_TREE
        help
          DRM driver for ARM Mali 400 GPUs.
diff --git a/drivers/gpu/drm/lima/Makefile b/drivers/gpu/drm/lima/Makefile
index 7ee2a3d..9297a77 100644
--- a/drivers/gpu/drm/lima/Makefile
+++ b/drivers/gpu/drm/lima/Makefile
@@ -6,6 +6,7 @@ lima-y := \
 	lima_mmu.o \
 	lima_gp.o \
 	lima_pp.o \
-	lima_gem.o
+	lima_gem.o \
+	lima_vm.o
 
 obj-$(CONFIG_DRM_LIMA) += lima.o
diff --git a/drivers/gpu/drm/lima/lima.h b/drivers/gpu/drm/lima/lima.h
index 285c6a9..f7a24c3 100644
--- a/drivers/gpu/drm/lima/lima.h
+++ b/drivers/gpu/drm/lima/lima.h
@@ -22,6 +22,7 @@
 #ifndef __LIMA_H__
 
 #include <drm/drmP.h>
+#include "lima_vm.h"
 
 enum lima_gpu_type {
 	GPU_MALI400 = 0,
@@ -85,8 +86,11 @@ struct lima_device {
 	struct lima_pp *pp[LIMA_MAX_PP];
 	int num_pp;
 
-	void *empty_mmu_pda;
-	dma_addr_t empty_mmu_pda_dma;
+	struct lima_vm empty_vm;
+};
+
+struct lima_drm_priv {
+	struct lima_vm vm;
 };
 
 int lima_device_init(struct lima_device *ldev, struct drm_device *dev);
@@ -112,5 +116,7 @@ int lima_gem_create_handle(struct drm_device *dev, struct drm_file *file,
 void lima_gem_free_object(struct drm_gem_object *obj);
 int lima_gem_mmap_offset(struct drm_file *file, u32 handle, u64 *offset);
 int lima_gem_mmap(struct file *filp, struct vm_area_struct *vma);
+int lima_gem_va_map(struct drm_file *file, u32 handle, u32 flags, u32 va);
+int lima_gem_va_unmap(struct drm_file *file, u32 handle, u32 va);
 
 #endif
diff --git a/drivers/gpu/drm/lima/lima_device.c b/drivers/gpu/drm/lima/lima_device.c
index 80d1fce..a6be0d7 100644
--- a/drivers/gpu/drm/lima/lima_device.c
+++ b/drivers/gpu/drm/lima/lima_device.c
@@ -121,13 +121,9 @@ int lima_device_init(struct lima_device *ldev, struct drm_device *dev)
 		return err;
 	}
 
-	ldev->empty_mmu_pda = dma_alloc_wc(ldev->dev, PAGE_SIZE,
-					   &ldev->empty_mmu_pda_dma, GFP_KERNEL);
-	if (!ldev->empty_mmu_pda) {
-		err = -ENOMEM;
+	err = lima_vm_init(&ldev->empty_vm, ldev->dev, true);
+	if (err)
 		goto err_out;
-	}
-	memset(ldev->empty_mmu_pda, 0, PAGE_SIZE);
 
 	ldev->pmu = kzalloc(sizeof(*ldev->pmu), GFP_KERNEL);
 	if (!ldev->pmu) {
@@ -247,10 +243,7 @@ void lima_device_fini(struct lima_device *ldev)
 		kfree(ldev->pmu);
 	}
 
-	if (ldev->empty_mmu_pda) {
-		dma_free_wc(ldev->dev, PAGE_SIZE, ldev->empty_mmu_pda,
-			    ldev->empty_mmu_pda_dma);
-	}
+	lima_vm_fini(&ldev->empty_vm);
 
 	lima_clk_fini(ldev);
 }
diff --git a/drivers/gpu/drm/lima/lima_drv.c b/drivers/gpu/drm/lima/lima_drv.c
index 5b2a76c..38071912 100644
--- a/drivers/gpu/drm/lima/lima_drv.c
+++ b/drivers/gpu/drm/lima/lima_drv.c
@@ -42,6 +42,20 @@ static int lima_ioctl_gem_info(struct drm_device *dev, void *data, struct drm_fi
 	return lima_gem_mmap_offset(file, args->handle, &args->offset);
 }
 
+static int lima_ioctl_gem_va(struct drm_device *dev, void *data, struct drm_file *file)
+{
+	struct drm_lima_gem_va *args = data;
+
+	switch (args->op) {
+	case LIMA_VA_OP_MAP:
+		return lima_gem_va_map(file, args->handle, args->flags, args->va);
+	case LIMA_VA_OP_UNMAP:
+		return lima_gem_va_unmap(file, args->handle, args->va);
+	default:
+		return -EINVAL;
+	}
+}
+
 static int lima_drm_driver_load(struct drm_device *dev, unsigned long flags)
 {
 	struct lima_device *ldev;
@@ -78,10 +92,40 @@ static int lima_drm_driver_unload(struct drm_device *dev)
 	return 0;
 }
 
+static int lima_drm_driver_open(struct drm_device *dev, struct drm_file *file)
+{
+	int err;
+	struct lima_drm_priv *priv;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	err = lima_vm_init(&priv->vm, dev->dev, false);
+	if (err)
+		goto err_out0;
+
+	file->driver_priv = priv;
+	return 0;
+
+err_out0:
+	kfree(priv);
+	return err;
+}
+
+static void lima_drm_driver_preclose(struct drm_device *dev, struct drm_file *file)
+{
+	struct lima_drm_priv *priv = file->driver_priv;
+
+	lima_vm_fini(&priv->vm);
+	kfree(priv);
+}
+
 static const struct drm_ioctl_desc lima_drm_driver_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(LIMA_INFO, lima_ioctl_info, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(LIMA_GEM_CREATE, lima_ioctl_gem_create, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(LIMA_GEM_INFO, lima_ioctl_gem_info, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(LIMA_GEM_VA, lima_ioctl_gem_va, DRM_AUTH|DRM_RENDER_ALLOW),
 };
 
 extern const struct vm_operations_struct lima_gem_vm_ops;
@@ -101,6 +145,8 @@ static struct drm_driver lima_drm_driver = {
 	.driver_features    = DRIVER_RENDER | DRIVER_GEM,
 	.load		    = lima_drm_driver_load,
 	.unload             = lima_drm_driver_unload,
+	.open               = lima_drm_driver_open,
+	.preclose           = lima_drm_driver_preclose,
 	.ioctls             = lima_drm_driver_ioctls,
 	.num_ioctls         = ARRAY_SIZE(lima_drm_driver_ioctls),
 	.fops               = &lima_drm_driver_fops,
diff --git a/drivers/gpu/drm/lima/lima_gem.c b/drivers/gpu/drm/lima/lima_gem.c
index b4dac67..6dc2c852 100644
--- a/drivers/gpu/drm/lima/lima_gem.c
+++ b/drivers/gpu/drm/lima/lima_gem.c
@@ -2,11 +2,22 @@
 #include <drm/drm_gem.h>
 #include <linux/dma-mapping.h>
 
+#include "lima.h"
+
+
+struct lima_bo_va {
+	struct list_head list;
+	struct lima_vm *vm;
+	u32 va;
+};
 
 struct lima_bo {
 	struct drm_gem_object gem;
 	dma_addr_t dma_addr;
 	void *cpu_addr;
+
+	struct mutex lock;
+	struct list_head va;
 };
 
 static inline
@@ -15,6 +26,12 @@ struct lima_bo *to_lima_bo(struct drm_gem_object *obj)
 	return container_of(obj, struct lima_bo, gem);
 }
 
+static inline
+struct lima_drm_priv *to_lima_drm_priv(struct drm_file *file)
+{
+	return file->driver_priv;
+}
+
 static struct lima_bo *lima_gem_create_bo(struct drm_device *dev, u32 size, u32 flags)
 {
 	int err;
@@ -26,6 +43,9 @@ static struct lima_bo *lima_gem_create_bo(struct drm_device *dev, u32 size, u32
 	if (!bo)
 		return ERR_PTR(-ENOMEM);
 
+	mutex_init(&bo->lock);
+	INIT_LIST_HEAD(&bo->va);
+
 	err = drm_gem_object_init(dev, &bo->gem, size);
 	if (err)
 		goto err_out0;
@@ -66,6 +86,13 @@ int lima_gem_create_handle(struct drm_device *dev, struct drm_file *file,
 void lima_gem_free_object(struct drm_gem_object *obj)
 {
 	struct lima_bo *bo = to_lima_bo(obj);
+	struct lima_bo_va *bo_va, *tmp;
+
+	list_for_each_entry_safe(bo_va, tmp, &bo->va, list) {
+		lima_vm_unmap(bo_va->vm, bo_va->va, obj->size);
+		list_del(&bo_va->list);
+		kfree(bo_va);
+	}
 
 	dma_free_coherent(obj->dev->dev, obj->size, bo->cpu_addr, bo->dma_addr);
 	drm_gem_object_release(obj);
@@ -124,3 +151,95 @@ const struct vm_operations_struct lima_gem_vm_ops = {
 	.open = drm_gem_vm_open,
 	.close = drm_gem_vm_close,
 };
+
+int lima_gem_va_map(struct drm_file *file, u32 handle, u32 flags, u32 va)
+{
+	struct lima_drm_priv *priv = to_lima_drm_priv(file);
+	struct drm_gem_object *obj;
+	struct lima_bo *bo;
+	int err;
+	struct lima_bo_va *bo_va;
+
+	if (!PAGE_ALIGNED(va))
+		return -EINVAL;
+
+	obj = drm_gem_object_lookup(file, handle);
+	if (!obj)
+		return -ENOENT;
+
+	bo = to_lima_bo(obj);
+
+	/* overflow */
+	if (va + obj->size < va) {
+		err = -EINVAL;
+		goto err_out0;
+	}
+
+	err = lima_vm_map(&priv->vm, bo->dma_addr, va, obj->size);
+	if (err)
+		goto err_out0;
+
+	bo_va = kmalloc(sizeof(*bo_va), GFP_KERNEL);
+	if (!bo_va) {
+		err = -ENOMEM;
+		goto err_out1;
+	}
+	INIT_LIST_HEAD(&bo_va->list);
+	bo_va->vm = &priv->vm;
+	bo_va->va = va;
+
+	mutex_lock(&bo->lock);
+
+	list_add(&bo_va->list, &bo->va);
+
+	mutex_unlock(&bo->lock);
+
+	drm_gem_object_unreference_unlocked(obj);
+	return 0;
+
+err_out1:
+	lima_vm_unmap(&priv->vm, va, obj->size);
+err_out0:
+	drm_gem_object_unreference_unlocked(obj);
+	return err;
+}
+
+int lima_gem_va_unmap(struct drm_file *file, u32 handle, u32 va)
+{
+	struct lima_drm_priv *priv = to_lima_drm_priv(file);
+	struct drm_gem_object *obj;
+	struct lima_bo *bo;
+	int err = 0;
+	struct lima_bo_va *bo_va, *tmp;
+	bool found = false;
+
+	obj = drm_gem_object_lookup(file, handle);
+	if (!obj)
+		return -ENOENT;
+
+	bo = to_lima_bo(obj);
+
+	mutex_lock(&bo->lock);
+
+	list_for_each_entry_safe(bo_va, tmp, &bo->va, list) {
+		if (bo_va->vm == &priv->vm && bo_va->va == va) {
+			list_del(&bo_va->list);
+			kfree(bo_va);
+			found = true;
+			break;
+		}
+	}
+
+	mutex_unlock(&bo->lock);
+
+	if (!found) {
+		err = -ENOENT;
+		goto out;
+	}
+
+	err = lima_vm_unmap(&priv->vm, va, obj->size);
+
+out:
+	drm_gem_object_unreference_unlocked(obj);
+	return err;
+}
diff --git a/drivers/gpu/drm/lima/lima_mmu.c b/drivers/gpu/drm/lima/lima_mmu.c
index 12e2c04..56915ba 100644
--- a/drivers/gpu/drm/lima/lima_mmu.c
+++ b/drivers/gpu/drm/lima/lima_mmu.c
@@ -28,32 +28,6 @@
 #define   LIMA_MMU_INT_READ_BUS_ERROR       0x02
 #define LIMA_MMU_INT_STATUS		  0x0020
 
-#define LIMA_MMU_FLAG_PRESENT          (1 << 0)
-#define LIMA_MMU_FLAG_READ_PERMISSION  (1 << 1)
-#define LIMA_MMU_FLAG_WRITE_PERMISSION (1 << 2)
-#define LIMA_MMU_FLAG_OVERRIDE_CACHE   (1 << 3)
-#define LIMA_MMU_FLAG_WRITE_CACHEABLE  (1 << 4)
-#define LIMA_MMU_FLAG_WRITE_ALLOCATE   (1 << 5)
-#define LIMA_MMU_FLAG_WRITE_BUFFERABLE (1 << 6)
-#define LIMA_MMU_FLAG_READ_CACHEABLE   (1 << 7)
-#define LIMA_MMU_FLAG_READ_ALLOCATE    (1 << 8)
-#define LIMA_MMU_FLAG_MASK             0x1FF
-
-#define LIMA_MMU_FLAGS_FORCE_GP_READ_ALLOCATE (	 \
-		LIMA_MMU_FLAG_PRESENT |		 \
-		LIMA_MMU_FLAG_READ_PERMISSION |  \
-		LIMA_MMU_FLAG_WRITE_PERMISSION | \
-		LIMA_MMU_FLAG_OVERRIDE_CACHE |	 \
-		LIMA_MMU_FLAG_WRITE_CACHEABLE |  \
-		LIMA_MMU_FLAG_WRITE_BUFFERABLE | \
-		LIMA_MMU_FLAG_READ_CACHEABLE |	 \
-		LIMA_MMU_FLAG_READ_ALLOCATE )
-
-#define LIMA_MMU_FLAGS_DEFAULT (			   \
-		LIMA_MMU_FLAG_PRESENT |			   \
-		LIMA_MMU_FLAG_READ_PERMISSION |		   \
-		LIMA_MMU_FLAG_WRITE_PERMISSION )
-
 #define mmu_write(reg, data) writel(data, mmu->ip.iomem + LIMA_MMU_##reg)
 #define mmu_read(reg) readl(mmu->ip.iomem + LIMA_MMU_##reg)
 
@@ -96,7 +70,7 @@ int lima_mmu_init(struct lima_mmu *mmu)
 	}
 
 	mmu_write(INT_MASK, LIMA_MMU_INT_PAGE_FAULT | LIMA_MMU_INT_READ_BUS_ERROR);
-	mmu_write(DTE_ADDR, dev->empty_mmu_pda_dma);
+	mmu_write(DTE_ADDR, dev->empty_vm.pd.dma);
 	mmu_write(COMMAND, LIMA_MMU_COMMAND_ENABLE_PAGING);
 	for (timeout = 1000; timeout > 0; timeout--) {
 		if (mmu_read(STATUS) & LIMA_MMU_STATUS_PAGING_ENABLED)
diff --git a/drivers/gpu/drm/lima/lima_vm.c b/drivers/gpu/drm/lima/lima_vm.c
new file mode 100644
index 0000000..ccd44c9
--- /dev/null
+++ b/drivers/gpu/drm/lima/lima_vm.c
@@ -0,0 +1,180 @@
+#include <drm/drmP.h>
+#include <linux/interval_tree.h>
+#include <linux/dma-mapping.h>
+
+#include "lima_vm.h"
+
+#define LIMA_PAGE_SIZE    4096
+#define LIMA_PAGE_ENT_NUM (LIMA_PAGE_SIZE / sizeof(u32))
+
+#define LIMA_PDE(va) (va >> 22)
+#define LIMA_PTE(va) ((va << 10) >> 22)
+
+#define LIMA_VM_FLAG_PRESENT          (1 << 0)
+#define LIMA_VM_FLAG_READ_PERMISSION  (1 << 1)
+#define LIMA_VM_FLAG_WRITE_PERMISSION (1 << 2)
+#define LIMA_VM_FLAG_OVERRIDE_CACHE   (1 << 3)
+#define LIMA_VM_FLAG_WRITE_CACHEABLE  (1 << 4)
+#define LIMA_VM_FLAG_WRITE_ALLOCATE   (1 << 5)
+#define LIMA_VM_FLAG_WRITE_BUFFERABLE (1 << 6)
+#define LIMA_VM_FLAG_READ_CACHEABLE   (1 << 7)
+#define LIMA_VM_FLAG_READ_ALLOCATE    (1 << 8)
+#define LIMA_VM_FLAG_MASK             0x1FF
+
+#define LIMA_VM_FLAGS_CACHE (			 \
+		LIMA_VM_FLAG_PRESENT |		 \
+		LIMA_VM_FLAG_READ_PERMISSION |	 \
+		LIMA_VM_FLAG_WRITE_PERMISSION |	 \
+		LIMA_VM_FLAG_OVERRIDE_CACHE |	 \
+		LIMA_VM_FLAG_WRITE_CACHEABLE |	 \
+		LIMA_VM_FLAG_WRITE_BUFFERABLE |	 \
+		LIMA_VM_FLAG_READ_CACHEABLE |	 \
+		LIMA_VM_FLAG_READ_ALLOCATE )
+
+#define LIMA_VM_FLAGS_UNCACHE (			\
+		LIMA_VM_FLAG_PRESENT |		\
+		LIMA_VM_FLAG_READ_PERMISSION |	\
+		LIMA_VM_FLAG_WRITE_PERMISSION )
+
+
+int lima_vm_map(struct lima_vm *vm, dma_addr_t dma, u32 va, u32 size)
+{
+	int err;
+	struct interval_tree_node *it;
+	u32 addr, faddr;
+
+	mutex_lock(&vm->lock);
+
+	it = interval_tree_iter_first(&vm->va, va, va + size - 1);
+	if (it) {
+		dev_err(vm->dev, "lima vm map va overlap %x-%x %lx-%lx\n",
+			va, va + size -1, it->start, it->last);
+		err = -EINVAL;
+		goto err_out0;
+	}
+
+	it = kmalloc(sizeof(*it), GFP_KERNEL);
+	if (!it) {
+		err = -ENOMEM;
+		goto err_out0;
+	}
+
+	it->start = va;
+	it->last = va + size - 1;
+	interval_tree_insert(it, &vm->va);
+
+	for (addr = va; addr < va + size; addr += LIMA_PAGE_SIZE, dma += LIMA_PAGE_SIZE) {
+		u32 pde = LIMA_PDE(addr);
+		u32 pte = LIMA_PTE(addr);
+
+		if (!vm->pts[pde].cpu) {
+			vm->pts[pde].cpu = dma_alloc_coherent(
+				vm->dev, LIMA_PAGE_SIZE,
+				&vm->pts[pde].dma, GFP_KERNEL);
+			if (!vm->pts[pde].cpu) {
+				err = -ENOMEM;
+				goto err_out1;
+			}
+			memset(vm->pts[pde].cpu, 0, LIMA_PAGE_SIZE);
+		}
+
+		vm->pd.cpu[pde] = vm->pts[pde].dma | LIMA_VM_FLAG_PRESENT;
+		vm->pts[pde].cpu[pte] = dma | LIMA_VM_FLAGS_CACHE;
+	}
+
+	mutex_unlock(&vm->lock);
+	return 0;
+
+err_out1:
+	for (faddr = va; faddr < addr; faddr += LIMA_PAGE_SIZE) {
+		u32 pde = LIMA_PDE(faddr);
+		u32 pte = LIMA_PTE(faddr);
+		vm->pts[pde].cpu[pte] = 0;
+	}
+	interval_tree_remove(it, &vm->va);
+	kfree(it);
+err_out0:
+	mutex_unlock(&vm->lock);
+	return err;
+}
+
+int lima_vm_unmap(struct lima_vm *vm, u32 va, u32 size)
+{
+	int err = 0;
+	struct interval_tree_node *it;
+	u32 addr;
+
+	mutex_lock(&vm->lock);
+
+	it = interval_tree_iter_first(&vm->va, va, va + size - 1);
+	if (it) {
+		if (it->start != va || it->last != va + size - 1) {
+			dev_err(vm->dev, "lima vm unmap va not match %x-%x %lx-%lx\n",
+				va, va + size -1, it->start, it->last);
+			err = -EINVAL;
+			goto out;
+		}
+		interval_tree_remove(it, &vm->va);
+		kfree(it);
+	}
+	else
+		goto out;
+
+	for (addr = va; addr < va + size; addr += LIMA_PAGE_SIZE) {
+		u32 pde = LIMA_PDE(addr);
+		u32 pte = LIMA_PTE(addr);
+		vm->pts[pde].cpu[pte] = 0;
+	}
+
+out:
+	mutex_unlock(&vm->lock);
+	return err;
+}
+
+int lima_vm_init(struct lima_vm *vm, struct device *dev, bool empty)
+{
+	int err;
+
+	vm->dev = dev;
+	vm->va = RB_ROOT;
+	mutex_init(&vm->lock);
+
+	vm->pd.cpu = dma_alloc_coherent(dev, LIMA_PAGE_SIZE, &vm->pd.dma, GFP_KERNEL);
+	if (!vm->pd.cpu)
+		return -ENOMEM;
+	memset(vm->pd.cpu, 0, LIMA_PAGE_SIZE);
+
+	if (!empty) {
+		vm->pts = drm_calloc_large(LIMA_PAGE_ENT_NUM, sizeof(vm->pts[0]));
+		if (!vm->pts) {
+			err = -ENOMEM;
+			goto err_out;
+		}
+	}
+
+	return 0;
+
+err_out:
+	dma_free_coherent(dev, LIMA_PAGE_SIZE, vm->pd.cpu, vm->pd.dma);
+	return err;
+}
+
+void lima_vm_fini(struct lima_vm *vm)
+{
+	struct interval_tree_node *it, *tmp;
+
+	if (!RB_EMPTY_ROOT(&vm->va)) {
+		dev_err(vm->dev, "still active bo inside vm\n");
+	}
+
+	rbtree_postorder_for_each_entry_safe(it, tmp, &vm->va, rb) {
+		interval_tree_remove(it, &vm->va);
+		kfree(it);
+	}
+
+	if (vm->pts)
+		drm_free_large(vm->pts);
+
+	if (vm->pd.cpu)
+		dma_free_coherent(vm->dev, LIMA_PAGE_SIZE, vm->pd.cpu, vm->pd.dma);
+}
diff --git a/drivers/gpu/drm/lima/lima_vm.h b/drivers/gpu/drm/lima/lima_vm.h
new file mode 100644
index 0000000..4e0fde1
--- /dev/null
+++ b/drivers/gpu/drm/lima/lima_vm.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2017 Lima Project
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef __LIMA_VM_H__
+#define __LIMA_VM_H__
+
+#include <linux/mutex.h>
+#include <linux/rbtree.h>
+
+
+struct lima_vm_page {
+	u32 *cpu;
+	dma_addr_t dma;
+};
+
+struct lima_vm {
+	struct mutex lock;
+
+	struct device *dev;
+
+	/* tree of virtual addresses mapped */
+	struct rb_root va;
+
+        struct lima_vm_page pd;
+	struct lima_vm_page *pts;
+};
+
+int lima_vm_init(struct lima_vm *vm, struct device *dev, bool empty);
+void lima_vm_fini(struct lima_vm *vm);
+
+int lima_vm_map(struct lima_vm *vm, dma_addr_t dma, u32 va, u32 size);
+int lima_vm_unmap(struct lima_vm *vm, u32 va, u32 size);
+
+#endif
diff --git a/include/uapi/drm/lima_drm.h b/include/uapi/drm/lima_drm.h
index 484cedf..ff382ae 100644
--- a/include/uapi/drm/lima_drm.h
+++ b/include/uapi/drm/lima_drm.h
@@ -48,13 +48,25 @@ struct drm_lima_gem_info {
 	__u64 offset;  /* out */
 };
 
+#define LIMA_VA_OP_MAP    1
+#define LIMA_VA_OP_UNMAP  2
+
+struct drm_lima_gem_va {
+	__u32 handle;  /* in */
+	__u32 op;      /* in */
+	__u32 flags;   /* in */
+	__u32 va;      /* in */
+};
+
 #define DRM_LIMA_INFO        0x00
 #define DRM_LIMA_GEM_CREATE  0x01
 #define DRM_LIMA_GEM_INFO    0x02
+#define DRM_LIMA_GEM_VA      0x03
 
 #define DRM_IOCTL_LIMA_INFO DRM_IOR(DRM_COMMAND_BASE + DRM_LIMA_INFO, struct drm_lima_info)
 #define DRM_IOCTL_LIMA_GEM_CREATE DRM_IOWR(DRM_COMMAND_BASE + DRM_LIMA_GEM_CREATE, struct drm_lima_gem_create)
 #define DRM_IOCTL_LIMA_GEM_INFO DRM_IOWR(DRM_COMMAND_BASE + DRM_LIMA_GEM_INFO, struct drm_lima_gem_info)
+#define DRM_IOCTL_LIMA_GEM_VA DRM_IOW(DRM_COMMAND_BASE + DRM_LIMA_GEM_VA, struct drm_lima_gem_va)
 
 #if defined(__cplusplus)
 }
-- 
2.0.1

