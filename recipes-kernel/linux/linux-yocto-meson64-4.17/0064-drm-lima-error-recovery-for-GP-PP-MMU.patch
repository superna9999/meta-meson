From ae9f066a17a374a0ceee7272a568b2d4140d09f7 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 31 May 2017 10:40:30 +0800
Subject: [PATCH 064/134] drm/lima: error recovery for GP/PP/MMU

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 drivers/gpu/drm/lima/lima.h        |  2 +
 drivers/gpu/drm/lima/lima_device.c |  3 ++
 drivers/gpu/drm/lima/lima_gp.c     | 89 +++++++++++++++++++++++++++++---------
 drivers/gpu/drm/lima/lima_mmu.c    | 28 +++++++++++-
 drivers/gpu/drm/lima/lima_pp.c     | 61 ++++++++++++++++++++++----
 drivers/gpu/drm/lima/lima_sched.c  |  9 +++-
 drivers/gpu/drm/lima/lima_sched.h  |  2 +-
 7 files changed, 160 insertions(+), 34 deletions(-)

diff --git a/drivers/gpu/drm/lima/lima.h b/drivers/gpu/drm/lima/lima.h
index bdd3942..262fd4e 100644
--- a/drivers/gpu/drm/lima/lima.h
+++ b/drivers/gpu/drm/lima/lima.h
@@ -52,6 +52,7 @@ struct lima_l2_cache {
 
 struct lima_mmu {
 	struct lima_ip ip;
+	struct lima_sched_pipe *pipe;
 
 	spinlock_t lock;
 	struct lima_vm *vm;
@@ -125,6 +126,7 @@ int lima_mmu_init(struct lima_mmu *mmu);
 void lima_mmu_fini(struct lima_mmu *mmu);
 void lima_mmu_switch_vm(struct lima_mmu *mmu, struct lima_vm *vm, bool reset);
 void lima_mmu_zap_vm(struct lima_mmu *mmu, struct lima_vm *vm, u32 va, u32 size);
+void lima_mmu_page_fault_resume(struct lima_mmu *mmu);
 
 int lima_gp_init(struct lima_gp *gp);
 void lima_gp_fini(struct lima_gp *gp);
diff --git a/drivers/gpu/drm/lima/lima_device.c b/drivers/gpu/drm/lima/lima_device.c
index a61c35d..5aad2ba 100644
--- a/drivers/gpu/drm/lima/lima_device.c
+++ b/drivers/gpu/drm/lima/lima_device.c
@@ -110,6 +110,7 @@ static int lima_gp_group_init(struct lima_device *dev)
 		goto err_out2;
 
 	dev->pipe[LIMA_PIPE_GP] = &gp->pipe;
+	gp->mmu.pipe = &gp->pipe;
 	dev->gp = gp;
 	return 0;
 
@@ -164,6 +165,8 @@ static int lima_pp_group_init(struct lima_device *dev, int n)
 		return err;
 
 	dev->pipe[LIMA_PIPE_PP] = &pp->pipe;
+	for (i = 0; i < pp->num_core; i++)
+		pp->core[i].mmu.pipe = &pp->pipe;
 	lima_pp_init(pp);
 	return 0;
 }
diff --git a/drivers/gpu/drm/lima/lima_gp.c b/drivers/gpu/drm/lima/lima_gp.c
index 01ae4d3..a736636 100644
--- a/drivers/gpu/drm/lima/lima_gp.c
+++ b/drivers/gpu/drm/lima/lima_gp.c
@@ -78,10 +78,8 @@
 	 LIMA_GP_IRQ_SEMAPHORE_OVERFLOW  | \
 	 LIMA_GP_IRQ_PTR_ARRAY_OUT_OF_BOUNDS)
 
-#define LIMA_GP_IRQ_MASK_USED		   \
-	(				   \
-	 LIMA_GP_IRQ_VS_END_CMD_LST      | \
-	 LIMA_GP_IRQ_PLBU_END_CMD_LST    | \
+#define LIMA_GP_IRQ_MASK_ERROR             \
+	(                                  \
 	 LIMA_GP_IRQ_PLBU_OUT_OF_MEM     | \
 	 LIMA_GP_IRQ_FORCE_HANG          | \
 	 LIMA_GP_IRQ_WRITE_BOUND_ERR     | \
@@ -93,6 +91,13 @@
 	 LIMA_GP_IRQ_SEMAPHORE_OVERFLOW  | \
 	 LIMA_GP_IRQ_PTR_ARRAY_OUT_OF_BOUNDS)
 
+#define LIMA_GP_IRQ_MASK_USED		   \
+	(				   \
+	 LIMA_GP_IRQ_VS_END_CMD_LST      | \
+	 LIMA_GP_IRQ_PLBU_END_CMD_LST    | \
+	 LIMA_GP_IRQ_MASK_ERROR)
+
+
 #define gp_write(reg, data) writel(data, gp->ip.iomem + LIMA_GP_##reg)
 #define gp_read(reg) readl(gp->ip.iomem + LIMA_GP_##reg)
 
@@ -101,23 +106,29 @@ static irqreturn_t lima_gp_irq_handler(int irq, void *data)
 	struct lima_gp *gp = data;
 	struct lima_device *dev = gp->ip.dev;
 	u32 state = gp_read(INT_STAT);
-	u32 status = gp_read(STATUS);
-	bool task_done = false;
-
-	dev_info_ratelimited(dev->dev, "gp irq state=%x status=%x\n", state, status);
 
-	if (state & LIMA_GP_IRQ_VS_END_CMD_LST) {
-		gp->task &= ~LIMA_GP_TASK_VS;
-		task_done = true;
+	if (state & LIMA_GP_IRQ_MASK_ERROR) {
+		u32 status = gp_read(STATUS);
+		dev_info(dev->dev, "gp error irq state=%x status=%x\n",
+			 state, status);
+		lima_sched_pipe_task_done(&gp->pipe, true);
 	}
+	else {
+		bool task_done = false;
 
-	if (state & LIMA_GP_IRQ_PLBU_END_CMD_LST) {
-		gp->task &= ~LIMA_GP_TASK_PLBU;
-		task_done = true;
-	}
+		if (state & LIMA_GP_IRQ_VS_END_CMD_LST) {
+			gp->task &= ~LIMA_GP_TASK_VS;
+			task_done = true;
+		}
+
+		if (state & LIMA_GP_IRQ_PLBU_END_CMD_LST) {
+			gp->task &= ~LIMA_GP_TASK_PLBU;
+			task_done = true;
+		}
 
-	if (task_done && !gp->task)
-		lima_sched_pipe_task_done(&gp->pipe);
+		if (task_done && !gp->task)
+			lima_sched_pipe_task_done(&gp->pipe, false);
+	}
 
 	gp_write(INT_CLEAR, state);
 	return IRQ_NONE;
@@ -164,9 +175,8 @@ static int lima_gp_start_task(void *data, struct lima_sched_task *task)
 	return 0;
 }
 
-static int lima_gp_reset(void *data)
+static int lima_gp_soft_reset(struct lima_gp *gp)
 {
-	struct lima_gp *gp = data;
 	struct lima_device *dev = gp->ip.dev;
 	int timeout;
 
@@ -187,12 +197,51 @@ static int lima_gp_reset(void *data)
 	return 0;
 }
 
+static int lima_gp_hard_reset(struct lima_gp *gp)
+{
+	struct lima_device *dev = gp->ip.dev;
+	int timeout;
+
+	gp_write(CMD, LIMA_GP_CMD_STOP_BUS);
+	for (timeout = 1000; timeout > 0; timeout--) {
+		if (gp_read(STATUS) & LIMA_GP_STATUS_BUS_STOPPED)
+			break;
+	}
+	if (!timeout) {
+		dev_err(dev->dev, "gp stop bus timeout\n");
+		return -ETIMEDOUT;
+	}
+
+	gp_write(PERF_CNT_0_LIMIT, 0xC0FFE000);
+	gp_write(INT_MASK, 0);
+	gp_write(CMD, LIMA_GP_CMD_RESET);
+	for (timeout = 1000; timeout > 0; timeout--) {
+		gp_write(PERF_CNT_0_LIMIT, 0xC01A0000);
+		if (gp_read(PERF_CNT_0_LIMIT) == 0xC01A0000)
+			break;
+	}
+	if (!timeout) {
+		dev_err(dev->dev, "gp hard reset timeout\n");
+		return -ETIMEDOUT;
+	}
+
+	gp_write(PERF_CNT_0_LIMIT, 0);
+	gp_write(INT_CLEAR, LIMA_GP_IRQ_MASK_ALL);
+	gp_write(INT_MASK, LIMA_GP_IRQ_MASK_USED);
+	return 0;
+}
+
+static int lima_gp_reset(void *data)
+{
+	return lima_gp_hard_reset(data);
+}
+
 int lima_gp_init(struct lima_gp *gp)
 {
 	struct lima_device *dev = gp->ip.dev;
 	int err;
 
-	err = lima_gp_reset(gp);
+	err = lima_gp_soft_reset(gp);
 	if (err)
 		return err;
 
diff --git a/drivers/gpu/drm/lima/lima_mmu.c b/drivers/gpu/drm/lima/lima_mmu.c
index c528493..8dd6996 100644
--- a/drivers/gpu/drm/lima/lima_mmu.c
+++ b/drivers/gpu/drm/lima/lima_mmu.c
@@ -59,14 +59,16 @@ static irqreturn_t lima_mmu_irq_handler(int irq, void *data)
 			 fault, LIMA_MMU_STATUS_BUS_ID(status),
 			 status & LIMA_MMU_STATUS_PAGE_FAULT_IS_WRITE ? "write" : "read",
 			 mmu->ip.name);
-		lima_vm_print(mmu->vm);
+		//lima_vm_print(mmu->vm);
 	}
 
 	if (status & LIMA_MMU_INT_READ_BUS_ERROR) {
 		dev_info(dev->dev, "mmu %s irq bus error\n", mmu->ip.name);
 	}
 
-	mmu_write(INT_CLEAR, LIMA_MMU_INT_PAGE_FAULT|LIMA_MMU_INT_READ_BUS_ERROR);
+	lima_sched_pipe_task_done(mmu->pipe, true);
+
+	mmu_write(INT_CLEAR, status);
 	return IRQ_NONE;
 }
 
@@ -157,3 +159,25 @@ void lima_mmu_zap_vm(struct lima_mmu *mmu, struct lima_vm *vm, u32 va, u32 size)
 	        mmu->zap_all = true;
 	spin_unlock(&mmu->lock);
 }
+
+void lima_mmu_page_fault_resume(struct lima_mmu *mmu)
+{
+	struct lima_device *dev = mmu->ip.dev;
+	u32 status = mmu_read(STATUS);
+
+	if (status & LIMA_MMU_STATUS_PAGE_FAULT_ACTIVE) {
+		dev_info(dev->dev, "mmu resume\n");
+
+	        spin_lock(&mmu->lock);
+		mmu->vm = dev->empty_vm;
+		spin_unlock(&mmu->lock);
+
+		mmu_write(INT_MASK, 0);
+		mmu_write(DTE_ADDR, 0xCAFEBABE);
+		lima_mmu_send_command(LIMA_MMU_COMMAND_HARD_RESET, mmu_read(DTE_ADDR) == 0);
+	        mmu_write(INT_MASK, LIMA_MMU_INT_PAGE_FAULT | LIMA_MMU_INT_READ_BUS_ERROR);
+		mmu_write(DTE_ADDR, dev->empty_vm->pd.dma);
+		lima_mmu_send_command(LIMA_MMU_COMMAND_ENABLE_PAGING,
+				      mmu_read(STATUS) & LIMA_MMU_STATUS_PAGING_ENABLED);
+	}
+}
diff --git a/drivers/gpu/drm/lima/lima_pp.c b/drivers/gpu/drm/lima/lima_pp.c
index fe7a8c7..683d53d 100644
--- a/drivers/gpu/drm/lima/lima_pp.c
+++ b/drivers/gpu/drm/lima/lima_pp.c
@@ -66,9 +66,8 @@
 	 LIMA_PP_IRQ_CALL_STACK_OVERFLOW   | \
 	 LIMA_PP_IRQ_RESET_COMPLETED)
 
-#define LIMA_PP_IRQ_MASK_USED                \
+#define LIMA_PP_IRQ_MASK_ERROR               \
 	(                                    \
-	 LIMA_PP_IRQ_END_OF_FRAME          | \
 	 LIMA_PP_IRQ_FORCE_HANG            | \
 	 LIMA_PP_IRQ_BUS_ERROR             | \
 	 LIMA_PP_IRQ_WRITE_BOUNDARY_ERROR  | \
@@ -76,6 +75,11 @@
 	 LIMA_PP_IRQ_CALL_STACK_UNDERFLOW  | \
 	 LIMA_PP_IRQ_CALL_STACK_OVERFLOW)
 
+#define LIMA_PP_IRQ_MASK_USED                \
+	(                                    \
+	 LIMA_PP_IRQ_END_OF_FRAME          | \
+	 LIMA_PP_IRQ_MASK_ERROR)
+
 #define pp_write(reg, data) writel(data, core->ip.iomem + LIMA_PP_##reg)
 #define pp_read(reg) readl(core->ip.iomem + LIMA_PP_##reg)
 
@@ -85,13 +89,18 @@ static irqreturn_t lima_pp_core_irq_handler(int irq, void *data)
 	struct lima_device *dev = core->ip.dev;
 	struct lima_pp *pp = dev->pp;
 	u32 state = pp_read(INT_STATUS);
-	u32 status = pp_read(STATUS);
 
-	dev_info_ratelimited(dev->dev, "pp irq state=%x status=%x\n", state, status);
-
-	if ((state & LIMA_PP_IRQ_END_OF_FRAME) &&
-	    atomic_dec_and_test(&pp->task))
-		lima_sched_pipe_task_done(&pp->pipe);
+	if (state & LIMA_PP_IRQ_MASK_ERROR) {
+		u32 status = pp_read(STATUS);
+		dev_info(dev->dev, "pp error irq state=%x status=%x\n",
+			 state, status);
+		lima_sched_pipe_task_done(&pp->pipe, true);
+	}
+	else {
+		if ((state & LIMA_PP_IRQ_END_OF_FRAME) &&
+		    atomic_dec_and_test(&pp->task))
+			lima_sched_pipe_task_done(&pp->pipe, false);
+	}
 
 	pp_write(INT_CLEAR, state);
 	return IRQ_NONE;
@@ -146,6 +155,40 @@ static int lima_pp_core_reset(struct lima_pp_core *core)
 	return 0;
 }
 
+static int lima_pp_core_hard_reset(struct lima_pp_core *core)
+{
+	struct lima_device *dev = core->ip.dev;
+	int timeout;
+/*
+	pp_write(CTRL, LIMA_PP_CTRL_STOP_BUS);
+	for (timeout = 1000; timeout > 0; timeout--) {
+		if (pp_read(STATUS) & LIMA_PP_STATUS_BUS_STOPPED)
+			break;
+	}
+	if (!timeout) {
+		dev_err(dev->dev, "pp stop bus timeout\n");
+		return -ETIMEDOUT;
+	}
+*/
+	pp_write(PERF_CNT_0_LIMIT, 0xC0FFE000);
+	pp_write(INT_MASK, 0);
+	pp_write(CTRL, LIMA_PP_CTRL_FORCE_RESET);
+	for (timeout = 1000; timeout > 0; timeout--) {
+		pp_write(PERF_CNT_0_LIMIT, 0xC01A0000);
+		if (pp_read(PERF_CNT_0_LIMIT) == 0xC01A0000)
+			break;
+	}
+	if (!timeout) {
+		dev_err(dev->dev, "pp hard reset timeout\n");
+		return -ETIMEDOUT;
+	}
+
+	pp_write(PERF_CNT_0_LIMIT, 0);
+	pp_write(INT_CLEAR, LIMA_PP_IRQ_MASK_ALL);
+	pp_write(INT_MASK, LIMA_PP_IRQ_MASK_USED);
+	return 0;
+}
+
 int lima_pp_core_init(struct lima_pp_core *core)
 {
 	struct lima_device *dev = core->ip.dev;
@@ -189,7 +232,7 @@ static int lima_pp_reset(void *data)
 	int i;
 
 	for (i = 0; i < pp->num_core; i++)
-		lima_pp_core_reset(pp->core + i);
+		lima_pp_core_hard_reset(pp->core + i);
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/lima/lima_sched.c b/drivers/gpu/drm/lima/lima_sched.c
index 7fff6f1..2d92ee2 100644
--- a/drivers/gpu/drm/lima/lima_sched.c
+++ b/drivers/gpu/drm/lima/lima_sched.c
@@ -243,8 +243,10 @@ static int lima_sched_pipe_worker(void *param)
 			if (ret == -ERESTARTSYS)
 				return 0;
 			if (ret < 0 || pipe->worker_has_error) {
-				DRM_INFO("lima worker wait task fence error %d\n", ret);
+				DRM_INFO("lima worker wait task error\n");
 				pipe->reset(pipe->data);
+				for (i = 0; i < pipe->num_mmu; i++)
+					lima_mmu_page_fault_resume(pipe->mmu[i]);
 			}
 			else
 				dma_fence_signal(task->fence);
@@ -364,8 +366,11 @@ int lima_sched_pipe_wait_fence(struct lima_sched_pipe *pipe, u32 fence, u64 time
 	return ret;
 }
 
-void lima_sched_pipe_task_done(struct lima_sched_pipe *pipe)
+void lima_sched_pipe_task_done(struct lima_sched_pipe *pipe, bool error)
 {
+	if (error)
+		pipe->worker_has_error = true;
+
 	pipe->worker_is_busy = false;
 	wake_up(&pipe->worker_busy_wait);
 }
diff --git a/drivers/gpu/drm/lima/lima_sched.h b/drivers/gpu/drm/lima/lima_sched.h
index b1c4fb4..fef66f5 100644
--- a/drivers/gpu/drm/lima/lima_sched.h
+++ b/drivers/gpu/drm/lima/lima_sched.h
@@ -71,6 +71,6 @@ int lima_sched_task_queue(struct lima_sched_pipe *pipe, struct lima_sched_task *
 int lima_sched_pipe_init(struct lima_sched_pipe *pipe, const char *name);
 void lima_sched_pipe_fini(struct lima_sched_pipe *pipe);
 int lima_sched_pipe_wait_fence(struct lima_sched_pipe *pipe, u32 fence, u64 timeout_ns);
-void lima_sched_pipe_task_done(struct lima_sched_pipe *pipe);
+void lima_sched_pipe_task_done(struct lima_sched_pipe *pipe, bool error);
 
 #endif
-- 
2.0.1

