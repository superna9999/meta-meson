From 025a645406778ebf704a666cf29dd79f30dbfe01 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 8 Feb 2018 11:01:40 +0800
Subject: [PATCH 103/134] drm/lima: use module param for some configurable args

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 drivers/gpu/drm/lima/lima.h       |  3 +++
 drivers/gpu/drm/lima/lima_drv.c   | 21 +++++++++++++++++++++
 drivers/gpu/drm/lima/lima_sched.c | 33 +++++++++++++++++++++++++++------
 drivers/gpu/drm/lima/lima_sched.h |  3 +--
 4 files changed, 52 insertions(+), 8 deletions(-)

diff --git a/drivers/gpu/drm/lima/lima.h b/drivers/gpu/drm/lima/lima.h
index 3094c2c..17db8c0 100644
--- a/drivers/gpu/drm/lima/lima.h
+++ b/drivers/gpu/drm/lima/lima.h
@@ -29,6 +29,9 @@
 #include "lima_vm.h"
 #include "lima_sched.h"
 
+extern int lima_sched_timeout_ms;
+extern int lima_sched_max_tasks;
+
 enum lima_gpu_type {
 	GPU_MALI400 = 0,
 	GPU_MALI450,
diff --git a/drivers/gpu/drm/lima/lima_drv.c b/drivers/gpu/drm/lima/lima_drv.c
index 9e92e48..1f3b210 100644
--- a/drivers/gpu/drm/lima/lima_drv.c
+++ b/drivers/gpu/drm/lima/lima_drv.c
@@ -1,9 +1,19 @@
 #include <linux/module.h>
 #include <linux/of_platform.h>
+#include <linux/log2.h>
 #include <drm/drm_prime.h>
 
 #include "lima.h"
 
+int lima_sched_timeout_ms = 0;
+int lima_sched_max_tasks = 32;
+
+MODULE_PARM_DESC(sched_timeout_ms, "task run timeout in ms (0 = no timeout (default))");
+module_param_named(sched_timeout_ms, lima_sched_timeout_ms, int, 0444);
+
+MODULE_PARM_DESC(sched_max_tasks, "max queued task num in a context (default 32)");
+module_param_named(sched_max_tasks, lima_sched_max_tasks, int, 0444);
+
 
 static inline struct lima_device *to_lima_dev(struct drm_device *dev)
 {
@@ -217,6 +227,7 @@ static struct drm_driver lima_drm_driver = {
 	.date               = "20170325",
 	.major              = 1,
 	.minor              = 0,
+	.patchlevel         = 0,
 
 	.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
 	.gem_prime_import   = drm_gem_prime_import,
@@ -301,10 +312,20 @@ static struct platform_driver lima_platform_driver = {
 	},
 };
 
+static void lima_check_module_param(void)
+{
+	if (lima_sched_max_tasks < 4)
+		lima_sched_max_tasks = 4;
+	else
+		lima_sched_max_tasks = roundup_pow_of_two(lima_sched_max_tasks);
+}
+
 static int __init lima_init(void)
 {
 	int ret;
 
+	lima_check_module_param();
+
 	ret = platform_driver_register(&lima_platform_driver);
 
 	return ret;
diff --git a/drivers/gpu/drm/lima/lima_sched.c b/drivers/gpu/drm/lima/lima_sched.c
index 102411f..56fc683 100644
--- a/drivers/gpu/drm/lima/lima_sched.c
+++ b/drivers/gpu/drm/lima/lima_sched.c
@@ -147,16 +147,32 @@ int lima_sched_context_init(struct lima_sched_pipe *pipe,
 			    struct lima_sched_context *context)
 {
 	struct drm_sched_rq *rq = pipe->base.sched_rq + DRM_SCHED_PRIORITY_NORMAL;
+	int err;
+
+	context->fences =
+		kzalloc(sizeof(*context->fences) * lima_sched_max_tasks, GFP_KERNEL);
+	if (!context->fences)
+		return -ENOMEM;
 
 	spin_lock_init(&context->lock);
-	return drm_sched_entity_init(&pipe->base, &context->base, rq,
-				     LIMA_SCHED_CONTEXT_MAX_TASK, &context->guilty);
+	err = drm_sched_entity_init(&pipe->base, &context->base, rq,
+				    lima_sched_max_tasks, &context->guilty);
+	if (err) {
+		kfree(context->fences);
+		context->fences = NULL;
+		return err;
+	}
+
+	return 0;
 }
 
 void lima_sched_context_fini(struct lima_sched_pipe *pipe,
 			     struct lima_sched_context *context)
 {
 	drm_sched_entity_fini(&pipe->base, &context->base);
+
+	if (context->fences)
+		kfree(context->fences);
 }
 
 static uint32_t lima_sched_context_add_fence(struct lima_sched_context *context,
@@ -168,7 +184,7 @@ static uint32_t lima_sched_context_add_fence(struct lima_sched_context *context,
 	spin_lock(&context->lock);
 
 	seq = context->sequence;
-	idx = seq & (LIMA_SCHED_CONTEXT_MAX_TASK - 1);
+	idx = seq & (lima_sched_max_tasks - 1);
 	other = context->fences[idx];
 
 	if (other) {
@@ -201,12 +217,12 @@ static struct dma_fence *lima_sched_context_get_fence(struct lima_sched_context
 		goto out;
 	}
 
-	if (seq + LIMA_SCHED_CONTEXT_MAX_TASK < context->sequence) {
+	if (seq + lima_sched_max_tasks < context->sequence) {
 		fence = NULL;
 		goto out;
 	}
 
-	idx = seq & (LIMA_SCHED_CONTEXT_MAX_TASK - 1);
+	idx = seq & (lima_sched_max_tasks - 1);
 	fence = dma_fence_get(context->fences[idx]);
 
 out:
@@ -350,7 +366,12 @@ const struct drm_sched_backend_ops lima_sched_ops = {
 
 int lima_sched_pipe_init(struct lima_sched_pipe *pipe, const char *name)
 {
-	const long timeout = msecs_to_jiffies(5000);
+	long timeout;
+
+	if (lima_sched_timeout_ms <= 0)
+		timeout = MAX_SCHEDULE_TIMEOUT;
+	else
+		timeout = msecs_to_jiffies(lima_sched_timeout_ms);
 
 	pipe->fence_context = dma_fence_context_alloc(1);
 	spin_lock_init(&pipe->fence_lock);
diff --git a/drivers/gpu/drm/lima/lima_sched.h b/drivers/gpu/drm/lima/lima_sched.h
index 70bafdd..3551175 100644
--- a/drivers/gpu/drm/lima/lima_sched.h
+++ b/drivers/gpu/drm/lima/lima_sched.h
@@ -38,11 +38,10 @@ struct lima_sched_task {
 	struct dma_fence *fence;
 };
 
-#define LIMA_SCHED_CONTEXT_MAX_TASK 32
 struct lima_sched_context {
 	struct drm_sched_entity base;
 	spinlock_t lock;
-	struct dma_fence *fences[LIMA_SCHED_CONTEXT_MAX_TASK];
+	struct dma_fence **fences;
 	uint32_t sequence;
 	atomic_t guilty;
 };
-- 
2.0.1

