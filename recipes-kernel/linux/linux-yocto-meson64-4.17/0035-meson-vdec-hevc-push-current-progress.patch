From 62c06f409e93bf610e64c50bf05decef65b2cc46 Mon Sep 17 00:00:00 2001
From: Maxime Jourdan <maxi.jourdan@wanadoo.fr>
Date: Tue, 17 Apr 2018 03:18:31 +0200
Subject: [PATCH] meson: vdec: hevc: push current progress

There isn't much new feature wise.
The code is in a pitiful state because of all the prints and register writes.
It'll get better once we actually start decoding frames.

We're also back to using the non-MMU firmware since I can get the parsing interrupt with that one now.

I'm currently focusing on decoding the first IDR frame of a bitstream, there is no support for anything else.
---
 drivers/media/platform/meson/vdec/codec_helpers.c |  18 +-
 drivers/media/platform/meson/vdec/codec_hevc.c    | 758 +++++++++++++++++++---
 drivers/media/platform/meson/vdec/vdec.c          |   8 +-
 drivers/media/platform/meson/vdec/vdec_hevc.c     |  12 +-
 drivers/soc/amlogic/meson-pwrc-vdec.c             |   5 +
 vh265_mc                                          | Bin 16384 -> 16384 bytes
 6 files changed, 699 insertions(+), 102 deletions(-)

diff --git a/drivers/media/platform/meson/vdec/codec_helpers.c b/drivers/media/platform/meson/vdec/codec_helpers.c
index c383c58..2dc3188 100644
--- a/drivers/media/platform/meson/vdec/codec_helpers.c
+++ b/drivers/media/platform/meson/vdec/codec_helpers.c
@@ -17,18 +17,24 @@ void codec_helper_set_canvases(struct vdec_session *sess, void *reg_base)
 	v4l2_m2m_for_each_dst_buf(sess->m2m_ctx, buf) {
 		u32 buf_idx    = buf->vb.vb2_buf.index;
 		u32 cnv_y_idx  = 128 + buf_idx * 2;
-		u32 cnv_uv_idx = 128 + buf_idx * 2 + 1;
-		dma_addr_t buf_y_paddr  = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
-		dma_addr_t buf_uv_paddr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 1);
+		u32 cnv_uv_idx = cnv_y_idx + 1;
+		dma_addr_t buf_y_paddr  =
+			vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
+		dma_addr_t buf_uv_paddr =
+			vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 1);
 
 		/* Y plane */
-		vdec_canvas_setup(core->dmc_base, cnv_y_idx, buf_y_paddr, width, height, MESON_CANVAS_WRAP_NONE, MESON_CANVAS_BLKMODE_LINEAR);
+		vdec_canvas_setup(core->dmc_base, cnv_y_idx, buf_y_paddr,
+			width, height, MESON_CANVAS_WRAP_NONE,
+			MESON_CANVAS_BLKMODE_LINEAR);
 
 		/* U/V plane */
-		vdec_canvas_setup(core->dmc_base, cnv_uv_idx, buf_uv_paddr, width, height / 2, MESON_CANVAS_WRAP_NONE, MESON_CANVAS_BLKMODE_LINEAR);
+		vdec_canvas_setup(core->dmc_base, cnv_uv_idx, buf_uv_paddr,
+			width, height / 2, MESON_CANVAS_WRAP_NONE,
+			MESON_CANVAS_BLKMODE_LINEAR);
 
 		writel_relaxed(((cnv_uv_idx) << 16) |
 			       ((cnv_uv_idx) << 8)  |
-				(cnv_y_idx), reg_base + buf_idx*4);
+				(cnv_y_idx), reg_base + buf_idx * 4);
 	}
 }
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/codec_hevc.c b/drivers/media/platform/meson/vdec/codec_hevc.c
index 2125fa3..77b541b 100644
--- a/drivers/media/platform/meson/vdec/codec_hevc.c
+++ b/drivers/media/platform/meson/vdec/codec_hevc.c
@@ -15,6 +15,7 @@
 #define HEVC_DEC_STATUS_REG       HEVC_ASSIST_SCRATCH_0
 	#define HEVC_ACTION_DONE	0xff
 #define HEVC_RPM_BUFFER           HEVC_ASSIST_SCRATCH_1
+#define HEVC_DECODE_INFO	HEVC_ASSIST_SCRATCH_1
 #define HEVC_SHORT_TERM_RPS       HEVC_ASSIST_SCRATCH_2
 #define HEVC_VPS_BUFFER           HEVC_ASSIST_SCRATCH_3
 #define HEVC_SPS_BUFFER           HEVC_ASSIST_SCRATCH_4
@@ -40,11 +41,18 @@
 #define HEVC_AUX_ADR		  HEVC_ASSIST_SCRATCH_L
 #define HEVC_AUX_DATA_SIZE	  HEVC_ASSIST_SCRATCH_M
 #define HEVC_DECODE_SIZE	  HEVC_ASSIST_SCRATCH_N
-
 #define HEVCD_MPP_ANC2AXI_TBL_DATA (0x3464 * 4)
 
+#define AMRISC_MAIN_REQ         0x04
+
 /* HEVC Infos */
-#define MAX_REF_PIC_NUM 24
+#define MAX_REF_PIC_NUM	24
+#define MAX_REF_ACTIVE  16
+#define MPRED_MV_BUF_SIZE	0x120000
+#define MAX_TILE_COL_NUM	5
+#define MAX_TILE_ROW_NUM	5
+#define MAX_SLICE_NUM	800
+#define INVALID_POC 0x80000000
 
 #define IPP_OFFSET       0x00
 #define SAO_ABV_OFFSET   (IPP_OFFSET + 0x4000)
@@ -62,7 +70,7 @@
 #define MMU_VBH_OFFSET   (DBLK_DATA_OFFSET + 0x40000)
 #define MPRED_ABV_OFFSET (MMU_VBH_OFFSET + 0x5000)
 #define MPRED_MV_OFFSET  (MPRED_ABV_OFFSET + 0x8000)
-#define RPM_OFFSET       (MPRED_MV_OFFSET + 0x120000 * MAX_REF_PIC_NUM)
+#define RPM_OFFSET       (MPRED_MV_OFFSET + MPRED_MV_BUF_SIZE * MAX_REF_PIC_NUM)
 #define LMEM_OFFSET      (RPM_OFFSET + 0x100)
 
 /* ISR decode status */
@@ -81,16 +89,32 @@
 #define HEVC_SEI_DAT                         0xc
 #define HEVC_SEI_DAT_DONE                    0xd
 
+/* RPM misc_flag0 */
+#define PCM_LOOP_FILTER_DISABLED_FLAG_BIT       0
+#define PCM_ENABLE_FLAG_BIT             1
+#define LOOP_FILER_ACROSS_TILES_ENABLED_FLAG_BIT    2
+#define PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT  3
+#define DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_BIT 4
+#define PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT     5
+#define DEBLOCKING_FILTER_OVERRIDE_FLAG_BIT     6
+#define SLICE_DEBLOCKING_FILTER_DISABLED_FLAG_BIT   7
+#define SLICE_SAO_LUMA_FLAG_BIT             8
+#define SLICE_SAO_CHROMA_FLAG_BIT           9
+#define SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT 10
+
+/* Buffer sizes */
 #define SIZE_WORKSPACE ALIGN(LMEM_OFFSET + 0xA00, 64 * SZ_1K)
 #define SIZE_AUX (SZ_1K * 32)
 #define SIZE_FRAME_MMU (0x1200 * 4)
 
+#define RPM_BEGIN                                              0x100
+#define modification_list_cur                                  0x140
+#define RPM_END                                                0x180
+#define RPS_USED_BIT        14
+
 #define PARSER_CMD_SKIP_CFG_0 0x0000090b
 #define PARSER_CMD_SKIP_CFG_1 0x1b14140f
 #define PARSER_CMD_SKIP_CFG_2 0x001b1910
-
-#define AMRISC_MAIN_REQ         0x04
-
 static const u16 parser_cmd[] = {
 	0x0401,
 	0x8401,
@@ -131,10 +155,6 @@ static const u16 parser_cmd[] = {
 	0x7C00
 };
 
-#define RPM_BEGIN                                              0x100
-#define modification_list_cur                                  0x140
-#define RPM_END                                                0x180
-
 union rpm_param {
 	struct {
 		unsigned short data[RPM_END - RPM_BEGIN];
@@ -161,7 +181,7 @@ union rpm_param {
 		unsigned short five_minus_max_num_merge_cand;
 		unsigned short sps_num_reorder_pics_0;
 		unsigned short modification_flag;
-		unsigned short tiles_enabled_flag;
+		unsigned short tiles_flags;
 		unsigned short num_tile_columns_minus1;
 		unsigned short num_tile_rows_minus1;
 		unsigned short tile_width[4];
@@ -280,6 +300,41 @@ enum NalUnitType {
 	NAL_UNIT_INVALID,
 };
 
+enum slice_type {
+	B_SLICE = 0,
+	P_SLICE = 1,
+	I_SLICE = 2,
+};
+
+/* Refers to a frame being decoded */
+struct hevc_frame {
+	struct list_head list;
+	struct vb2_v4l2_buffer *vbuf;
+	u32 poc;
+	u32 referenced;
+
+	u32 cur_slice_idx;
+	u32 cur_slice_type;
+
+	/* Up to 16 L0 refs for up to 5 slices */
+	u32 ref_poc_l0[MAX_SLICE_NUM][16];
+	u32 ref_num_l0;
+
+	/* Up to 16 L1 refs for up to 5 slices */
+	u32 ref_poc_l1[MAX_SLICE_NUM][16];
+	u32 ref_num_l1;
+};
+
+struct tile_s {
+	int width;
+	int height;
+	int start_cu_x;
+	int start_cu_y;
+
+	dma_addr_t sao_vb_start_addr;
+	dma_addr_t sao_abv_start_addr;
+};
+
 struct codec_hevc {
 	/* Buffer for the HEVC Workspace */
 	void      *workspace_vaddr;
@@ -298,12 +353,33 @@ struct codec_hevc {
 
 	/* Information computed from the RPM */
 	u32 lcu_size; // Largest Coding Unit
-
-	/* Current Picture Order Count */
+	u32 lcu_x_num;
+	u32 lcu_y_num;
+	u32 lcu_total;
+
+	/* Current Frame being handled */
+	struct hevc_frame *curr_frame;
+	/* collocated reference picture */
+	struct hevc_frame *col_frame;
 	u32 curr_poc;
 
+	/* All frames used by the HW at a given time */
+	struct list_head frames_list;
+
 	/* ?? */
 	u32 iPrevTid0POC;
+	u32 iPrevPOC;
+	u32 slice_segment_addr;
+	u32 slice_addr;
+
+	/* Tiles */
+	u32 num_tile_col;
+	u32 num_tile_row;
+	struct tile_s m_tile[MAX_TILE_ROW_NUM][MAX_TILE_COL_NUM];
+	u32 tile_start_lcu_x;
+	u32 tile_start_lcu_y;
+	u32 tile_width_lcu;
+	u32 tile_height_lcu;
 
 	/* Housekeeping thread for marking buffers to DONE
 	 * and recycling them into the hardware
@@ -311,29 +387,179 @@ struct codec_hevc {
 	struct task_struct *buffers_thread;
 };
 
+/* Update the L0 and L1 reference lists for a given frame */
+static void codec_hevc_update_frame_refs(struct vdec_session *sess, struct hevc_frame *frame)
+{
+	struct codec_hevc *hevc = sess->priv;
+	union rpm_param *params = &hevc->rpm_param;
+	int i, rIdx;
+	int num_neg = 0;
+	int num_pos = 0;
+	int total_num;
+	int num_ref_idx_l0_active =
+		(params->p.num_ref_idx_l0_active >
+		 MAX_REF_ACTIVE) ? MAX_REF_ACTIVE :
+		params->p.num_ref_idx_l0_active;
+	int num_ref_idx_l1_active =
+		(params->p.num_ref_idx_l1_active >
+		 MAX_REF_ACTIVE) ? MAX_REF_ACTIVE :
+		params->p.num_ref_idx_l1_active;
+	int RefPicSetStCurr0[16];
+	int RefPicSetStCurr1[16];
+
+	for (i = 0; i < 16; i++) {
+		RefPicSetStCurr0[i] = 0;
+		RefPicSetStCurr1[i] = 0;
+		frame->ref_poc_l0[frame->cur_slice_idx][i] = 0;
+		frame->ref_poc_l1[frame->cur_slice_idx][i] = 0;
+	}
+	for (i = 0; i < 16; i++) {
+		u32 cur_rps = params->p.CUR_RPS[i];
+		if (cur_rps & 0x8000)
+			break;
+		if ((cur_rps >> RPS_USED_BIT) & 1) {
+			int delt =
+				cur_rps &
+				((1 << (RPS_USED_BIT - 1)) - 1);
+			if ((cur_rps >> (RPS_USED_BIT - 1)) & 1) {
+				RefPicSetStCurr0[num_neg] =
+					frame->poc - ((1 << (RPS_USED_BIT - 1)) -
+								delt);
+				num_neg++;
+			} else {
+				RefPicSetStCurr1[num_pos] = frame->poc + delt;
+				num_pos++;
+			}
+		}
+	}
+	printk("num_neg = %d; num_pos = %d\n", num_neg, num_pos);
+	total_num = num_neg + num_pos;
+
+	if (total_num > 0) {
+		if (params->p.modification_flag & 0x1) {
+			for (rIdx = 0; rIdx < num_ref_idx_l0_active; rIdx++) {
+				int cIdx = params->p.modification_list[rIdx];
+				frame->ref_poc_l0[frame->cur_slice_idx][rIdx] =
+					cIdx >=
+					num_neg ? RefPicSetStCurr1[cIdx -
+					num_neg] :
+					RefPicSetStCurr0[cIdx];
+			}
+		} else {
+			for (rIdx = 0; rIdx < num_ref_idx_l0_active; rIdx++) {
+				int cIdx = rIdx % total_num;
+				frame->ref_poc_l0[frame->cur_slice_idx][rIdx] =
+					cIdx >=
+					num_neg ? RefPicSetStCurr1[cIdx -
+					num_neg] :
+					RefPicSetStCurr0[cIdx];
+			}
+		}
+
+		if (params->p.slice_type == B_SLICE) {
+			if (params->p.modification_flag & 0x2) {
+
+				for (rIdx = 0; rIdx < num_ref_idx_l1_active;
+					 rIdx++) {
+					int cIdx;
+					if (params->p.modification_flag & 0x1) {
+						cIdx =
+							params->p.
+							modification_list
+							[num_ref_idx_l0_active +
+							 rIdx];
+					} else {
+						cIdx =
+							params->p.
+							modification_list[rIdx];
+					}
+					frame->ref_poc_l1[frame->
+						cur_slice_idx][rIdx] =
+						cIdx >=
+						num_pos ?
+						RefPicSetStCurr0[cIdx -	num_pos]
+						: RefPicSetStCurr1[cIdx];
+				}
+			} else {
+
+				for (rIdx = 0; rIdx < num_ref_idx_l1_active;
+					 rIdx++) {
+					int cIdx = rIdx % total_num;
+					frame->ref_poc_l1[frame->
+						cur_slice_idx][rIdx] =
+						cIdx >=
+						num_pos ?
+						RefPicSetStCurr0[cIdx -
+						num_pos]
+						: RefPicSetStCurr1[cIdx];
+				}
+			}
+		}
+	}
+	/*set m_PIC */
+	frame->cur_slice_type = params->p.slice_type;
+	frame->ref_num_l0 = num_ref_idx_l0_active;
+	frame->ref_num_l1 = num_ref_idx_l1_active;
+
+	printk("Update frame %u; slice %u; slice_type %u; num_l0 %u; num_l1 %u\n", frame->poc, frame->cur_slice_idx, params->p.slice_type, frame->ref_num_l0, frame->ref_num_l1);
+}
+
+/* Dummy thread to print status every 0.5s */
 static int codec_hevc_buffers_thread(void *data)
 {
 	struct vdec_session *sess = data;
 	struct vdec_core *core = sess->core;
+	struct codec_hevc *hevc = sess->priv;
 
 	while (!kthread_should_stop()) {
+		msleep_interruptible(500);
 		printk("status: %08X ; level = %d ; d_si = %08X ; d_st = %08X; d_sc = %08X ; sfc = %08X\n", readl_relaxed(core->dos_base + HEVC_PARSER_INT_STATUS), readl_relaxed(core->dos_base + HEVC_STREAM_LEVEL), readl_relaxed(core->dos_base + HEVC_DECODE_SIZE), readl_relaxed(core->dos_base + DECODE_STOP_POS), readl_relaxed(core->dos_base + HEVC_STREAM_CONTROL), readl_relaxed(core->dos_base + HEVC_STREAM_FIFO_CTL));
-
-		msleep(100);
+		printk("Stream offset: %08X; curr_lcu = %u\n", readl_relaxed(core->dos_base + HEVC_SHIFT_BYTE_COUNT), readl_relaxed(core->dos_base + HEVC_MPRED_CURR_LCU));
+		printk("HEVC_DECODE_INFO = %08X\n", readl_relaxed(core->dos_base + HEVC_DECODE_INFO));
 	}
 
 	return 0;
 }
 
+static void codec_hevc_setup_canvas(struct vdec_session *sess)
+{
+	struct v4l2_m2m_buffer *buf;
+	struct vdec_core *core = sess->core;
+	u32 width = ALIGN(sess->width, 64);
+	u32 height = ALIGN(sess->height, 64);
+
+	v4l2_m2m_for_each_dst_buf(sess->m2m_ctx, buf) {
+		u32 buf_idx    = buf->vb.vb2_buf.index;
+		u32 cnv_y_idx  = 128 + buf_idx * 2;
+		u32 cnv_uv_idx = cnv_y_idx + 1;
+		dma_addr_t buf_y_paddr  =
+			vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
+		dma_addr_t buf_uv_paddr =
+			vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 1);
+
+		/* Y plane */
+		vdec_canvas_setup(core->dmc_base, cnv_y_idx, buf_y_paddr,
+			width, height, MESON_CANVAS_WRAP_NONE,
+			MESON_CANVAS_BLKMODE_LINEAR);
+
+		/* U/V plane */
+		vdec_canvas_setup(core->dmc_base, cnv_uv_idx, buf_uv_paddr,
+			width, height / 2, MESON_CANVAS_WRAP_NONE,
+			MESON_CANVAS_BLKMODE_LINEAR);
+	}
+}
+
 static void codec_hevc_setup_buffers(struct vdec_session *sess)
 {
 	int i;
 	dma_addr_t buf_y_paddr = 0;
-	dma_addr_t buf_uv_paddr;
+	dma_addr_t buf_uv_paddr = 0;
 	struct v4l2_m2m_buffer *buf;
 	struct vdec_core *core = sess->core;
 	u32 buf_size = v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);
 
+	codec_hevc_setup_canvas(sess);
+
 	/* >= GXL */
 	writel_relaxed((1 << 2) | (1 << 1), core->dos_base + HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR);
 	/* < GXL */
@@ -343,16 +569,16 @@ static void codec_hevc_setup_buffers(struct vdec_session *sess)
 		buf_y_paddr  = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
 		buf_uv_paddr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 1);
 
+		printk("Buf: %16X;%16X\n", buf_y_paddr, buf_uv_paddr);
+
 		writel_relaxed(buf_y_paddr  >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
-		writel_relaxed(buf_y_paddr  >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
-		/* Double write mode ?? */
-		//writel_relaxed(buf_uv_paddr >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
+		writel_relaxed(buf_uv_paddr >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
 	}
 
-	/* Fill the remaining unused slots with the last buffer's Y addr ? */
+	/* Fill the remaining unused slots with the last buffer's Y/UV addr ? */
 	for (i = buf_size; i < MAX_REF_PIC_NUM; ++i) {
 		writel_relaxed(buf_y_paddr  >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
-		//writel_relaxed(buf_uv_paddr >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
+		writel_relaxed(buf_uv_paddr >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
 	}
 
 	writel_relaxed(1, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR);
@@ -374,15 +600,14 @@ static int codec_hevc_setup_workspace(struct vdec_session *sess)
 	}
 	printk("Allocated Workspace: %08X - %08X\n", hevc->workspace_paddr, hevc->workspace_paddr + SIZE_WORKSPACE);
 
-	hevc->frame_mmu_vaddr = dma_alloc_coherent(core->dev, SIZE_FRAME_MMU, &hevc->frame_mmu_paddr, GFP_KERNEL);
+	/*hevc->frame_mmu_vaddr = dma_alloc_coherent(core->dev, SIZE_FRAME_MMU, &hevc->frame_mmu_paddr, GFP_KERNEL);
 	if (!hevc->frame_mmu_vaddr) {
 		printk("Failed to request HEVC frame_mmu\n");
 		return -ENOMEM;
 	}
 	memset(hevc->frame_mmu_vaddr, 0, SIZE_FRAME_MMU);
-	printk("Allocated frame_mmu: %08X - %08X\n", hevc->frame_mmu_paddr, hevc->frame_mmu_paddr + SIZE_FRAME_MMU);
+	printk("Allocated frame_mmu: %08X - %08X\n", hevc->frame_mmu_paddr, hevc->frame_mmu_paddr + SIZE_FRAME_MMU);*/
 
-	/* Setup Workspace */
 	writel_relaxed(hevc->workspace_paddr + IPP_OFFSET, core->dos_base + HEVCD_IPP_LINEBUFF_BASE);
 	writel_relaxed(hevc->workspace_paddr + RPM_OFFSET, core->dos_base + HEVC_RPM_BUFFER);
 	writel_relaxed(hevc->workspace_paddr + SH_TM_RPS_OFFSET, core->dos_base + HEVC_SHORT_TERM_RPS);
@@ -390,10 +615,12 @@ static int codec_hevc_setup_workspace(struct vdec_session *sess)
 	writel_relaxed(hevc->workspace_paddr + SPS_OFFSET, core->dos_base + HEVC_SPS_BUFFER);
 	writel_relaxed(hevc->workspace_paddr + PPS_OFFSET, core->dos_base + HEVC_PPS_BUFFER);
 	writel_relaxed(hevc->workspace_paddr + SAO_UP_OFFSET, core->dos_base + HEVC_SAO_UP);
+
 	/* MMU */
-	writel_relaxed(hevc->frame_mmu_paddr, core->dos_base + H265_MMU_MAP_BUFFER);
+	//writel_relaxed(hevc->frame_mmu_paddr, core->dos_base + H265_MMU_MAP_BUFFER);
 	/* No MMU */
-	//writel_relaxed(hevc->workspace_paddr + SWAP_BUF_OFFSET, core->dos_base + HEVC_STREAM_SWAP_BUFFER);
+	writel_relaxed(hevc->workspace_paddr + SWAP_BUF_OFFSET, core->dos_base + HEVC_STREAM_SWAP_BUFFER);
+
 	writel_relaxed(hevc->workspace_paddr + SWAP_BUF2_OFFSET, core->dos_base + HEVC_STREAM_SWAP_BUFFER2);
 	writel_relaxed(hevc->workspace_paddr + SCALELUT_OFFSET, core->dos_base + HEVC_SCALELUT);
 	writel_relaxed(hevc->workspace_paddr + DBLK_PARA_OFFSET, core->dos_base + HEVC_DBLK_CFG4);
@@ -416,8 +643,12 @@ static int codec_hevc_start(struct vdec_session *sess)
 		return -ENOMEM;
 
 	sess->priv = hevc;
+	INIT_LIST_HEAD(&hevc->frames_list);
+	hevc->curr_poc = INVALID_POC;
 
-	codec_hevc_setup_workspace(sess);
+	ret = codec_hevc_setup_workspace(sess);
+	if (ret)
+		goto free_hevc;
 
 	writel_relaxed(0x5a5a55aa, core->dos_base + HEVC_PARSER_VERSION);
 	writel_relaxed((1 << 14), core->dos_base + DOS_SW_RESET3);
@@ -465,6 +696,9 @@ static int codec_hevc_start(struct vdec_session *sess)
 	writel_relaxed(1, core->dos_base + HEVC_ASSIST_MBOX1_MASK);
 	/* disable PSCALE for hardware sharing */
 	writel_relaxed(0, core->dos_base + HEVC_PSCALE_CTRL);
+
+	writel_relaxed(0, core->dos_base + DEBUG_REG1);
+
 	/* Let the uCode do all the parsing */
 	writel_relaxed(0xc, core->dos_base + NAL_SEARCH_CTL);
 
@@ -484,16 +718,24 @@ static int codec_hevc_start(struct vdec_session *sess)
 	}
 	printk("Allocated AUX: %08X - %08X\n", hevc->aux_paddr, hevc->aux_paddr + SIZE_AUX);
 
-	writel_relaxed(hevc->aux_paddr, core->dos_base + HEVC_AUX_ADR);
-	writel_relaxed((((SIZE_AUX / 2) >> 4) << 16) | ((SIZE_AUX / 2) >> 4), core->dos_base + HEVC_AUX_DATA_SIZE);
+	/*writel_relaxed(hevc->aux_paddr, core->dos_base + HEVC_AUX_ADR);
+	writel_relaxed((((SIZE_AUX / 2) >> 4) << 16) | ((SIZE_AUX / 2) >> 4), core->dos_base + HEVC_AUX_DATA_SIZE);*/
 
-	codec_hevc_setup_buffers(sess);
+	writel_relaxed((1<<12)|(1<<11), core->dos_base + DOS_SW_RESET3);
+	writel_relaxed(0, core->dos_base + DOS_SW_RESET3);
+	readl_relaxed(core->dos_base + DOS_SW_RESET3);
+
+	writel_relaxed(1, core->dos_base + HEVC_MPSR);
 
 	hevc->buffers_thread = kthread_run(codec_hevc_buffers_thread, sess, "buffers_done");
 
 	printk("HEVC start OK!\n");
 
 	return 0;
+
+free_hevc:
+	kfree(hevc);
+	return ret;
 }
 
 static int codec_hevc_stop(struct vdec_session *sess)
@@ -526,82 +768,422 @@ static int codec_hevc_stop(struct vdec_session *sess)
 	return 0;
 }
 
-static void codec_hevc_prepare_new_frame(struct vdec_session *sess) {
+static void codec_hevc_update_tiles(struct vdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	struct vdec_core *core = sess->core;
+	u32 sao_mem_unit = (hevc->lcu_size == 16 ? 9 : hevc->lcu_size == 32 ? 14 : 24) << 4;
+	u32 pic_height_cu = (sess->height + hevc->lcu_size - 1) / hevc->lcu_size;
+	u32 pic_width_cu = (sess->width + hevc->lcu_size - 1) / hevc->lcu_size;
+	u32 sao_vb_size = (sao_mem_unit + (2 << 4)) * pic_height_cu;
+	u32 tiles_flags = hevc->rpm_param.p.tiles_flags;
+
+	printk("tiles_flags = %08X\n", tiles_flags);
+
+	if (tiles_flags & 1) {
+		/* TODO; The sample I'm using has tiles_flags == 0 */
+		return;
+	}
+
+	hevc->num_tile_col = 1;
+	hevc->num_tile_row = 1;
+	hevc->m_tile[0][0].width = pic_width_cu;
+	hevc->m_tile[0][0].height = pic_height_cu;
+	hevc->m_tile[0][0].start_cu_x = 0;
+	hevc->m_tile[0][0].start_cu_y = 0;
+	hevc->m_tile[0][0].sao_vb_start_addr = hevc->workspace_paddr + SAO_VB_OFFSET;
+	hevc->m_tile[0][0].sao_abv_start_addr = hevc->workspace_paddr + SAO_ABV_OFFSET;
+	
+	hevc->tile_start_lcu_x = 0;
+	hevc->tile_start_lcu_y = 0;
+	hevc->tile_width_lcu = pic_width_cu;
+	hevc->tile_height_lcu = pic_height_cu;
+
+	printk("sao_mem_unit = %u; sao_vb_size = %u\n", sao_mem_unit, sao_vb_size);
+	writel_relaxed(sao_mem_unit, core->dos_base + HEVC_sao_mem_unit);
+	writel_relaxed(hevc->workspace_paddr + SAO_ABV_OFFSET, core->dos_base + HEVC_SAO_ABV);
+	writel_relaxed(sao_vb_size, core->dos_base + HEVC_sao_vb_size);
+	writel_relaxed(hevc->workspace_paddr + SAO_VB_OFFSET, core->dos_base + HEVC_SAO_VB);
+}
+
+static struct hevc_frame * codec_hevc_get_frame_by_poc(struct codec_hevc *hevc, u32 poc)
+{
+	struct hevc_frame * tmp;
 
+	list_for_each_entry(tmp, &hevc->frames_list, list) {
+		if (tmp->poc == poc)
+			return tmp;
+	}
+
+	return NULL;
 }
 
-static void codec_hevc_set_iPrevTid0POC(struct vdec_session *sess) {
+static struct hevc_frame * codec_hevc_prepare_new_frame(struct vdec_session *sess)
+{
+	struct vb2_v4l2_buffer *vbuf;
+	struct hevc_frame *new_frame = NULL;
+	struct codec_hevc *hevc = sess->priv;
+
+	vbuf = v4l2_m2m_dst_buf_remove(sess->m2m_ctx);
+	if (!vbuf) {
+		printk("Couldn't remove dst buf\n");
+		return NULL;
+	}
+
+	new_frame = kzalloc(sizeof(*new_frame), GFP_KERNEL);
+	if (!new_frame)
+		return NULL;
+
+	new_frame->vbuf = vbuf;
+	new_frame->referenced = 1;
+	new_frame->poc = hevc->curr_poc;
+
+	list_add_tail(&new_frame->list, &hevc->frames_list);
+
+	return new_frame;
+}
+
+static void codec_hevc_set_sao(struct vdec_session *sess, struct hevc_frame *frame)
+{
+	struct vdec_core *core = sess->core;
+	struct codec_hevc *hevc = sess->priv;
+	union rpm_param *param = &hevc->rpm_param;
+	dma_addr_t buf_y_paddr = vb2_dma_contig_plane_dma_addr(&frame->vbuf->vb2_buf, 0);
+	dma_addr_t buf_u_v_paddr = vb2_dma_contig_plane_dma_addr(&frame->vbuf->vb2_buf, 1);
+	u32 misc_flag0 = param->p.misc_flag0;
+	u32 slice_deblocking_filter_disabled_flag;
+	u32 val, val_2;
+
+	val = (readl_relaxed(core->dos_base + HEVC_SAO_CTRL0) & 0xf) | ilog2(hevc->lcu_size);
+	writel_relaxed(val, core->dos_base + HEVC_SAO_CTRL0);
+
+	writel_relaxed(sess->width | (sess->height << 16), core->dos_base + HEVC_SAO_PIC_SIZE);
+	writel_relaxed((hevc->lcu_x_num - 1) | (hevc->lcu_y_num - 1) << 16, core->dos_base + HEVC_SAO_PIC_SIZE_LCU);
+
+	printk("buf size: %08X\n", vdec_get_output_size(sess));
+	writel_relaxed(buf_y_paddr, core->dos_base + HEVC_SAO_Y_START_ADDR);
+	writel_relaxed(vdec_get_output_size(sess), core->dos_base + HEVC_SAO_Y_LENGTH);
+	writel_relaxed(buf_u_v_paddr, core->dos_base + HEVC_SAO_C_START_ADDR);
+	writel_relaxed((vdec_get_output_size(sess) / 2), core->dos_base + HEVC_SAO_C_LENGTH);
+
+	writel_relaxed(buf_y_paddr, core->dos_base + HEVC_SAO_Y_WPTR);
+	writel_relaxed(buf_u_v_paddr, core->dos_base + HEVC_SAO_C_WPTR);
+
+	if (frame->cur_slice_idx == 0) {
+		writel_relaxed(sess->width | (sess->height << 16), core->dos_base + HEVC_DBLK_CFG2);
+
+		val = 0;
+		if ((misc_flag0 >> PCM_ENABLE_FLAG_BIT) & 0x1) {
+			printk("Woo..\n");
+			val |= ((misc_flag0 >> PCM_LOOP_FILTER_DISABLED_FLAG_BIT) & 0x1) << 3;
+		}
+		val |= (param->p.pps_cb_qp_offset & 0x1f) << 4;
+		val |= (param->p.pps_cr_qp_offset & 0x1f) << 9;
+		val |= (hevc->lcu_size == 64) ? 0 : ((hevc->lcu_size == 32) ? 1 : 2);
+		printk("HEVC_DBLK_CFG1: %08X\n", val);
+		writel_relaxed(val, core->dos_base + HEVC_DBLK_CFG1);
+	}
+
+	val = readl_relaxed(core->dos_base + HEVC_SAO_CTRL1) & ~0x3ff3;
+	val |=	0x1 |  /* disable cm compression ? */
+		0x880;  /* 0xff0 mask controls "endianness", setting it to 0x880 enables 64-bit big endian */
+	writel_relaxed(val, core->dos_base + HEVC_SAO_CTRL1);
+
+	/* set them all 0 for H265_NV21 (no down-scale) */
+	val = readl_relaxed(core->dos_base + HEVC_SAO_CTRL5) & ~0xff0000;
+	writel_relaxed(val, core->dos_base + HEVC_SAO_CTRL5);
+
+	val = readl_relaxed(core->dos_base + HEVCD_IPP_AXIIF_CONFIG) & ~0x30;
+	val |= 0xf;
+	writel_relaxed(val, core->dos_base + HEVCD_IPP_AXIIF_CONFIG);
+
+	val = 0;
+	val_2 = readl_relaxed(core->dos_base + HEVC_SAO_CTRL0);
+	val_2 &= (~0x300);
+	/* slice_deblocking_filter_disabled_flag = 0;
+		ucode has handle it , so read it from ucode directly */
+	/*if (hevc->tile_enabled) {
+		val |=
+			((misc_flag0 >>
+			  LOOP_FILER_ACROSS_TILES_ENABLED_FLAG_BIT) &
+			 0x1) << 0;
+		val_2 |=
+			((misc_flag0 >>
+			  LOOP_FILER_ACROSS_TILES_ENABLED_FLAG_BIT) &
+			 0x1) << 8;
+	}*/
+	slice_deblocking_filter_disabled_flag = (misc_flag0 >>
+			SLICE_DEBLOCKING_FILTER_DISABLED_FLAG_BIT) &
+		0x1;	/* ucode has handle it,so read it from ucode directly */
+	if ((misc_flag0 & (1 << DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_BIT))
+		&& (misc_flag0 & (1 << DEBLOCKING_FILTER_OVERRIDE_FLAG_BIT))) {
+		//ucode has handle it , so read it from ucode directly */
+		val |= slice_deblocking_filter_disabled_flag << 2;
+
+		if (!slice_deblocking_filter_disabled_flag) {
+			val |= (param->p.slice_beta_offset_div2 & 0xf) << 3;
+			val |= (param->p.slice_tc_offset_div2 & 0xf) << 7;
+		}
+	} else {
+		val |=
+			((misc_flag0 >>
+			  PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT) &
+			 0x1) << 2;
+
+		if (((misc_flag0 >> PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT) &
+			 0x1) == 0) {
+			val |= (param->p.pps_beta_offset_div2 & 0xf) << 3;
+			val |= (param->p.pps_tc_offset_div2 & 0xf) << 7;
+		}
+	}
+	if ((misc_flag0 & (1 << PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT))
+		&& ((misc_flag0 & (1 << SLICE_SAO_LUMA_FLAG_BIT))
+			|| (misc_flag0 & (1 << SLICE_SAO_CHROMA_FLAG_BIT))
+			|| (!slice_deblocking_filter_disabled_flag))) {
+		val |=
+			((misc_flag0 >>
+			  SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)
+			 & 0x1)	<< 1;
+		val_2 |=
+			((misc_flag0 >>
+			  SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)
+			& 0x1) << 9;
+	} else {
+		val |=
+			((misc_flag0 >>
+			  PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)
+			 & 0x1) << 1;
+		val_2 |=
+			((misc_flag0 >>
+			  PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)
+			 & 0x1) << 9;
+	}
+
+	printk("Writing %08X;%08X\n", val, val_2);
+	writel_relaxed(val, core->dos_base + HEVC_DBLK_CFG9);
+	writel_relaxed(val_2, core->dos_base + HEVC_SAO_CTRL0);
+}
+
+static dma_addr_t codec_hevc_get_frame_mv_paddr(struct codec_hevc *hevc, struct hevc_frame *frame)
+{
+	return hevc->workspace_paddr + MPRED_MV_OFFSET +
+		(frame->vbuf->vb2_buf.index * MPRED_MV_BUF_SIZE);
+}
+
+/* Update the necessary information for motion prediction with the current slice */
+static void codec_hevc_set_mpred(struct vdec_session *sess, struct hevc_frame *frame, struct hevc_frame *col_frame)
+{
+	struct vdec_core *core = sess->core;
+	struct codec_hevc *hevc = sess->priv;
+	union rpm_param *param = &hevc->rpm_param;
+	u32 ref_num_l0 = frame->ref_num_l0;
+	u32 ref_num_l1 = frame->ref_num_l1;
+	u32 *ref_poc_l0 = frame->ref_poc_l0[frame->cur_slice_idx];
+	u32 *ref_poc_l1 = frame->ref_poc_l1[frame->cur_slice_idx];
+	u32 lcu_size_log2 = ilog2(hevc->lcu_size);
+	u32 mv_mem_unit = lcu_size_log2 == 6 ? 0x200 : lcu_size_log2 == 5 ? 0x80 : 0x20;
+	u32 slice_segment_address = param->p.slice_segment_address;
+	u32 max_num_merge_cand = 5 - param->p.five_minus_max_num_merge_cand;
+	u32 plevel = param->p.log2_parallel_merge_level;
+	u32 col_from_l0_flag = param->p.collocated_from_l0_flag;
+	u32 tmvp_flag = param->p.slice_temporal_mvp_enable_flag;
+	u32 is_next_slice_segment = param->p.dependent_slice_segment_flag ? 1 : 0;
+	u32 slice_type = param->p.slice_type;
+	dma_addr_t col_mv_rd_start_addr, col_mv_rd_ptr, col_mv_rd_end_addr;
+	dma_addr_t mpred_mv_wr_ptr;
+	u32 val;
+	int i;
+
+	val = readl_relaxed(core->dos_base + HEVC_MPRED_CURR_LCU);
+
+	col_mv_rd_start_addr = codec_hevc_get_frame_mv_paddr(hevc, col_frame);
+	mpred_mv_wr_ptr = codec_hevc_get_frame_mv_paddr(hevc, frame) + (hevc->slice_addr * mv_mem_unit);
+	col_mv_rd_ptr = col_mv_rd_start_addr + (hevc->slice_addr * mv_mem_unit);
+	col_mv_rd_end_addr = col_mv_rd_start_addr + ((hevc->lcu_x_num * hevc->lcu_y_num) * mv_mem_unit);
+
+	writel_relaxed(codec_hevc_get_frame_mv_paddr(hevc, frame), core->dos_base + HEVC_MPRED_MV_WR_START_ADDR);
+	writel_relaxed(col_mv_rd_start_addr, core->dos_base + HEVC_MPRED_MV_RD_START_ADDR);
+
+	printk("lcu_x_num = %u; tile_width_lcu = %u\n", hevc->lcu_x_num, hevc->tile_width_lcu);
+	val = ((hevc->lcu_x_num - hevc->tile_width_lcu) * mv_mem_unit);
+	printk("HEVC_MPRED_MV_WR_ROW_JUMP: %u\n", val);
+	writel_relaxed(val, core->dos_base + HEVC_MPRED_MV_WR_ROW_JUMP);
+	writel_relaxed(val, core->dos_base + HEVC_MPRED_MV_RD_ROW_JUMP);
+
+	printk("HEVC_MPRED_CTRL0 before: %08X\n", readl_relaxed(core->dos_base + HEVC_MPRED_CTRL0));
+	val = slice_type |
+			  1 << 2 | // new pic
+			  1 << 3 | // new tile
+			  is_next_slice_segment << 4 |
+			  tmvp_flag << 5 |
+			  0 << 6 | //LDCFlag
+			  col_from_l0_flag << 7 |
+			  1 << 9 |
+			  1 << 10 |
+			  0 << 11 | // mv_rd_en
+			  1 << 13 |
+			  lcu_size_log2 << 16 |
+			  3 << 20 | plevel << 24;
+	writel_relaxed(val, core->dos_base + HEVC_MPRED_CTRL0);
+	printk("HEVC_MPRED_CTRL0 after: %08X\n", readl_relaxed(core->dos_base + HEVC_MPRED_CTRL0));
+
+	val = max_num_merge_cand | 2 << 4 | 3 << 8 | 5 << 12 | 36 << 16;
+	writel_relaxed(val, core->dos_base + HEVC_MPRED_CTRL1);
+
+	writel_relaxed(sess->width | (sess->height << 16), core->dos_base + HEVC_MPRED_PIC_SIZE);
+
+	val = ((hevc->lcu_x_num - 1) | (hevc->lcu_y_num - 1) << 16);
+	writel_relaxed(val, core->dos_base + HEVC_MPRED_PIC_SIZE_LCU);
+	printk("PIC_SIZE_LCU = %08X\n", val);
+	val = (hevc->tile_start_lcu_x | hevc->tile_start_lcu_y << 16);
+	writel_relaxed(val, core->dos_base + HEVC_MPRED_TILE_START);
+	printk("HEVC_MPRED_TILE_START = %08X\n", val);
+	val = (hevc->tile_width_lcu | hevc->tile_height_lcu << 16);
+	writel_relaxed(val, core->dos_base + HEVC_MPRED_TILE_SIZE_LCU);
+	printk("HEVC_MPRED_TILE_SIZE_LCU = %08X\n", val);
+
+	writel_relaxed((ref_num_l0 | ref_num_l1 << 8), core->dos_base + HEVC_MPRED_REF_NUM);
+	writel_relaxed((1 << ref_num_l0) - 1, core->dos_base + HEVC_MPRED_REF_EN_L0);
+	writel_relaxed((1 << ref_num_l1) - 1, core->dos_base + HEVC_MPRED_REF_EN_L1);
+
+	writel_relaxed(hevc->curr_poc, core->dos_base + HEVC_MPRED_CUR_POC);
+	/* We only try to decode first frame for now, so write invalid_poc to col poc */
+	writel_relaxed(INVALID_POC, core->dos_base + HEVC_MPRED_COL_POC);
+
+	for (i = 0; i < MAX_REF_ACTIVE; ++i) {
+		printk("Ref %u: %u;%u\n", i, ref_poc_l0[i], ref_poc_l1[i]);
+		writel_relaxed(ref_poc_l0[i], core->dos_base + HEVC_MPRED_L0_REF00_POC + i * 4);
+		writel_relaxed(ref_poc_l1[i], core->dos_base + HEVC_MPRED_L1_REF00_POC + i * 4);
+	}
+
+	if (slice_segment_address == 0) {
+		printk("mpred_mv_wr_ptr = %08X; col_mv_rd_start_addr = %08X\n", mpred_mv_wr_ptr, col_mv_rd_start_addr);
+		writel_relaxed(hevc->workspace_paddr + MPRED_ABV_OFFSET, core->dos_base + HEVC_MPRED_ABV_START_ADDR);
+		writel_relaxed(mpred_mv_wr_ptr, core->dos_base + HEVC_MPRED_MV_WPTR);
+		writel_relaxed(col_mv_rd_start_addr, core->dos_base + HEVC_MPRED_MV_RPTR);
+	} else {
+		writel_relaxed(col_mv_rd_ptr, core->dos_base + HEVC_MPRED_MV_RPTR);
+	}
+
+	printk("col_mv_rd_end_addr = %08X\n", col_mv_rd_end_addr);
+	writel_relaxed(col_mv_rd_end_addr, core->dos_base + HEVC_MPRED_MV_RD_END_ADDR);
+}
+
+/*  motion compensation reference cache controller ; Only for first IDR frame for now */
+static void codec_hevc_set_mcrcc(struct vdec_session *sess )
+{
+	struct vdec_core *core = sess->core;
+
+	/* reset mcrcc */
+	writel_relaxed(0x02, core->dos_base + HEVCD_MCRCC_CTL1);
+	/* remove reset -- disables clock */
+	writel_relaxed(0x00, core->dos_base + HEVCD_MCRCC_CTL1);
+	/* enable mcrcc progressive-mode */
+	//writel_relaxed(0xff0, core->dos_base + HEVCD_MCRCC_CTL1);
+}
+
+static void codec_hevc_set_iPrevTid0POC(struct vdec_session *sess)
+{
 	struct codec_hevc *hevc = sess->priv;
 	u32 nal_unit_type = hevc->rpm_param.p.m_nalUnitType;
 	u32 temporal_id = hevc->rpm_param.p.m_temporalId;
+	int iMaxPOClsb =
+		1 << (hevc->rpm_param.p.
+		log2_max_pic_order_cnt_lsb_minus4 + 4);
+	int iPrevPOClsb;
+	int iPrevPOCmsb;
+	int iPOCmsb;
+	int iPOClsb = hevc->rpm_param.p.POClsb;
+
+	hevc->iPrevPOC = hevc->curr_poc;
 
 	if (nal_unit_type == NAL_UNIT_CODED_SLICE_IDR ||
 	    nal_unit_type == NAL_UNIT_CODED_SLICE_IDR_N_LP) {
 		hevc->curr_poc = 0;
 		if ((temporal_id - 1) == 0)
 			hevc->iPrevTid0POC = hevc->curr_poc;
-	} else {
-		int iMaxPOClsb =
-			1 << (hevc->rpm_param.p.
-			log2_max_pic_order_cnt_lsb_minus4 + 4);
-		int iPrevPOClsb;
-		int iPrevPOCmsb;
-		int iPOCmsb;
-		int iPOClsb = hevc->rpm_param.p.POClsb;
-
-		iPrevPOClsb = hevc->iPrevTid0POC % iMaxPOClsb;
-		iPrevPOCmsb = hevc->iPrevTid0POC - iPrevPOClsb;
-
-		if ((iPOClsb < iPrevPOClsb)
-			&& ((iPrevPOClsb - iPOClsb) >=
-				(iMaxPOClsb / 2)))
-			iPOCmsb = iPrevPOCmsb + iMaxPOClsb;
-		else if ((iPOClsb > iPrevPOClsb)
-				 && ((iPOClsb - iPrevPOClsb) >
-					 (iMaxPOClsb / 2)))
-			iPOCmsb = iPrevPOCmsb - iMaxPOClsb;
-		else
-			iPOCmsb = iPrevPOCmsb;
-
-		if (nal_unit_type == NAL_UNIT_CODED_SLICE_BLA   ||
-		    nal_unit_type == NAL_UNIT_CODED_SLICE_BLANT ||
-		    nal_unit_type == NAL_UNIT_CODED_SLICE_BLA_N_LP) {
-			/* For BLA picture types, POCmsb is set to 0. */
-			iPOCmsb = 0;
-		}
-		hevc->curr_poc = (iPOCmsb + iPOClsb);
-		if ((temporal_id - 1) == 0)
-			hevc->iPrevTid0POC = hevc->curr_poc;
+
+		return;
 	}
+
+	iPrevPOClsb = hevc->iPrevTid0POC % iMaxPOClsb;
+	iPrevPOCmsb = hevc->iPrevTid0POC - iPrevPOClsb;
+
+	if ((iPOClsb < iPrevPOClsb) && ((iPrevPOClsb - iPOClsb) >= (iMaxPOClsb / 2)))
+		iPOCmsb = iPrevPOCmsb + iMaxPOClsb;
+	else if ((iPOClsb > iPrevPOClsb) && ((iPOClsb - iPrevPOClsb) > (iMaxPOClsb / 2)))
+		iPOCmsb = iPrevPOCmsb - iMaxPOClsb;
+	else
+		iPOCmsb = iPrevPOCmsb;
+
+	if (nal_unit_type == NAL_UNIT_CODED_SLICE_BLA   ||
+	    nal_unit_type == NAL_UNIT_CODED_SLICE_BLANT ||
+	    nal_unit_type == NAL_UNIT_CODED_SLICE_BLA_N_LP)
+		iPOCmsb = 0; /* For BLA picture types, POCmsb is set to 0. */
+
+	hevc->curr_poc = (iPOCmsb + iPOClsb);
+	if ((temporal_id - 1) == 0)
+		hevc->iPrevTid0POC = hevc->curr_poc;
 }
 
-static void codec_hevc_process_segment_header(struct vdec_session *sess)
+static int codec_hevc_process_segment_header(struct vdec_session *sess)
 {
 	struct codec_hevc *hevc = sess->priv;
-	u32 nal_unit_type = hevc->rpm_param.p.m_nalUnitType;
-	u32 temporal_id = hevc->rpm_param.p.m_temporalId;
-	u32 slice_segment_address = hevc->rpm_param.p.slice_segment_address;
+	union rpm_param *param = &hevc->rpm_param;
+	u32 nal_unit_type = param->p.m_nalUnitType;
+	u32 temporal_id = param->p.m_temporalId;
+	u32 slice_segment_address = param->p.slice_segment_address;
 
 	printk("nal_unit_type = %u ; temporal_id = %u ; slice_seg_addr = %u\n",
 		nal_unit_type, temporal_id, slice_segment_address);
 
+	if (param->p.first_slice_segment_in_pic_flag == 0) {
+		printk("Oh yeah. %u %u\n", param->p.slice_segment_address, param->p.dependent_slice_segment_flag);
+		hevc->slice_segment_addr = param->p.slice_segment_address;
+		if (!param->p.dependent_slice_segment_flag)
+			hevc->slice_addr = hevc->slice_segment_addr;
+	} else {
+		hevc->slice_segment_addr = 0;
+		hevc->slice_addr = 0;
+	}
+
 	codec_hevc_set_iPrevTid0POC(sess);
+	printk("curr_poc = %u; iPrevPOC = %u; iPrevTid0POC = %u\n", hevc->curr_poc, hevc->iPrevPOC, hevc->iPrevTid0POC);
 
 	/* ? First slice: new frame ? */
-	if (slice_segment_address == 0)
-		codec_hevc_prepare_new_frame(sess);
+	if (slice_segment_address == 0) {
+		hevc->curr_frame = codec_hevc_prepare_new_frame(sess);
+		if (!hevc->curr_frame)
+			return -1;
+
+		codec_hevc_update_tiles(sess);
+		hevc->col_frame = hevc->curr_frame;
+	}
+
+	return 0;
 }
 
 /* The RPM raw data isn't really usable in its state.
  * There are many hi/lo fields, others must be processed
  * to actually get the relevant information, etc.
  */
-static void codec_hevc_process_rpm(struct codec_hevc *hevc)
+static void codec_hevc_process_rpm(struct vdec_session *sess)
 {
+	struct codec_hevc *hevc = sess->priv;
 	union rpm_param *rpm_param = &hevc->rpm_param;
+	u32 lcu_x_num_div, lcu_y_num_div;
 
 	hevc->lcu_size = 1 << (rpm_param->p.log2_min_coding_block_size_minus3 +
 		3 + rpm_param->p.log2_diff_max_min_coding_block_size);
+
+	lcu_x_num_div = (sess->width / hevc->lcu_size);
+	lcu_y_num_div = (sess->height / hevc->lcu_size);
+	hevc->lcu_x_num = ((sess->width % hevc->lcu_size) == 0) ? lcu_x_num_div : lcu_x_num_div + 1;
+	hevc->lcu_y_num = ((sess->height % hevc->lcu_size) == 0) ? lcu_y_num_div : lcu_y_num_div + 1;
+	hevc->lcu_total = hevc->lcu_x_num * hevc->lcu_y_num;
+
+	printk("lcu_size = %u ; lcu_size_log2 = %u; lcu_x_num = %u; lcu_y_num = %u; lcu_total = %u\n", hevc->lcu_size, ilog2(hevc->lcu_size), hevc->lcu_x_num, hevc->lcu_y_num, hevc->lcu_total);
+	printk("col_ref = %u\n", rpm_param->p.collocated_ref_idx);
 }
 
 /* The RPM section within the workspace contains
@@ -611,32 +1193,41 @@ static void codec_hevc_fetch_rpm(struct vdec_session *sess)
 {
 	struct codec_hevc *hevc = sess->priv;
 	u16 *rpm_vaddr = hevc->workspace_vaddr + RPM_OFFSET;
-	int i;
+	int i, j;
 
-	for (i = 0; i < (RPM_END - RPM_BEGIN); i += 4) {
-		int ii;
-		for (ii = 0; ii < 4; ii++) {
-			hevc->rpm_param.l.data[i + ii] = rpm_vaddr[i + 3 - ii];
-		}
-	}
+	for (i = 0; i < (RPM_END - RPM_BEGIN); i += 4)
+		for (j = 0; j < 4; j++)
+			hevc->rpm_param.l.data[i + j] = rpm_vaddr[i + 3 - j];
 
-	codec_hevc_process_rpm(hevc);
+	codec_hevc_process_rpm(sess);
 
-	printk("Size: %ux%u\n", hevc->rpm_param.p.pic_width_in_luma_samples,  hevc->rpm_param.p.pic_height_in_luma_samples);
+	printk("Size: %ux%u ; %ux%u\n", hevc->rpm_param.p.pic_width_in_luma_samples,  hevc->rpm_param.p.pic_height_in_luma_samples, sess->width, sess->height);
 }
 
 static irqreturn_t codec_hevc_isr(struct vdec_session *sess)
 {
 	u32 dec_status;
 	struct vdec_core *core = sess->core;
+	struct codec_hevc *hevc = sess->priv;
 
 	dec_status = readl_relaxed(core->dos_base + HEVC_DEC_STATUS_REG);
-	printk("codec_hevc_isr: %08X\n", dec_status);
+	printk("!!! codec_hevc_isr: %08X\n", dec_status);
+	printk("HEVC_SHIFT_BYTE_COUNT: %u\n", readl_relaxed(core->dos_base + HEVC_SHIFT_BYTE_COUNT));
+	printk("HEVC_PARSER_LCU_START: %u\n", readl_relaxed(core->dos_base + HEVC_PARSER_LCU_START) & 0xffffff);
 
 	if (dec_status == HEVC_SLICE_SEGMENT_DONE) {
-		writel_relaxed(readl_relaxed(core->dos_base + HEVC_WAIT_FLAG) | 2, core->dos_base + HEVC_WAIT_FLAG);
 		codec_hevc_fetch_rpm(sess);
+		codec_hevc_setup_buffers(sess);
 		codec_hevc_process_segment_header(sess);
+
+		writel_relaxed(readl_relaxed(core->dos_base + HEVC_WAIT_FLAG) | 2, core->dos_base + HEVC_WAIT_FLAG);
+
+		codec_hevc_update_frame_refs(sess, hevc->curr_frame);
+		codec_hevc_set_mcrcc(sess);
+		codec_hevc_set_mpred(sess, hevc->curr_frame, hevc->col_frame);
+		codec_hevc_set_sao(sess, hevc->curr_frame);
+
+		printk("Stream offset: %08X\n", readl_relaxed(core->dos_base + HEVC_SHIFT_BYTE_COUNT));
 		writel_relaxed(HEVC_CODED_SLICE_SEGMENT_DAT, core->dos_base + HEVC_DEC_STATUS_REG);
 		writel_relaxed(AMRISC_MAIN_REQ, core->dos_base + HEVC_MCPU_INTR_REQ);
 	}
@@ -648,5 +1239,4 @@ struct vdec_codec_ops codec_hevc_ops = {
 	.start = codec_hevc_start,
 	.stop = codec_hevc_stop,
 	.isr = codec_hevc_isr,
-};
-
+};
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/vdec.c b/drivers/media/platform/meson/vdec/vdec.c
index b31cc81..e91d193 100644
--- a/drivers/media/platform/meson/vdec/vdec.c
+++ b/drivers/media/platform/meson/vdec/vdec.c
@@ -36,7 +36,7 @@ static void vdec_abort(struct vdec_session *sess)
 
 static u32 get_output_size(u32 width, u32 height)
 {
-	return ALIGN(width, 64) * ALIGN(height, 64);
+	return ALIGN(width * height, 64 * SZ_1K);
 }
 
 u32 vdec_get_output_size(struct vdec_session *sess)
@@ -266,11 +266,11 @@ static const struct vdec_format vdec_formats[] = {
 		.pixfmt = V4L2_PIX_FMT_HEVC,
 		.num_planes = 1,
 		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
-		.min_buffers = 8,
-		.max_buffers = 32,
+		.min_buffers = 16,
+		.max_buffers = 16,
 		.vdec_ops = &vdec_hevc_ops,
 		.codec_ops = &codec_hevc_ops,
-		.firmware_path = "meson/gxl/vh265_mc_mmu",
+		.firmware_path = "meson/gxl/vh265_mc",
 	}, {
 		.pixfmt = V4L2_PIX_FMT_MPEG1,
 		.num_planes = 1,
diff --git a/drivers/media/platform/meson/vdec/vdec_hevc.c b/drivers/media/platform/meson/vdec/vdec_hevc.c
index bced612..1eb93d1 100644
--- a/drivers/media/platform/meson/vdec/vdec_hevc.c
+++ b/drivers/media/platform/meson/vdec/vdec_hevc.c
@@ -80,13 +80,15 @@ static void vdec_hevc_stbuf_init(struct vdec_session *sess)
 	printk("vdec_hevc_stbuf_init end\n");
 }
 
+/* VDEC_HEVC specific ESPARSER configuration */
 static void vdec_hevc_conf_esparser(struct vdec_session *sess)
 {
 	struct vdec_core *core = sess->core;
 
 	printk("vdec_hevc_conf_esparser\n");
-	/* VDEC_HEVC specific ESPARSER stuff */
-	writel_relaxed(3 << 1, core->dos_base + DOS_GEN_CTRL0); // set vififo_vbuf_rp_sel=>vdec_hevc
+
+	/* set vififo_vbuf_rp_sel=>vdec_hevc */
+	writel_relaxed(3 << 1, core->dos_base + DOS_GEN_CTRL0);
 	writel_relaxed(readl_relaxed(core->dos_base + HEVC_STREAM_CONTROL) | (1 << 3), core->dos_base + HEVC_STREAM_CONTROL);
 	writel_relaxed(readl_relaxed(core->dos_base + HEVC_STREAM_CONTROL) | 1, core->dos_base + HEVC_STREAM_CONTROL);
 	writel_relaxed(readl_relaxed(core->dos_base + HEVC_STREAM_FIFO_CTL) | (1 << 29), core->dos_base + HEVC_STREAM_FIFO_CTL);
@@ -127,12 +129,6 @@ static int vdec_hevc_start(struct vdec_session *sess)
 
 	codec_ops->start(sess);
 
-	writel_relaxed((1<<12)|(1<<11), core->dos_base + DOS_SW_RESET3);
-	writel_relaxed(0, core->dos_base + DOS_SW_RESET3);
-	readl_relaxed(core->dos_base + DOS_SW_RESET3);
-
-	writel_relaxed(1, core->dos_base + HEVC_MPSR);
-
 	printk("vdec_hevc_start end\n");
 
 	return 0;
diff --git a/drivers/soc/amlogic/meson-pwrc-vdec.c b/drivers/soc/amlogic/meson-pwrc-vdec.c
index 752ebb9..8aeb03e 100644
--- a/drivers/soc/amlogic/meson-pwrc-vdec.c
+++ b/drivers/soc/amlogic/meson-pwrc-vdec.c
@@ -17,6 +17,7 @@
 /* AO Offsets */
 #define AO_RTI_GEN_PWR_SLEEP0 (0x3a << 2)
 
+//#define GEN_PWR_VDEC_1 (BIT(7) | BIT(6))
 #define GEN_PWR_VDEC_1 (BIT(3) | BIT(2))
 
 struct meson_pwrc_vdec {
@@ -25,6 +26,7 @@ struct meson_pwrc_vdec {
 	struct clk *dos_parser_clk;
 	struct clk *vpu_intr_clk;
 	struct clk *vdec_1_clk;
+	struct clk *vdec_hevc_clk;
 };
 
 static inline
@@ -45,6 +47,7 @@ static int meson_pwrc_vdec_power_off(struct generic_pm_domain *genpd)
 	//clk_disable_unprepare(pd->vpu_intr_clk);
 	clk_disable_unprepare(pd->dos_parser_clk);
 	clk_disable_unprepare(pd->vdec_1_clk);
+	//clk_disable_unprepare(pd->vdec_hevc_clk);
 
 	return 0;
 }
@@ -54,6 +57,7 @@ static int meson_pwrc_vdec_setup_clk(struct meson_pwrc_vdec *pd) {
 	clk_prepare_enable(pd->dos_parser_clk);
 	//clk_prepare_enable(pd->vpu_intr_clk);
 	clk_prepare_enable(pd->vdec_1_clk);
+	//clk_prepare_enable(pd->vdec_hevc_clk);
 
 	return 0;
 }
@@ -104,6 +108,7 @@ static int meson_pwrc_vdec_probe(struct platform_device *pdev)
 	vdec_pd.vpu_intr_clk = devm_clk_get(&pdev->dev, "vpu_intr");
 	vdec_pd.dos_parser_clk = devm_clk_get(&pdev->dev, "dos_parser");
 	vdec_pd.vdec_1_clk = devm_clk_get(&pdev->dev, "vdec_1");
+	vdec_pd.vdec_hevc_clk = devm_clk_get(&pdev->dev, "vdec_hevc");
 	vdec_pd.regmap_ao = regmap_ao;
 
 	powered_off = meson_pwrc_vdec_get_power(&vdec_pd);
diff --git a/vh265_mc b/vh265_mc
index 8f127a242a5d46ba071881e01c4b3c322c1e8c07..e2ba47431e867c020e8af18fb9ce4805544c9350 100644
GIT binary patch
delta 12
TcmZo@U~Fh$-0;VKq5}&6AY25)

delta 14
TcmZo@U~Fh$-0;Vq#Q+EZC-nrf

