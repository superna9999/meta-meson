From 5ffd0e0f1fa3fc4456f34201c0f981c9177cd459 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 5 May 2017 13:54:06 +0800
Subject: [PATCH 058/134] drm/lima: zap mmu when va unmap

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 drivers/gpu/drm/lima/lima.h     |  2 ++
 drivers/gpu/drm/lima/lima_mmu.c | 26 ++++++++++++++++++++++++--
 drivers/gpu/drm/lima/lima_vm.c  | 18 +++++++++++++-----
 3 files changed, 39 insertions(+), 7 deletions(-)

diff --git a/drivers/gpu/drm/lima/lima.h b/drivers/gpu/drm/lima/lima.h
index fd1b72d..7cdccc8 100644
--- a/drivers/gpu/drm/lima/lima.h
+++ b/drivers/gpu/drm/lima/lima.h
@@ -55,6 +55,7 @@ struct lima_mmu {
 
 	spinlock_t lock;
 	struct lima_vm *vm;
+	bool zap_all;
 };
 
 struct lima_gp {
@@ -113,6 +114,7 @@ void lima_l2_cache_fini(struct lima_l2_cache *l2_cache);
 int lima_mmu_init(struct lima_mmu *mmu);
 void lima_mmu_fini(struct lima_mmu *mmu);
 void lima_mmu_switch_vm(struct lima_mmu *mmu, struct lima_vm *vm, bool reset);
+void lima_mmu_zap_vm(struct lima_mmu *mmu, struct lima_vm *vm, u32 va, u32 size);
 
 int lima_gp_init(struct lima_gp *gp);
 void lima_gp_fini(struct lima_gp *gp);
diff --git a/drivers/gpu/drm/lima/lima_mmu.c b/drivers/gpu/drm/lima/lima_mmu.c
index a80e783..77da644 100644
--- a/drivers/gpu/drm/lima/lima_mmu.c
+++ b/drivers/gpu/drm/lima/lima_mmu.c
@@ -100,6 +100,7 @@ int lima_mmu_init(struct lima_mmu *mmu)
 
 	mmu->vm = dev->empty_vm;
 	spin_lock_init(&mmu->lock);
+	mmu->zap_all = false;
 
 	return 0;
 }
@@ -118,19 +119,40 @@ void lima_mmu_switch_vm(struct lima_mmu *mmu, struct lima_vm *vm, bool reset)
 	if (mmu->vm == vm) {
 		if (reset)
 			vm = dev->empty_vm;
-		else
+		else if (!mmu->zap_all)
 			goto out;
 	}
 
 	lima_mmu_send_command(LIMA_MMU_COMMAND_ENABLE_STALL,
 			      mmu_read(STATUS) & LIMA_MMU_STATUS_STALL_ACTIVE);
-	mmu_write(DTE_ADDR, vm->pd.dma);
+
+	if (mmu->vm != vm)
+		mmu_write(DTE_ADDR, vm->pd.dma);
+
 	/* flush the TLB */
 	mmu_write(COMMAND, LIMA_MMU_COMMAND_ZAP_CACHE);
+
 	lima_mmu_send_command(LIMA_MMU_COMMAND_DISABLE_STALL,
 			      !(mmu_read(STATUS) & LIMA_MMU_STATUS_STALL_ACTIVE));
+
 	mmu->vm = vm;
+	mmu->zap_all = false;
 
 out:
 	spin_unlock(&mmu->lock);
 }
+
+void lima_mmu_zap_vm(struct lima_mmu *mmu, struct lima_vm *vm, u32 va, u32 size)
+{
+	/* TODO: use LIMA_MMU_ZAP_ONE_LINE to just zap a PDE
+         * needs to investigate:
+         * 1. if LIMA_MMU_ZAP_ONE_LINE need stall mmu, otherwise we can zap it here
+         * 2. how many PDE when LIMA_MMU_ZAP_ONE_LINE is better than zap all,
+         *    otherwise we can use zap all when exceeds that limit
+         */
+
+	spin_lock(&mmu->lock);
+	if (mmu->vm == vm)
+	        mmu->zap_all = true;
+	spin_unlock(&mmu->lock);
+}
diff --git a/drivers/gpu/drm/lima/lima_vm.c b/drivers/gpu/drm/lima/lima_vm.c
index f1d9295..e5cf8dc 100644
--- a/drivers/gpu/drm/lima/lima_vm.c
+++ b/drivers/gpu/drm/lima/lima_vm.c
@@ -97,25 +97,26 @@ int lima_vm_map(struct lima_vm *vm, dma_addr_t dma, u32 va, u32 size)
 
 int lima_vm_unmap(struct lima_vm *vm, u32 va, u32 size)
 {
-	int err = 0;
+	int err, i;
 	struct interval_tree_node *it;
 	u32 addr;
+	struct lima_device *dev = vm->dev;
 
 	mutex_lock(&vm->lock);
 
 	it = interval_tree_iter_first(&vm->va, va, va + size - 1);
 	if (it) {
 		if (it->start != va || it->last != va + size - 1) {
-			dev_err(vm->dev->dev, "lima vm unmap va not match %x-%x %lx-%lx\n",
+			dev_err(dev->dev, "lima vm unmap va not match %x-%x %lx-%lx\n",
 				va, va + size -1, it->start, it->last);
 			err = -EINVAL;
-			goto out;
+			goto err_out;
 		}
 		interval_tree_remove(it, &vm->va);
 		kfree(it);
 	}
 	else
-		goto out;
+		goto err_out;
 
 	for (addr = va; addr < va + size; addr += LIMA_PAGE_SIZE) {
 		u32 pde = LIMA_PDE(addr);
@@ -123,7 +124,14 @@ int lima_vm_unmap(struct lima_vm *vm, u32 va, u32 size)
 		vm->pts[pde].cpu[pte] = 0;
 	}
 
-out:
+	mutex_unlock(&vm->lock);
+
+	for (i = 0; i < dev->num_pipe; i++)
+		lima_mmu_zap_vm(dev->pipe[i]->mmu, vm, va, size);
+
+	return 0;
+
+err_out:
 	mutex_unlock(&vm->lock);
 	return err;
 }
-- 
2.0.1

