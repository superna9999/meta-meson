From 76b526f51a94da2def1ad8ad14d59447a732c248 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 9 May 2017 16:23:28 +0800
Subject: [PATCH] drm/lima: real gp task finish dma fence signal

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 drivers/gpu/drm/lima/lima.h       |  5 ++++
 drivers/gpu/drm/lima/lima_gp.c    | 51 ++++++++++++++++++++++++-------
 drivers/gpu/drm/lima/lima_pp.c    |  9 ++++++
 drivers/gpu/drm/lima/lima_sched.c | 63 ++++++++++++++++++++++++++++++++++-----
 drivers/gpu/drm/lima/lima_sched.h |  2 ++
 5 files changed, 112 insertions(+), 18 deletions(-)

diff --git a/drivers/gpu/drm/lima/lima.h b/drivers/gpu/drm/lima/lima.h
index 7cdccc8..e36a814 100644
--- a/drivers/gpu/drm/lima/lima.h
+++ b/drivers/gpu/drm/lima/lima.h
@@ -58,10 +58,15 @@ struct lima_mmu {
 	bool zap_all;
 };
 
+#define LIMA_GP_TASK_VS    0x01
+#define LIMA_GP_TASK_PLBU  0x02
+
 struct lima_gp {
 	struct lima_ip ip;
 	struct lima_mmu mmu;
 	struct lima_sched_pipe pipe;
+
+	int task;
 };
 
 struct lima_pp {
diff --git a/drivers/gpu/drm/lima/lima_gp.c b/drivers/gpu/drm/lima/lima_gp.c
index 85293a4..5ae79b9 100644
--- a/drivers/gpu/drm/lima/lima_gp.c
+++ b/drivers/gpu/drm/lima/lima_gp.c
@@ -102,8 +102,23 @@ static irqreturn_t lima_gp_irq_handler(int irq, void *data)
 	struct lima_device *dev = gp->ip.dev;
 	u32 state = gp_read(INT_STAT);
 	u32 status = gp_read(STATUS);
+	bool task_done = false;
 
 	dev_info_ratelimited(dev->dev, "gp irq state=%x status=%x\n", state, status);
+
+	if (state & LIMA_GP_IRQ_VS_END_CMD_LST) {
+		gp->task &= ~LIMA_GP_TASK_VS;
+		task_done = true;
+	}
+
+	if (state & LIMA_GP_IRQ_PLBU_END_CMD_LST) {
+		gp->task &= ~LIMA_GP_TASK_PLBU;
+		task_done = true;
+	}
+
+	if (task_done && !gp->task)
+		lima_sched_pipe_task_done(&gp->pipe);
+
 	gp_write(INT_CLEAR, state);
 	return IRQ_NONE;
 }
@@ -114,17 +129,22 @@ static int lima_gp_start_task(void *data, struct lima_sched_task *task)
 	struct drm_lima_m400_gp_frame *frame = task->frame;
 	u32 cmd = 0;
 
-	DRM_INFO("lima start task gp %s\n", gp->ip.name);
+	DRM_INFO("lima start task gp status %08x\n", gp_read(STATUS));
 
 	if (frame->vs_cmd_start > frame->vs_cmd_end ||
 	    frame->plbu_cmd_start > frame->plbu_cmd_end ||
 	    frame->tile_heap_start > frame->tile_heap_end)
 		return -EINVAL;
 
-	if (frame->vs_cmd_start != frame->vs_cmd_end)
+	gp->task = 0;
+	if (frame->vs_cmd_start != frame->vs_cmd_end) {
 		cmd |= LIMA_GP_CMD_START_VS;
-	if (frame->plbu_cmd_start != frame->plbu_cmd_end)
+		gp->task |= LIMA_GP_TASK_VS;
+	}
+	if (frame->plbu_cmd_start != frame->plbu_cmd_end) {
 		cmd |= LIMA_GP_CMD_START_PLBU;
+		gp->task |= LIMA_GP_TASK_PLBU;
+	}
 
 	gp_write(VSCL_START_ADDR, frame->vs_cmd_start);
 	gp_write(VSCL_END_ADDR, frame->vs_cmd_end);
@@ -135,15 +155,14 @@ static int lima_gp_start_task(void *data, struct lima_sched_task *task)
 
 	gp_write(CMD, LIMA_GP_CMD_UPDATE_PLBU_ALLOC);
 	gp_write(CMD, cmd);
-
-	dma_fence_signal(task->fence);
 	return 0;
 }
 
-int lima_gp_init(struct lima_gp *gp)
+static int lima_gp_reset(void *data)
 {
+	struct lima_gp *gp = data;
 	struct lima_device *dev = gp->ip.dev;
-	int timeout, err;
+	int timeout;
 
 	gp_write(INT_MASK, 0);
 	gp_write(INT_CLEAR, LIMA_GP_IRQ_RESET_COMPLETED);
@@ -157,6 +176,20 @@ int lima_gp_init(struct lima_gp *gp)
 		return -ETIMEDOUT;
 	}
 
+	gp_write(INT_CLEAR, LIMA_GP_IRQ_MASK_ALL);
+	gp_write(INT_MASK, LIMA_GP_IRQ_MASK_USED);
+	return 0;
+}
+
+int lima_gp_init(struct lima_gp *gp)
+{
+	struct lima_device *dev = gp->ip.dev;
+	int err;
+
+	err = lima_gp_reset(gp);
+	if (err)
+		return err;
+
 	err = devm_request_irq(dev->dev, gp->ip.irq, lima_gp_irq_handler, 0,
 			       gp->ip.name, gp);
 	if (err) {
@@ -164,10 +197,8 @@ int lima_gp_init(struct lima_gp *gp)
 		return err;
 	}
 
-	gp_write(INT_CLEAR, LIMA_GP_IRQ_MASK_ALL);
-	gp_write(INT_MASK, LIMA_GP_IRQ_MASK_USED);
-
 	gp->pipe.start_task = lima_gp_start_task;
+	gp->pipe.reset = lima_gp_reset;
 	gp->pipe.data = gp;
 	gp->pipe.mmu = &gp->mmu;
 	return 0;
diff --git a/drivers/gpu/drm/lima/lima_pp.c b/drivers/gpu/drm/lima/lima_pp.c
index 03b147c..0d1795c 100644
--- a/drivers/gpu/drm/lima/lima_pp.c
+++ b/drivers/gpu/drm/lima/lima_pp.c
@@ -9,9 +9,18 @@ static int lima_pp_start_task(void *data, struct lima_sched_task *task)
 	return 0;
 }
 
+static int lima_pp_reset(void *data)
+{
+	struct lima_pp *pp = data;
+
+	DRM_INFO("lima reset pp %s\n", pp->ip.name);
+	return 0;
+}
+
 int lima_pp_init(struct lima_pp *pp)
 {
 	pp->pipe.start_task = lima_pp_start_task;
+	pp->pipe.reset = lima_pp_reset;
 	pp->pipe.data = pp;
 	pp->pipe.mmu = &pp->mmu;
 	return 0;
diff --git a/drivers/gpu/drm/lima/lima_sched.c b/drivers/gpu/drm/lima/lima_sched.c
index 885cdc6..fc815ae 100644
--- a/drivers/gpu/drm/lima/lima_sched.c
+++ b/drivers/gpu/drm/lima/lima_sched.c
@@ -148,13 +148,43 @@ static struct lima_sched_task *lima_sched_pipe_get_task(struct lima_sched_pipe *
 	return task;
 }
 
+#define LIMA_WORKER_WAIT_TIMEOUT_NS 1000000000
+
+static int lima_sched_pipe_worker_wait_fence(struct dma_fence *fence)
+{
+	int ret;
+	unsigned long timeout = nsecs_to_jiffies(LIMA_WORKER_WAIT_TIMEOUT_NS);
+
+	while (1) {
+		ret = dma_fence_wait_timeout(fence, true, timeout);
+
+		/* interrupted by signal, may be kthread stop */
+		if (ret == -ERESTARTSYS) {
+			if (kthread_should_stop())
+				return ret;
+			else
+				continue;
+		}
+
+		if (ret < 0)
+			return ret;
+
+		if (!ret)
+			return -ETIMEDOUT;
+
+		return 0;
+	}
+
+	return 0;
+}
+
 static int lima_sched_pipe_worker(void *param)
 {
 	struct lima_sched_pipe *pipe = param;
 	struct lima_sched_task *task;
 
 	while (!kthread_should_stop()) {
-		int i;
+		int i, ret;
 		unsigned long saved_flags;
 
 		wait_event_interruptible(pipe->worker_wait,
@@ -166,22 +196,28 @@ static int lima_sched_pipe_worker(void *param)
 
 		/* wait all dependent fence be signaled */
 		for (i = 0; i < task->num_dep; i++) {
-			/* interrupted by signal, may be kthread stop, ignore other error */
-			while (dma_fence_wait(task->dep[i], true) == -ERESTARTSYS) {
-				if (kthread_should_stop())
-					return 0;
+			ret = lima_sched_pipe_worker_wait_fence(task->dep[i]);
+			if (ret == -ERESTARTSYS)
+				return 0;
+			if (ret < 0) {
+				DRM_INFO("lima worker wait dep fence error %d\n", ret);
+				goto abort;
 			}
 		}
 
 		lima_mmu_switch_vm(pipe->mmu, task->vm, false);
 
 		if (!pipe->start_task(pipe->data, task)) {
-			while (dma_fence_wait(task->fence, true) == -ERESTARTSYS) {
-				if (kthread_should_stop())
-					return 0;
+			ret = lima_sched_pipe_worker_wait_fence(task->fence);
+			if (ret == -ERESTARTSYS)
+				return 0;
+			if (ret < 0) {
+				DRM_INFO("lima worker wait task fence error %d\n", ret);
+				pipe->reset(pipe->data);
 			}
 		}
 
+	abort:
 		spin_lock_irqsave(&pipe->lock, saved_flags);
 		list_del(&task->list);
 		spin_unlock_irqrestore(&pipe->lock, saved_flags);
@@ -294,3 +330,14 @@ int lima_sched_pipe_wait_fence(struct lima_sched_pipe *pipe, u32 fence, u64 time
 
 	return ret;
 }
+
+void lima_sched_pipe_task_done(struct lima_sched_pipe *pipe)
+{
+	struct lima_sched_task *task;
+
+	spin_lock(&pipe->lock);
+	task = list_first_entry(&pipe->queue, struct lima_sched_task, list);
+	spin_unlock(&pipe->lock);
+
+	dma_fence_signal(task->fence);
+}
diff --git a/drivers/gpu/drm/lima/lima_sched.h b/drivers/gpu/drm/lima/lima_sched.h
index 4508d19..dbf645d 100644
--- a/drivers/gpu/drm/lima/lima_sched.h
+++ b/drivers/gpu/drm/lima/lima_sched.h
@@ -54,6 +54,7 @@ struct lima_sched_pipe {
 	u32 fence_done_seqno;
 
 	int (*start_task)(void *data, struct lima_sched_task *task);
+	int (*reset)(void *data);
 	void *data;
 };
 
@@ -65,5 +66,6 @@ int lima_sched_task_queue(struct lima_sched_pipe *pipe, struct lima_sched_task *
 int lima_sched_pipe_init(struct lima_sched_pipe *pipe, const char *name);
 void lima_sched_pipe_fini(struct lima_sched_pipe *pipe);
 int lima_sched_pipe_wait_fence(struct lima_sched_pipe *pipe, u32 fence, u64 timeout_ns);
+void lima_sched_pipe_task_done(struct lima_sched_pipe *pipe);
 
 #endif
