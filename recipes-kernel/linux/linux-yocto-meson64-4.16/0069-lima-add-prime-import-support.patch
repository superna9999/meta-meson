From fd341050013b3e87cc798f93f6846f489e893ffc Mon Sep 17 00:00:00 2001
From: Erico Nunes <nunes.erico@gmail.com>
Date: Wed, 27 Sep 2017 23:37:36 +0200
Subject: [PATCH] lima: add prime import support

This enables lima to import a shared buffer from a dma_buf handle using
the DRM prime infrastructure.
With this, it is possible to allocate a dumb buffer with a display
driver to render to a display.
We can mostly use helper DRM callbacks, but gem_prime_import_sg_table
must have a custom function because we must allocate a lima_bo structure
and initialize custom fields other than the drm_gem_object.

This was tested on the Allwinner A20 with the sun4i-drm driver, along
with lima.

Signed-off-by: Erico Nunes <nunes.erico@gmail.com>
---
 drivers/gpu/drm/lima/lima.h     |  3 ++
 drivers/gpu/drm/lima/lima_drv.c |  7 +++-
 drivers/gpu/drm/lima/lima_gem.c | 74 ++++++++++++++++++++++++++++-------------
 3 files changed, 59 insertions(+), 25 deletions(-)

diff --git a/drivers/gpu/drm/lima/lima.h b/drivers/gpu/drm/lima/lima.h
index cb60709c..c79877f 100644
--- a/drivers/gpu/drm/lima/lima.h
+++ b/drivers/gpu/drm/lima/lima.h
@@ -149,6 +149,9 @@ int lima_gem_submit(struct drm_file *file, struct lima_sched_pipe *pipe,
 		    struct drm_lima_gem_submit_bo *bos, u32 nr_bos,
 		    void *frame, u32 *fence);
 int lima_gem_wait(struct drm_file *file, u32 handle, u32 op, u64 timeout_ns);
+struct drm_gem_object *lima_gem_prime_import_sg_table(struct drm_device *dev,
+						      struct dma_buf_attachment *attach,
+						      struct sg_table *sgt);
 
 unsigned long lima_timeout_to_jiffies(u64 timeout_ns);
 
diff --git a/drivers/gpu/drm/lima/lima_drv.c b/drivers/gpu/drm/lima/lima_drv.c
index 89c2ec7..43092b0 100644
--- a/drivers/gpu/drm/lima/lima_drv.c
+++ b/drivers/gpu/drm/lima/lima_drv.c
@@ -1,5 +1,6 @@
 #include <linux/module.h>
 #include <linux/of_platform.h>
+#include <drm/drm_prime.h>
 
 #include "lima.h"
 
@@ -200,7 +201,7 @@ static const struct file_operations lima_drm_driver_fops = {
 };
 
 static struct drm_driver lima_drm_driver = {
-	.driver_features    = DRIVER_RENDER | DRIVER_GEM,
+	.driver_features    = DRIVER_RENDER | DRIVER_GEM | DRIVER_PRIME,
 	.open               = lima_drm_driver_open,
 	.postclose          = lima_drm_driver_postclose,
 	.ioctls             = lima_drm_driver_ioctls,
@@ -213,6 +214,10 @@ static struct drm_driver lima_drm_driver = {
 	.date               = "20170325",
 	.major              = 1,
 	.minor              = 0,
+
+	.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
+	.gem_prime_import   = drm_gem_prime_import,
+	.gem_prime_import_sg_table = lima_gem_prime_import_sg_table,
 };
 
 static int lima_pdev_probe(struct platform_device *pdev)
diff --git a/drivers/gpu/drm/lima/lima_gem.c b/drivers/gpu/drm/lima/lima_gem.c
index 8cd238f..2158331 100644
--- a/drivers/gpu/drm/lima/lima_gem.c
+++ b/drivers/gpu/drm/lima/lima_gem.c
@@ -1,5 +1,6 @@
 #include <drm/drmP.h>
 #include <drm/drm_gem.h>
+#include <linux/dma-buf.h>
 #include <linux/dma-mapping.h>
 #include <linux/reservation.h>
 
@@ -19,7 +20,9 @@ struct lima_bo {
 	struct mutex lock;
 	struct list_head va;
 
-	struct reservation_object resv;
+	/* normally (resv == &_resv) except for imported bo's */
+	struct reservation_object *resv;
+	struct reservation_object _resv;
 };
 
 static inline
@@ -47,22 +50,14 @@ static struct lima_bo *lima_gem_create_bo(struct drm_device *dev, u32 size, u32
 
 	mutex_init(&bo->lock);
 	INIT_LIST_HEAD(&bo->va);
-	reservation_object_init(&bo->resv);
+	reservation_object_init(&bo->_resv);
 
 	err = drm_gem_object_init(dev, &bo->gem, size);
 	if (err)
 		goto err_out0;
 
-	bo->cpu_addr = dma_alloc_coherent(dev->dev, size, &bo->dma_addr, GFP_USER);
-	if (!bo->cpu_addr) {
-		err = -ENOMEM;
-		goto err_out1;
-	}
-
 	return bo;
 
-err_out1:
-	drm_gem_object_release(&bo->gem);
 err_out0:
 	kfree(bo);
 	return ERR_PTR(err);
@@ -78,12 +73,24 @@ int lima_gem_create_handle(struct drm_device *dev, struct drm_file *file,
 	if (IS_ERR(bo))
 		return PTR_ERR(bo);
 
+	bo->cpu_addr = dma_alloc_coherent(dev->dev, size, &bo->dma_addr, GFP_USER);
+	if (!bo->cpu_addr) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	bo->resv = &bo->_resv;
+
 	err = drm_gem_handle_create(file, &bo->gem, handle);
 
 	/* drop reference from allocate - handle holds it now */
 	drm_gem_object_unreference_unlocked(&bo->gem);
 
 	return err;
+
+err_out:
+	lima_gem_free_object(&bo->gem);
+	return err;
 }
 
 void lima_gem_free_object(struct drm_gem_object *obj)
@@ -97,8 +104,10 @@ void lima_gem_free_object(struct drm_gem_object *obj)
 		kfree(bo_va);
 	}
 
-	dma_free_coherent(obj->dev->dev, obj->size, bo->cpu_addr, bo->dma_addr);
-	reservation_object_fini(&bo->resv);
+	if (!obj->import_attach)
+		dma_free_coherent(obj->dev->dev, obj->size, bo->cpu_addr, bo->dma_addr);
+
+	reservation_object_fini(&bo->_resv);
 	drm_gem_object_release(obj);
 	kfree(bo);
 }
@@ -263,7 +272,7 @@ static int lima_gem_lock_bos(struct lima_bo **bos, u32 nr_bos,
 			continue;
 		}
 
-		ret = ww_mutex_lock_interruptible(&bos[i]->resv.lock, ctx);
+		ret = ww_mutex_lock_interruptible(&bos[i]->resv->lock, ctx);
 		if (ret < 0) {
 			contended = i;
 			goto err;
@@ -275,14 +284,14 @@ static int lima_gem_lock_bos(struct lima_bo **bos, u32 nr_bos,
 
 err:
 	for (i--; i >= 0; i--)
-		ww_mutex_unlock(&bos[i]->resv.lock);
+		ww_mutex_unlock(&bos[i]->resv->lock);
 
 	if (slow_locked >= 0)
-		ww_mutex_unlock(&bos[slow_locked]->resv.lock);
+		ww_mutex_unlock(&bos[slow_locked]->resv->lock);
 
 	if (ret == -EDEADLK) {
 		/* we lost out in a seqno race, lock and retry.. */
-		ret = ww_mutex_lock_slow_interruptible(&bos[contended]->resv.lock, ctx);
+		ret = ww_mutex_lock_slow_interruptible(&bos[contended]->resv->lock, ctx);
 		if (!ret) {
 			slow_locked = contended;
 			goto retry;
@@ -301,12 +310,12 @@ static int lima_gem_sync_bo(struct lima_sched_task *task, u64 context,
 
 	if (write) {
 		struct reservation_object_list *fobj =
-			reservation_object_get_list(&bo->resv);
+			reservation_object_get_list(bo->resv);
 
 		if (fobj && fobj->shared_count > 0) {
 			for (i = 0; i < fobj->shared_count; i++) {
 				f = rcu_dereference_protected(
-					fobj->shared[i], reservation_object_held(&bo->resv));
+					fobj->shared[i], reservation_object_held(bo->resv));
 				if (f->context != context) {
 					err = lima_sched_task_add_dep(task, f);
 					if (err)
@@ -316,7 +325,7 @@ static int lima_gem_sync_bo(struct lima_sched_task *task, u64 context,
 		}
 	}
 
-	f = reservation_object_get_excl(&bo->resv);
+	f = reservation_object_get_excl(bo->resv);
 	if (f) {
 		err = lima_sched_task_add_dep(task, f);
 		if (err)
@@ -324,7 +333,7 @@ static int lima_gem_sync_bo(struct lima_sched_task *task, u64 context,
 	}
 
 	if (!write) {
-		err = reservation_object_reserve_shared(&bo->resv);
+		err = reservation_object_reserve_shared(bo->resv);
 		if (err)
 			return err;
 	}
@@ -380,9 +389,9 @@ int lima_gem_submit(struct drm_file *file, struct lima_sched_pipe *pipe,
 
 	for (i = 0; i < nr_bos; i++) {
 		if (bos[i].flags & LIMA_SUBMIT_BO_WRITE)
-			reservation_object_add_excl_fence(&lbos[i]->resv, task->fence);
+			reservation_object_add_excl_fence(lbos[i]->resv, task->fence);
 		else
-			reservation_object_add_shared_fence(&lbos[i]->resv, task->fence);
+			reservation_object_add_shared_fence(lbos[i]->resv, task->fence);
 	}
 	dma_fence_put(task->fence);
 
@@ -393,7 +402,7 @@ int lima_gem_submit(struct drm_file *file, struct lima_sched_pipe *pipe,
 		lima_sched_task_delete(task);
 out1:
 	for (i = 0; i < nr_bos; i++)
-		ww_mutex_unlock(&lbos[i]->resv.lock);
+		ww_mutex_unlock(&lbos[i]->resv->lock);
 	ww_acquire_fini(&ctx);
 out0:
 	for (i = 0; i < nr_bos && lbos[i]; i++)
@@ -417,7 +426,7 @@ int lima_gem_wait(struct drm_file *file, u32 handle, u32 op, u64 timeout_ns)
 	bo = to_lima_bo(obj);
 
 	timeout = timeout_ns ? lima_timeout_to_jiffies(timeout_ns) : 0;
-	ret = reservation_object_wait_timeout_rcu(&bo->resv, write, true, timeout);
+	ret = reservation_object_wait_timeout_rcu(bo->resv, write, true, timeout);
 	if (ret == 0)
 		ret = timeout ? -ETIMEDOUT : -EBUSY;
 	else if (ret > 0)
@@ -426,3 +435,20 @@ int lima_gem_wait(struct drm_file *file, u32 handle, u32 op, u64 timeout_ns)
 	drm_gem_object_unreference_unlocked(obj);
 	return ret;
 }
+
+struct drm_gem_object *lima_gem_prime_import_sg_table(struct drm_device *dev,
+						      struct dma_buf_attachment *attach,
+						      struct sg_table *sgt)
+{
+	struct lima_bo *bo;
+	dma_addr_t dma_addr = sg_dma_address(sgt->sgl);
+
+	bo = lima_gem_create_bo(dev, attach->dmabuf->size, 0);
+	if (!bo)
+		return ERR_PTR(-ENOMEM);
+
+	bo->dma_addr = dma_addr;
+	bo->resv = attach->dmabuf->resv;
+
+	return &bo->gem;
+}
