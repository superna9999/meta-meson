From 3fada3bde47b24bfe7d9b1083b22704103546171 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 29 May 2017 11:29:37 +0800
Subject: [PATCH] drm/lima: use wait queue instead of dma_fence for busy wait

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 drivers/gpu/drm/lima/lima_sched.c | 75 ++++++++++++++++++++++++++-------------
 drivers/gpu/drm/lima/lima_sched.h |  5 ++-
 2 files changed, 55 insertions(+), 25 deletions(-)

diff --git a/drivers/gpu/drm/lima/lima_sched.c b/drivers/gpu/drm/lima/lima_sched.c
index dfe6226..7fff6f1 100644
--- a/drivers/gpu/drm/lima/lima_sched.c
+++ b/drivers/gpu/drm/lima/lima_sched.c
@@ -111,7 +111,6 @@ int lima_sched_task_add_dep(struct lima_sched_task *task, struct dma_fence *fenc
 
 int lima_sched_task_queue(struct lima_sched_pipe *pipe, struct lima_sched_task *task)
 {
-	unsigned long saved_flags;
 	struct lima_fence *fence;
 
 	fence = kzalloc(sizeof(*fence), GFP_KERNEL);
@@ -119,7 +118,7 @@ int lima_sched_task_queue(struct lima_sched_pipe *pipe, struct lima_sched_task *
 		return -ENOMEM;
 	fence->pipe = pipe;
 
-	spin_lock_irqsave(&pipe->lock, saved_flags);
+	spin_lock(&pipe->lock);
 
 	dma_fence_init(&fence->base, &lima_fence_ops, &pipe->fence_lock,
 		       pipe->fence_context, ++pipe->fence_seqno);
@@ -131,20 +130,19 @@ int lima_sched_task_queue(struct lima_sched_pipe *pipe, struct lima_sched_task *
 
 	list_add_tail(&task->list, &pipe->queue);
 
-	spin_unlock_irqrestore(&pipe->lock, saved_flags);
+	spin_unlock(&pipe->lock);
 
-	wake_up(&pipe->worker_wait);
+	wake_up(&pipe->worker_idle_wait);
 	return 0;
 }
 
 static struct lima_sched_task *lima_sched_pipe_get_task(struct lima_sched_pipe *pipe)
 {
-	unsigned long saved_flags;
 	struct lima_sched_task *task;
 
-	spin_lock_irqsave(&pipe->lock, saved_flags);
+	spin_lock(&pipe->lock);
 	task = list_first_entry_or_null(&pipe->queue, struct lima_sched_task, list);
-	spin_unlock_irqrestore(&pipe->lock, saved_flags);
+	spin_unlock(&pipe->lock);
 	return task;
 }
 
@@ -178,6 +176,37 @@ static int lima_sched_pipe_worker_wait_fence(struct dma_fence *fence)
 	return 0;
 }
 
+static int lima_sched_pipe_worker_wait_busy(struct lima_sched_pipe *pipe)
+{
+	int ret;
+	unsigned long timeout = nsecs_to_jiffies(LIMA_WORKER_WAIT_TIMEOUT_NS);
+
+	while (1) {
+		ret = wait_event_interruptible_timeout(
+			pipe->worker_busy_wait,
+			!pipe->worker_is_busy || kthread_should_stop(),
+			timeout);
+
+		/* interrupted by signal, may be kthread stop */
+		if (ret == -ERESTARTSYS) {
+			if (kthread_should_stop())
+				return ret;
+			else
+				continue;
+		}
+
+		if (ret < 0)
+			return ret;
+
+		if (!ret)
+			return -ETIMEDOUT;
+
+		return 0;
+	}
+
+	return 0;
+}
+
 static int lima_sched_pipe_worker(void *param)
 {
 	struct lima_sched_pipe *pipe = param;
@@ -185,9 +214,8 @@ static int lima_sched_pipe_worker(void *param)
 
 	while (!kthread_should_stop()) {
 		int i, ret;
-		unsigned long saved_flags;
 
-		wait_event_interruptible(pipe->worker_wait,
+		wait_event_interruptible(pipe->worker_idle_wait,
 					 (task = lima_sched_pipe_get_task(pipe)) ||
 					 kthread_should_stop());
 
@@ -208,20 +236,24 @@ static int lima_sched_pipe_worker(void *param)
 		for (i = 0; i < pipe->num_mmu; i++)
 			lima_mmu_switch_vm(pipe->mmu[i], task->vm, false);
 
+		pipe->worker_is_busy = true;
+		pipe->worker_has_error = false;
 		if (!pipe->start_task(pipe->data, task)) {
-			ret = lima_sched_pipe_worker_wait_fence(task->fence);
+			ret = lima_sched_pipe_worker_wait_busy(pipe);
 			if (ret == -ERESTARTSYS)
 				return 0;
-			if (ret < 0) {
+			if (ret < 0 || pipe->worker_has_error) {
 				DRM_INFO("lima worker wait task fence error %d\n", ret);
 				pipe->reset(pipe->data);
 			}
+			else
+				dma_fence_signal(task->fence);
 		}
 
 	abort:
-		spin_lock_irqsave(&pipe->lock, saved_flags);
+		spin_lock(&pipe->lock);
 		list_del(&task->list);
-		spin_unlock_irqrestore(&pipe->lock, saved_flags);
+		spin_unlock(&pipe->lock);
 		lima_sched_task_delete(task);
 		/* the only writer of this counter */
 		pipe->fence_done_seqno++;
@@ -239,7 +271,8 @@ int lima_sched_pipe_init(struct lima_sched_pipe *pipe, const char *name)
 	INIT_LIST_HEAD(&pipe->queue);
 	pipe->fence_context = dma_fence_context_alloc(1);
 	spin_lock_init(&pipe->fence_lock);
-	init_waitqueue_head(&pipe->worker_wait);
+	init_waitqueue_head(&pipe->worker_idle_wait);
+	init_waitqueue_head(&pipe->worker_busy_wait);
 
 	worker = kthread_run(lima_sched_pipe_worker, pipe, name);
 	if (IS_ERR(worker)) {
@@ -285,11 +318,10 @@ static unsigned long lima_timeout_to_jiffies(u64 timeout_ns)
 
 static struct dma_fence *lima_sched_pipe_get_fence(struct lima_sched_pipe *pipe, u32 fence)
 {
-	unsigned long saved_flags;
 	struct lima_sched_task *task;
 	struct dma_fence *f = NULL;
 
-	spin_lock_irqsave(&pipe->lock, saved_flags);
+	spin_lock(&pipe->lock);
 	list_for_each_entry(task, &pipe->queue, list) {
 		if (task->fence->seqno < fence)
 			continue;
@@ -301,7 +333,7 @@ static struct dma_fence *lima_sched_pipe_get_fence(struct lima_sched_pipe *pipe,
 
 		break;
 	}
-	spin_unlock_irqrestore(&pipe->lock, saved_flags);
+	spin_unlock(&pipe->lock);
 
 	return f;
 }
@@ -334,11 +366,6 @@ int lima_sched_pipe_wait_fence(struct lima_sched_pipe *pipe, u32 fence, u64 time
 
 void lima_sched_pipe_task_done(struct lima_sched_pipe *pipe)
 {
-	struct lima_sched_task *task;
-
-	spin_lock(&pipe->lock);
-	task = list_first_entry(&pipe->queue, struct lima_sched_task, list);
-	spin_unlock(&pipe->lock);
-
-	dma_fence_signal(task->fence);
+	pipe->worker_is_busy = false;
+	wake_up(&pipe->worker_busy_wait);
 }
diff --git a/drivers/gpu/drm/lima/lima_sched.h b/drivers/gpu/drm/lima/lima_sched.h
index 2bfaf7b..b1c4fb4 100644
--- a/drivers/gpu/drm/lima/lima_sched.h
+++ b/drivers/gpu/drm/lima/lima_sched.h
@@ -47,7 +47,10 @@ struct lima_sched_pipe {
 	int num_mmu;
 
 	struct task_struct *worker;
-	wait_queue_head_t worker_wait;
+	wait_queue_head_t worker_idle_wait;
+	wait_queue_head_t worker_busy_wait;
+	bool worker_is_busy;
+	bool worker_has_error;
 
 	spinlock_t lock;
 	struct list_head queue;
