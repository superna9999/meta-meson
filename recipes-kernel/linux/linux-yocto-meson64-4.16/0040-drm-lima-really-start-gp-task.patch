From 70b3ba8d34ce7b061f4099b2cec43bb2e58a562c Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 4 May 2017 18:27:50 +0800
Subject: [PATCH] drm/lima: really start gp task

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 drivers/gpu/drm/lima/lima.h       |   2 +
 drivers/gpu/drm/lima/lima_drv.c   |  20 ++++-
 drivers/gpu/drm/lima/lima_gem.c   |   3 +-
 drivers/gpu/drm/lima/lima_gp.c    | 159 +++++++++++++++++++++++++++++++++++++-
 drivers/gpu/drm/lima/lima_mmu.c   |  78 ++++++++++++++-----
 drivers/gpu/drm/lima/lima_pp.c    |   1 +
 drivers/gpu/drm/lima/lima_sched.c |  10 ++-
 drivers/gpu/drm/lima/lima_sched.h |   5 +-
 drivers/gpu/drm/lima/lima_vm.c    |  22 +++++-
 drivers/gpu/drm/lima/lima_vm.h    |   2 +
 include/uapi/drm/lima_drm.h       |  13 ++++
 11 files changed, 287 insertions(+), 28 deletions(-)

diff --git a/drivers/gpu/drm/lima/lima.h b/drivers/gpu/drm/lima/lima.h
index bc0184a..861fd4c 100644
--- a/drivers/gpu/drm/lima/lima.h
+++ b/drivers/gpu/drm/lima/lima.h
@@ -52,6 +52,7 @@ struct lima_l2_cache {
 
 struct lima_mmu {
 	struct lima_ip ip;
+	struct lima_vm *vm;
 };
 
 struct lima_gp {
@@ -109,6 +110,7 @@ void lima_l2_cache_fini(struct lima_l2_cache *l2_cache);
 
 int lima_mmu_init(struct lima_mmu *mmu);
 void lima_mmu_fini(struct lima_mmu *mmu);
+void lima_mmu_switch_vm(struct lima_mmu *mmu, struct lima_vm *vm);
 
 int lima_gp_init(struct lima_gp *gp);
 void lima_gp_fini(struct lima_gp *gp);
diff --git a/drivers/gpu/drm/lima/lima_drv.c b/drivers/gpu/drm/lima/lima_drv.c
index a056090..5e528e8 100644
--- a/drivers/gpu/drm/lima/lima_drv.c
+++ b/drivers/gpu/drm/lima/lima_drv.c
@@ -64,9 +64,24 @@ static int lima_ioctl_gem_submit(struct drm_device *dev, void *data, struct drm_
 	void *frame;
 	struct lima_device *ldev = to_lima_dev(dev);
 
-	if (args->pipe >= ldev->num_pipe || args->nr_bos == 0 || args->frame_size == 0)
+	if (args->pipe >= ldev->num_pipe || args->nr_bos == 0)
 		return -EINVAL;
 
+	switch (ldev->gpu_type) {
+	case GPU_MALI400:
+		if (args->pipe == 0) {
+			if (args->frame_size != sizeof(struct drm_lima_m400_gp_frame))
+				return -EINVAL;
+		}
+		else {
+			if (args->frame_size != sizeof(struct drm_lima_m400_pp_frame))
+				return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
 	bos = kmalloc(args->nr_bos * sizeof(*bos), GFP_KERNEL);
 	if (!bos)
 		return -ENOMEM;
@@ -89,7 +104,8 @@ static int lima_ioctl_gem_submit(struct drm_device *dev, void *data, struct drm_
 			      frame, &args->fence);
 
 out1:
-	kfree(frame);
+	if (err)
+		kfree(frame);
 out0:
 	kfree(bos);
 	return err;
diff --git a/drivers/gpu/drm/lima/lima_gem.c b/drivers/gpu/drm/lima/lima_gem.c
index abc5e76..07e06e6 100644
--- a/drivers/gpu/drm/lima/lima_gem.c
+++ b/drivers/gpu/drm/lima/lima_gem.c
@@ -339,6 +339,7 @@ int lima_gem_submit(struct drm_file *file, struct lima_sched_pipe *pipe,
 	int i, err = 0;
 	struct ww_acquire_ctx ctx;
 	struct lima_sched_task *task;
+	struct lima_drm_priv *priv = to_lima_drm_priv(file);
 
 	lbos = kzalloc(sizeof(*lbos) * nr_bos, GFP_KERNEL);
 	if (!lbos)
@@ -359,7 +360,7 @@ int lima_gem_submit(struct drm_file *file, struct lima_sched_pipe *pipe,
 	if (err)
 		goto out0;
 
-	task = lima_sched_task_create();
+	task = lima_sched_task_create(&priv->vm, frame);
 	if (IS_ERR(task)) {
 		err = PTR_ERR(task);
 		goto out1;
diff --git a/drivers/gpu/drm/lima/lima_gp.c b/drivers/gpu/drm/lima/lima_gp.c
index 36c5dce..85293a4 100644
--- a/drivers/gpu/drm/lima/lima_gp.c
+++ b/drivers/gpu/drm/lima/lima_gp.c
@@ -1,22 +1,179 @@
 #include "lima.h"
 
+#define LIMA_GP_VSCL_START_ADDR                0x00
+#define LIMA_GP_VSCL_END_ADDR                  0x04
+#define LIMA_GP_PLBUCL_START_ADDR              0x08
+#define LIMA_GP_PLBUCL_END_ADDR                0x0c
+#define LIMA_GP_PLBU_ALLOC_START_ADDR          0x10
+#define LIMA_GP_PLBU_ALLOC_END_ADDR            0x14
+#define LIMA_GP_CMD                            0x20
+#define   LIMA_GP_CMD_START_VS                 (1 << 0)
+#define   LIMA_GP_CMD_START_PLBU               (1 << 1)
+#define   LIMA_GP_CMD_UPDATE_PLBU_ALLOC        (1 << 4)
+#define   LIMA_GP_CMD_RESET                    (1 << 5)
+#define   LIMA_GP_CMD_FORCE_HANG               (1 << 6)
+#define   LIMA_GP_CMD_STOP_BUS                 (1 << 9)
+#define   LIMA_GP_CMD_SOFT_RESET               (1 << 10)
+#define LIMA_GP_INT_RAWSTAT                    0x24
+#define LIMA_GP_INT_CLEAR                      0x28
+#define LIMA_GP_INT_MASK                       0x2C
+#define LIMA_GP_INT_STAT                       0x30
+#define   LIMA_GP_IRQ_VS_END_CMD_LST           (1 << 0)
+#define   LIMA_GP_IRQ_PLBU_END_CMD_LST         (1 << 1)
+#define   LIMA_GP_IRQ_PLBU_OUT_OF_MEM          (1 << 2)
+#define   LIMA_GP_IRQ_VS_SEM_IRQ               (1 << 3)
+#define   LIMA_GP_IRQ_PLBU_SEM_IRQ             (1 << 4)
+#define   LIMA_GP_IRQ_HANG                     (1 << 5)
+#define   LIMA_GP_IRQ_FORCE_HANG               (1 << 6)
+#define   LIMA_GP_IRQ_PERF_CNT_0_LIMIT         (1 << 7)
+#define   LIMA_GP_IRQ_PERF_CNT_1_LIMIT         (1 << 8)
+#define   LIMA_GP_IRQ_WRITE_BOUND_ERR          (1 << 9)
+#define   LIMA_GP_IRQ_SYNC_ERROR               (1 << 10)
+#define   LIMA_GP_IRQ_AXI_BUS_ERROR            (1 << 11)
+#define   LIMA_GP_IRQ_AXI_BUS_STOPPED          (1 << 12)
+#define   LIMA_GP_IRQ_VS_INVALID_CMD           (1 << 13)
+#define   LIMA_GP_IRQ_PLB_INVALID_CMD          (1 << 14)
+#define   LIMA_GP_IRQ_RESET_COMPLETED          (1 << 19)
+#define   LIMA_GP_IRQ_SEMAPHORE_UNDERFLOW      (1 << 20)
+#define   LIMA_GP_IRQ_SEMAPHORE_OVERFLOW       (1 << 21)
+#define   LIMA_GP_IRQ_PTR_ARRAY_OUT_OF_BOUNDS  (1 << 22)
+#define LIMA_GP_WRITE_BOUND_LOW                0x34
+#define LIMA_GP_PERF_CNT_0_ENABLE              0x3C
+#define LIMA_GP_PERF_CNT_1_ENABLE              0x40
+#define LIMA_GP_PERF_CNT_0_SRC                 0x44
+#define LIMA_GP_PERF_CNT_1_SRC                 0x48
+#define LIMA_GP_PERF_CNT_0_VALUE               0x4C
+#define LIMA_GP_PERF_CNT_1_VALUE               0x50
+#define LIMA_GP_PERF_CNT_0_LIMIT               0x54
+#define LIMA_GP_STATUS                         0x68
+#define   LIMA_GP_STATUS_VS_ACTIVE             (1 << 1)
+#define   LIMA_GP_STATUS_BUS_STOPPED	       (1 << 2)
+#define	  LIMA_GP_STATUS_PLBU_ACTIVE	       (1 << 3)
+#define	  LIMA_GP_STATUS_BUS_ERROR	       (1 << 6)
+#define	  LIMA_GP_STATUS_WRITE_BOUND_ERR       (1 << 8)
+#define LIMA_GP_VERSION                        0x6C
+#define LIMA_GP_VSCL_START_ADDR_READ           0x80
+#define LIMA_GP_PLBCL_START_ADDR_READ          0x84
+#define LIMA_GP_CONTR_AXI_BUS_ERROR_STAT       0x94
+
+#define LIMA_GP_IRQ_MASK_ALL		   \
+	(				   \
+	 LIMA_GP_IRQ_VS_END_CMD_LST      | \
+	 LIMA_GP_IRQ_PLBU_END_CMD_LST    | \
+	 LIMA_GP_IRQ_PLBU_OUT_OF_MEM     | \
+	 LIMA_GP_IRQ_VS_SEM_IRQ          | \
+	 LIMA_GP_IRQ_PLBU_SEM_IRQ        | \
+	 LIMA_GP_IRQ_HANG                | \
+	 LIMA_GP_IRQ_FORCE_HANG          | \
+	 LIMA_GP_IRQ_PERF_CNT_0_LIMIT    | \
+	 LIMA_GP_IRQ_PERF_CNT_1_LIMIT    | \
+	 LIMA_GP_IRQ_WRITE_BOUND_ERR     | \
+	 LIMA_GP_IRQ_SYNC_ERROR          | \
+	 LIMA_GP_IRQ_AXI_BUS_ERROR       | \
+	 LIMA_GP_IRQ_AXI_BUS_STOPPED     | \
+	 LIMA_GP_IRQ_VS_INVALID_CMD      | \
+	 LIMA_GP_IRQ_PLB_INVALID_CMD     | \
+	 LIMA_GP_IRQ_RESET_COMPLETED     | \
+	 LIMA_GP_IRQ_SEMAPHORE_UNDERFLOW | \
+	 LIMA_GP_IRQ_SEMAPHORE_OVERFLOW  | \
+	 LIMA_GP_IRQ_PTR_ARRAY_OUT_OF_BOUNDS)
+
+#define LIMA_GP_IRQ_MASK_USED		   \
+	(				   \
+	 LIMA_GP_IRQ_VS_END_CMD_LST      | \
+	 LIMA_GP_IRQ_PLBU_END_CMD_LST    | \
+	 LIMA_GP_IRQ_PLBU_OUT_OF_MEM     | \
+	 LIMA_GP_IRQ_FORCE_HANG          | \
+	 LIMA_GP_IRQ_WRITE_BOUND_ERR     | \
+	 LIMA_GP_IRQ_SYNC_ERROR          | \
+	 LIMA_GP_IRQ_AXI_BUS_ERROR       | \
+	 LIMA_GP_IRQ_VS_INVALID_CMD      | \
+	 LIMA_GP_IRQ_PLB_INVALID_CMD     | \
+	 LIMA_GP_IRQ_SEMAPHORE_UNDERFLOW | \
+	 LIMA_GP_IRQ_SEMAPHORE_OVERFLOW  | \
+	 LIMA_GP_IRQ_PTR_ARRAY_OUT_OF_BOUNDS)
+
+#define gp_write(reg, data) writel(data, gp->ip.iomem + LIMA_GP_##reg)
+#define gp_read(reg) readl(gp->ip.iomem + LIMA_GP_##reg)
+
+static irqreturn_t lima_gp_irq_handler(int irq, void *data)
+{
+	struct lima_gp *gp = data;
+	struct lima_device *dev = gp->ip.dev;
+	u32 state = gp_read(INT_STAT);
+	u32 status = gp_read(STATUS);
+
+	dev_info_ratelimited(dev->dev, "gp irq state=%x status=%x\n", state, status);
+	gp_write(INT_CLEAR, state);
+	return IRQ_NONE;
+}
+
 static int lima_gp_start_task(void *data, struct lima_sched_task *task)
 {
 	struct lima_gp *gp = data;
+	struct drm_lima_m400_gp_frame *frame = task->frame;
+	u32 cmd = 0;
 
 	DRM_INFO("lima start task gp %s\n", gp->ip.name);
+
+	if (frame->vs_cmd_start > frame->vs_cmd_end ||
+	    frame->plbu_cmd_start > frame->plbu_cmd_end ||
+	    frame->tile_heap_start > frame->tile_heap_end)
+		return -EINVAL;
+
+	if (frame->vs_cmd_start != frame->vs_cmd_end)
+		cmd |= LIMA_GP_CMD_START_VS;
+	if (frame->plbu_cmd_start != frame->plbu_cmd_end)
+		cmd |= LIMA_GP_CMD_START_PLBU;
+
+	gp_write(VSCL_START_ADDR, frame->vs_cmd_start);
+	gp_write(VSCL_END_ADDR, frame->vs_cmd_end);
+	gp_write(PLBUCL_START_ADDR, frame->plbu_cmd_start);
+	gp_write(PLBUCL_END_ADDR, frame->plbu_cmd_end);
+	gp_write(PLBU_ALLOC_START_ADDR, frame->tile_heap_start);
+	gp_write(PLBU_ALLOC_END_ADDR, frame->tile_heap_end);
+
+	gp_write(CMD, LIMA_GP_CMD_UPDATE_PLBU_ALLOC);
+	gp_write(CMD, cmd);
+
 	dma_fence_signal(task->fence);
 	return 0;
 }
 
 int lima_gp_init(struct lima_gp *gp)
 {
+	struct lima_device *dev = gp->ip.dev;
+	int timeout, err;
+
+	gp_write(INT_MASK, 0);
+	gp_write(INT_CLEAR, LIMA_GP_IRQ_RESET_COMPLETED);
+	gp_write(CMD, LIMA_GP_CMD_SOFT_RESET);
+	for (timeout = 1000; timeout > 0; timeout--) {
+		if (gp_read(INT_RAWSTAT) & LIMA_GP_IRQ_RESET_COMPLETED)
+			break;
+	}
+	if (!timeout) {
+		dev_err(dev->dev, "gp reset time out\n");
+		return -ETIMEDOUT;
+	}
+
+	err = devm_request_irq(dev->dev, gp->ip.irq, lima_gp_irq_handler, 0,
+			       gp->ip.name, gp);
+	if (err) {
+		dev_err(dev->dev, "gp %s fail to request irq\n", gp->ip.name);
+		return err;
+	}
+
+	gp_write(INT_CLEAR, LIMA_GP_IRQ_MASK_ALL);
+	gp_write(INT_MASK, LIMA_GP_IRQ_MASK_USED);
+
 	gp->pipe.start_task = lima_gp_start_task;
 	gp->pipe.data = gp;
+	gp->pipe.mmu = &gp->mmu;
 	return 0;
 }
 
 void lima_gp_fini(struct lima_gp *gp)
 {
-	
+
 }
diff --git a/drivers/gpu/drm/lima/lima_mmu.c b/drivers/gpu/drm/lima/lima_mmu.c
index 56915ba..c3ba389 100644
--- a/drivers/gpu/drm/lima/lima_mmu.c
+++ b/drivers/gpu/drm/lima/lima_mmu.c
@@ -10,7 +10,7 @@
 #define   LIMA_MMU_STATUS_IDLE                (1 << 3)
 #define   LIMA_MMU_STATUS_REPLAY_BUFFER_EMPTY (1 << 4)
 #define   LIMA_MMU_STATUS_PAGE_FAULT_IS_WRITE (1 << 5)
-#define   LIMA_MMU_STATUS_STALL_NOT_ACTIVE    (1 << 31)
+#define   LIMA_MMU_STATUS_BUS_ID(x)           ((x >> 6) & 0x1F)
 #define LIMA_MMU_COMMAND		  0x0008
 #define   LIMA_MMU_COMMAND_ENABLE_PAGING    0x00
 #define   LIMA_MMU_COMMAND_DISABLE_PAGING   0x01
@@ -31,20 +31,48 @@
 #define mmu_write(reg, data) writel(data, mmu->ip.iomem + LIMA_MMU_##reg)
 #define mmu_read(reg) readl(mmu->ip.iomem + LIMA_MMU_##reg)
 
+#define lima_mmu_send_command(command, condition)	     \
+({							     \
+	int __timeout, __ret = 0;			     \
+							     \
+	mmu_write(COMMAND, command);			     \
+	for (__timeout = 1000; __timeout > 0; __timeout--) { \
+		if (condition)				     \
+			break;				     \
+	}						     \
+	if (!__timeout)	{				     \
+		dev_err(dev->dev, "mmu command %x timeout\n", command); \
+		__ret = -ETIMEDOUT;			     \
+	}						     \
+	__ret;						     \
+})
 
 static irqreturn_t lima_mmu_irq_handler(int irq, void *data)
 {
 	struct lima_mmu *mmu = data;
 	struct lima_device *dev = mmu->ip.dev;
+	u32 status = mmu_read(INT_STATUS);
 
-	dev_info(dev->dev, "mmu %s irq\n", mmu->ip.name);
+	if (status & LIMA_MMU_INT_PAGE_FAULT) {
+		u32 fault = mmu_read(PAGE_FAULT_ADDR);
+		dev_info(dev->dev, "mmu page fault at 0x%x from bus id %d of type %s on %s\n",
+			 fault, LIMA_MMU_STATUS_BUS_ID(status),
+			 status & LIMA_MMU_STATUS_PAGE_FAULT_IS_WRITE ? "write" : "read",
+			 mmu->ip.name);
+	}
+
+	if (status & LIMA_MMU_INT_READ_BUS_ERROR) {
+		dev_info(dev->dev, "mmu %s irq bus error\n", mmu->ip.name);
+	}
+
+	mmu_write(INT_CLEAR, LIMA_MMU_INT_PAGE_FAULT|LIMA_MMU_INT_READ_BUS_ERROR);
 	return IRQ_NONE;
 }
 
 int lima_mmu_init(struct lima_mmu *mmu)
 {
 	struct lima_device *dev = mmu->ip.dev;
-	int err, timeout;
+	int err;
 
 	mmu_write(DTE_ADDR, 0xCAFEBABE);
 	if (mmu_read(DTE_ADDR) != 0xCAFEB000) {
@@ -52,15 +80,9 @@ int lima_mmu_init(struct lima_mmu *mmu)
 		return -EIO;
 	}
 
-	mmu_write(COMMAND, LIMA_MMU_COMMAND_HARD_RESET);
-	for (timeout = 1000; timeout > 0; timeout--) {
-		if (mmu_read(DTE_ADDR) == 0)
-			break;
-	}
-	if (!timeout) {
-		dev_err(dev->dev, "mmu %s reset timeout\n", mmu->ip.name);
-		return -ETIMEDOUT;
-	}
+	err = lima_mmu_send_command(LIMA_MMU_COMMAND_HARD_RESET, mmu_read(DTE_ADDR) == 0);
+	if (err)
+		return err;
 
 	err = devm_request_irq(dev->dev, mmu->ip.irq, lima_mmu_irq_handler, 0,
 			       mmu->ip.name, mmu);
@@ -71,15 +93,12 @@ int lima_mmu_init(struct lima_mmu *mmu)
 
 	mmu_write(INT_MASK, LIMA_MMU_INT_PAGE_FAULT | LIMA_MMU_INT_READ_BUS_ERROR);
 	mmu_write(DTE_ADDR, dev->empty_vm.pd.dma);
-	mmu_write(COMMAND, LIMA_MMU_COMMAND_ENABLE_PAGING);
-	for (timeout = 1000; timeout > 0; timeout--) {
-		if (mmu_read(STATUS) & LIMA_MMU_STATUS_PAGING_ENABLED)
-			break;
-	}
-	if (!timeout) {
-		dev_err(dev->dev, "mmu %s enable paging time out\n", mmu->ip.name);
-		return -ETIMEDOUT;
-	}
+	err = lima_mmu_send_command(LIMA_MMU_COMMAND_ENABLE_PAGING,
+				    mmu_read(STATUS) & LIMA_MMU_STATUS_PAGING_ENABLED);
+	if (err)
+		return err;
+
+	mmu->vm = &dev->empty_vm;
 
 	return 0;
 }
@@ -88,3 +107,20 @@ void lima_mmu_fini(struct lima_mmu *mmu)
 {
 
 }
+
+void lima_mmu_switch_vm(struct lima_mmu *mmu, struct lima_vm *vm)
+{
+	struct lima_device *dev = mmu->ip.dev;
+
+	if (mmu->vm == vm)
+		return;
+
+	lima_mmu_send_command(LIMA_MMU_COMMAND_ENABLE_STALL,
+			      mmu_read(STATUS) & LIMA_MMU_STATUS_STALL_ACTIVE);
+	mmu_write(DTE_ADDR, vm->pd.dma);
+	/* flush the TLB */
+	mmu_write(COMMAND, LIMA_MMU_COMMAND_ZAP_CACHE);
+	lima_mmu_send_command(LIMA_MMU_COMMAND_DISABLE_STALL,
+			      !(mmu_read(STATUS) & LIMA_MMU_STATUS_STALL_ACTIVE));
+	mmu->vm = vm;
+}
diff --git a/drivers/gpu/drm/lima/lima_pp.c b/drivers/gpu/drm/lima/lima_pp.c
index 1a845fc..03b147c 100644
--- a/drivers/gpu/drm/lima/lima_pp.c
+++ b/drivers/gpu/drm/lima/lima_pp.c
@@ -13,6 +13,7 @@ int lima_pp_init(struct lima_pp *pp)
 {
 	pp->pipe.start_task = lima_pp_start_task;
 	pp->pipe.data = pp;
+	pp->pipe.mmu = &pp->mmu;
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/lima/lima_sched.c b/drivers/gpu/drm/lima/lima_sched.c
index b41b9c5..d33dc7b 100644
--- a/drivers/gpu/drm/lima/lima_sched.c
+++ b/drivers/gpu/drm/lima/lima_sched.c
@@ -44,7 +44,7 @@ static const struct dma_fence_ops lima_fence_ops = {
 	.release = lima_fence_release,
 };
 
-struct lima_sched_task *lima_sched_task_create(void)
+struct lima_sched_task *lima_sched_task_create(struct lima_vm *vm, void *frame)
 {
 	struct lima_sched_task *task;
 
@@ -52,6 +52,9 @@ struct lima_sched_task *lima_sched_task_create(void)
 	if (!task)
 		return ERR_PTR(-ENOMEM);
 
+	task->vm = vm;
+	task->frame = frame;
+
 	return task;
 }
 
@@ -68,6 +71,9 @@ void lima_sched_task_delete(struct lima_sched_task *task)
 	if (task->dep)
 		kfree(task->dep);
 
+	if (task->frame)
+		kfree(task->frame);
+
 	kfree(task);
 }
 
@@ -164,6 +170,8 @@ static int lima_sched_pipe_worker(void *param)
 			}
 		}
 
+		lima_mmu_switch_vm(pipe->mmu, task->vm);
+
 		if (!pipe->start_task(pipe->data, task)) {
 			while (dma_fence_wait(task->fence, true) == -ERESTARTSYS) {
 				if (kthread_should_stop())
diff --git a/drivers/gpu/drm/lima/lima_sched.h b/drivers/gpu/drm/lima/lima_sched.h
index 1946a60..4508d19 100644
--- a/drivers/gpu/drm/lima/lima_sched.h
+++ b/drivers/gpu/drm/lima/lima_sched.h
@@ -27,6 +27,8 @@
 
 struct lima_sched_task {
 	struct list_head list;
+	struct lima_vm *vm;
+	void *frame;
 
 	struct dma_fence **dep;
 	int num_dep;
@@ -40,6 +42,7 @@ struct lima_sched_pipe {
 
 	u64 fence_context;
 	spinlock_t fence_lock;
+	struct lima_mmu *mmu;
 
 	struct task_struct *worker;
 	wait_queue_head_t worker_wait;
@@ -54,7 +57,7 @@ struct lima_sched_pipe {
 	void *data;
 };
 
-struct lima_sched_task *lima_sched_task_create(void);
+struct lima_sched_task *lima_sched_task_create(struct lima_vm *vm, void *frame);
 void lima_sched_task_delete(struct lima_sched_task *task);
 int lima_sched_task_add_dep(struct lima_sched_task *task, struct dma_fence *fence);
 int lima_sched_task_queue(struct lima_sched_pipe *pipe, struct lima_sched_task *task);
diff --git a/drivers/gpu/drm/lima/lima_vm.c b/drivers/gpu/drm/lima/lima_vm.c
index ccd44c9..06e8197 100644
--- a/drivers/gpu/drm/lima/lima_vm.c
+++ b/drivers/gpu/drm/lima/lima_vm.c
@@ -76,9 +76,9 @@ int lima_vm_map(struct lima_vm *vm, dma_addr_t dma, u32 va, u32 size)
 				goto err_out1;
 			}
 			memset(vm->pts[pde].cpu, 0, LIMA_PAGE_SIZE);
+			vm->pd.cpu[pde] = vm->pts[pde].dma | LIMA_VM_FLAG_PRESENT;
 		}
 
-		vm->pd.cpu[pde] = vm->pts[pde].dma | LIMA_VM_FLAG_PRESENT;
 		vm->pts[pde].cpu[pte] = dma | LIMA_VM_FLAGS_CACHE;
 	}
 
@@ -178,3 +178,23 @@ void lima_vm_fini(struct lima_vm *vm)
 	if (vm->pd.cpu)
 		dma_free_coherent(vm->dev, LIMA_PAGE_SIZE, vm->pd.cpu, vm->pd.dma);
 }
+
+void lima_vm_print(struct lima_vm *vm)
+{
+	int i, j;
+
+	if (!vm->pd.cpu)
+		return;
+
+	for (i = 0; i < LIMA_PAGE_ENT_NUM; i++) {
+		if (vm->pd.cpu[i]) {
+			printk(KERN_INFO "lima vm pd %03x:%08x\n", i, vm->pd.cpu[i]);
+			if ((vm->pd.cpu[i] & ~LIMA_VM_FLAG_MASK) != vm->pts[i].dma)
+				printk(KERN_INFO "pd %x not match pt %x\n", i, vm->pts[i].dma);
+			for (j = 0; j < LIMA_PAGE_ENT_NUM; j++) {
+				if (vm->pts[i].cpu[j])
+					printk(KERN_INFO "  pt %03x:%08x\n", j, vm->pts[i].cpu[j]);
+			}
+		}
+	}
+}
diff --git a/drivers/gpu/drm/lima/lima_vm.h b/drivers/gpu/drm/lima/lima_vm.h
index 4e0fde1..86e8860 100644
--- a/drivers/gpu/drm/lima/lima_vm.h
+++ b/drivers/gpu/drm/lima/lima_vm.h
@@ -49,4 +49,6 @@ void lima_vm_fini(struct lima_vm *vm);
 int lima_vm_map(struct lima_vm *vm, dma_addr_t dma, u32 va, u32 size);
 int lima_vm_unmap(struct lima_vm *vm, u32 va, u32 size);
 
+void lima_vm_print(struct lima_vm *vm);
+
 #endif
diff --git a/include/uapi/drm/lima_drm.h b/include/uapi/drm/lima_drm.h
index 03a66ed..40770c2 100644
--- a/include/uapi/drm/lima_drm.h
+++ b/include/uapi/drm/lima_drm.h
@@ -66,6 +66,19 @@ struct drm_lima_gem_submit_bo {
 	__u32 flags;   /* in */
 };
 
+struct drm_lima_m400_gp_frame {
+	__u32 vs_cmd_start;
+	__u32 vs_cmd_end;
+	__u32 plbu_cmd_start;
+	__u32 plbu_cmd_end;
+	__u32 tile_heap_start;
+	__u32 tile_heap_end;
+};
+
+struct drm_lima_m400_pp_frame {
+	__u32 dummy;
+};
+
 struct drm_lima_gem_submit {
 	__u32 fence;       /* out */
 	__u32 pipe;        /* in */
